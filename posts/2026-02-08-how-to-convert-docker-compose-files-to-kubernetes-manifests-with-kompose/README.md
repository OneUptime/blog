# How to Convert Docker Compose Files to Kubernetes Manifests with Kompose

Author: [nawazdhandala](https://github.com/nawazdhandala)

Tags: Docker, Kubernetes, Kompose, Docker Compose, Migration, DevOps, Container Orchestration

Description: Learn how to use Kompose to convert Docker Compose YAML files into Kubernetes deployments, services, and volumes.

---

You have a Docker Compose file that works perfectly on your development machine. Now you need to deploy the same application to Kubernetes. Rewriting everything from scratch as Kubernetes manifests is tedious and error-prone. That is where Kompose comes in. It reads your Docker Compose files and generates equivalent Kubernetes Deployments, Services, PersistentVolumeClaims, and ConfigMaps automatically.

Kompose is not a magic bullet. The generated manifests usually need some tweaking for production use. But it gives you a solid starting point and eliminates the boilerplate.

## Installing Kompose

Kompose is a single binary. Install it based on your operating system.

On macOS with Homebrew:

```bash
# Install Kompose via Homebrew
brew install kompose
```

On Linux, download the binary directly:

```bash
# Download the latest Kompose binary for Linux
curl -L https://github.com/kubernetes/kompose/releases/latest/download/kompose-linux-amd64 -o kompose

# Make it executable and move to PATH
chmod +x kompose
sudo mv kompose /usr/local/bin/
```

Verify the installation:

```bash
# Check that Kompose is installed correctly
kompose version
```

## A Sample Docker Compose File

Let us work with a realistic example, a web application with a Redis cache and a PostgreSQL database.

```yaml
# docker-compose.yml - A typical three-service application
version: "3.8"

services:
  web:
    image: myapp/web:1.2.0
    ports:
      - "8080:8080"
    environment:
      DATABASE_URL: postgres://appuser:secret@db:5432/myapp
      REDIS_URL: redis://cache:6379
    depends_on:
      - db
      - cache
    restart: always
    deploy:
      replicas: 2

  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: appuser
      POSTGRES_PASSWORD: secret
      POSTGRES_DB: myapp
    volumes:
      - pgdata:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    restart: always

  cache:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    restart: always
    command: redis-server --maxmemory 256mb --maxmemory-policy allkeys-lru

volumes:
  pgdata:
```

## Basic Conversion

The simplest usage converts your Compose file into Kubernetes manifests in the current directory.

```bash
# Convert docker-compose.yml to Kubernetes YAML files
kompose convert
```

This produces several files:

```
web-deployment.yaml
web-service.yaml
db-deployment.yaml
db-service.yaml
cache-deployment.yaml
cache-service.yaml
pgdata-persistentvolumeclaim.yaml
```

Each Compose service becomes a Kubernetes Deployment and a Service. Named volumes become PersistentVolumeClaims.

## Understanding the Generated Manifests

Let us look at what Kompose generates for the web service.

The Deployment:

```yaml
# web-deployment.yaml - Generated by Kompose
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    io.kompose.service: web
  name: web
spec:
  replicas: 2
  selector:
    matchLabels:
      io.kompose.service: web
  template:
    metadata:
      labels:
        io.kompose.service: web
    spec:
      containers:
        - env:
            - name: DATABASE_URL
              value: postgres://appuser:secret@db:5432/myapp
            - name: REDIS_URL
              value: redis://cache:6379
          image: myapp/web:1.2.0
          name: web
          ports:
            - containerPort: 8080
              protocol: TCP
      restartPolicy: Always
```

The Service:

```yaml
# web-service.yaml - Generated by Kompose
apiVersion: v1
kind: Service
metadata:
  labels:
    io.kompose.service: web
  name: web
spec:
  ports:
    - name: "8080"
      port: 8080
      targetPort: 8080
  selector:
    io.kompose.service: web
```

Notice that Kompose picked up the `replicas: 2` from the `deploy` section and set environment variables as plain-text values in the Deployment spec. The service names in Compose (`db`, `cache`) map directly to Kubernetes Service names, so DNS resolution continues to work the same way.

## Output Options

Kompose supports several output formats beyond plain YAML files.

Write all manifests to a single file:

```bash
# Combine all generated manifests into one file
kompose convert -o k8s-manifests.yaml
```

Generate a Helm chart instead of raw manifests:

```bash
# Generate a Helm chart directory structure
kompose convert --chart
```

This creates a `chart/` directory with `Chart.yaml`, `values.yaml`, and a `templates/` folder containing all the manifests. Useful if you want to parameterize values later.

Output JSON instead of YAML:

```bash
# Generate Kubernetes manifests in JSON format
kompose convert --json
```

## Using Labels for Fine-Grained Control

Kompose reads special labels from your Compose file to control the generated Kubernetes resources. This is where the tool becomes really powerful.

```yaml
# docker-compose.yml with Kompose labels
version: "3.8"

services:
  web:
    image: myapp/web:1.2.0
    ports:
      - "8080:8080"
    labels:
      # Expose as a NodePort service instead of ClusterIP
      kompose.service.type: nodeport
      # Set resource requests and limits
      kompose.service.expose: "true"
      # Create an Ingress resource
      kompose.service.expose.ingress-class-name: "nginx"
      # Add health check as a liveness probe
      kompose.service.healthcheck.liveness.http_get_port: 8080
      kompose.service.healthcheck.liveness.http_get_path: /health
    environment:
      DATABASE_URL: postgres://appuser:secret@db:5432/myapp

  db:
    image: postgres:16-alpine
    labels:
      # Use a specific storage class for the volume
      kompose.volume.storage-class-name: "standard"
      kompose.volume.size: "10Gi"
    volumes:
      - pgdata:/var/lib/postgresql/data

volumes:
  pgdata:
```

Common Kompose labels:

| Label | Effect |
|-------|--------|
| `kompose.service.type` | Sets Service type (nodeport, loadbalancer, clusterip) |
| `kompose.service.expose` | Creates an Ingress resource |
| `kompose.volume.size` | Sets PVC storage size |
| `kompose.volume.storage-class-name` | Specifies the StorageClass |
| `kompose.image-pull-policy` | Sets imagePullPolicy (Always, IfNotPresent, Never) |

## Handling Secrets

Plain environment variables in Compose files become plain-text env vars in Kubernetes Deployments. That is fine for development, but you should use Kubernetes Secrets in production.

After running `kompose convert`, replace inline env values with Secret references:

```yaml
# Modified web-deployment.yaml - using Kubernetes Secrets
spec:
  containers:
    - name: web
      image: myapp/web:1.2.0
      env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: database-url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: redis-url
```

Create the corresponding Secret:

```bash
# Create a Kubernetes Secret with the application credentials
kubectl create secret generic app-secrets \
  --from-literal=database-url='postgres://appuser:secret@db:5432/myapp' \
  --from-literal=redis-url='redis://cache:6379'
```

## Deploy the Generated Manifests

Once you have reviewed and adjusted the manifests, apply them to your cluster.

```bash
# Apply all generated manifests to the current namespace
kubectl apply -f .

# Or if you combined them into a single file
kubectl apply -f k8s-manifests.yaml

# Check that all pods are running
kubectl get pods

# Check services
kubectl get svc
```

## Limitations to Watch For

Kompose handles the common cases well, but some Compose features do not translate cleanly:

**`depends_on`**: Kubernetes does not have a built-in equivalent. Kompose ignores it. You need init containers or application-level retry logic instead.

**`build` directives**: Kompose skips `build` sections since Kubernetes pulls pre-built images. Build your images and push them to a registry before converting.

**Host networking**: `network_mode: host` does not map well to Kubernetes networking. You will need to refactor this.

**Named networks**: Compose networks become Kubernetes NetworkPolicies only in some cases. Most of the time, Kompose ignores custom networks since all pods in a namespace can communicate by default in Kubernetes.

**Bind mounts**: Local file paths (like `./config:/etc/config`) cannot be converted to PVCs. Use ConfigMaps or Secrets for configuration files instead.

## A Practical Workflow

Here is the workflow I recommend for migrating from Compose to Kubernetes:

1. Run `kompose convert` to generate the initial manifests
2. Review each generated file and adjust resource limits, health checks, and secrets
3. Add readiness probes (Kompose does not always generate these)
4. Replace plain-text secrets with Kubernetes Secret references
5. Test in a development cluster (Minikube or Kind)
6. Iterate and refine

```bash
# Full workflow from Compose to running Kubernetes deployment
kompose convert -o k8s/

# Review the generated files
ls k8s/

# Apply to a test cluster
kubectl apply -f k8s/

# Verify everything is running
kubectl get all

# Check logs if something is not right
kubectl logs -l io.kompose.service=web
```

## Conclusion

Kompose bridges the gap between Docker Compose and Kubernetes. It will not give you production-ready manifests out of the box, but it eliminates the tedious work of translating service definitions, port mappings, and volume configurations by hand. Use it as a starting point, then layer on Kubernetes-specific features like Secrets, resource limits, and health checks. For teams migrating existing Compose-based applications to Kubernetes, Kompose saves hours of manual YAML writing and reduces the chance of translation errors.
