# How to Use Ansible delegate_facts

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: Ansible, Delegation, Facts, Configuration Management

Description: Learn how to use delegate_facts in Ansible to assign gathered facts to delegate hosts instead of the original target host.

---

When you combine `delegate_to` with fact-gathering tasks in Ansible, there is a subtle but important question: which host gets the facts? By default, facts gathered by a delegated task are assigned to the original host in the play, not the host where the task actually ran. The `delegate_facts: true` directive changes this behavior, assigning facts to the delegate host instead. This is critical for cross-host orchestration where you need to share information between hosts.

## The Problem delegate_facts Solves

Consider this scenario: you are deploying an application server, and you need to know the IP address of the database server. You could hardcode it, but what if the database server's IP is dynamic?

Without `delegate_facts`, gathering facts on the database server from an app server play assigns those facts to the app server, which is confusing and wrong.

```yaml
# without-delegate-facts.yml - Showing the default (confusing) behavior
---
- name: Show default fact assignment behavior
  hosts: appservers
  gather_facts: false
  tasks:
    - name: Gather facts from the database server
      ansible.builtin.setup:
      delegate_to: db.example.com
      # WITHOUT delegate_facts: true, the facts gathered from db.example.com
      # are stored under the APPSERVER's hostvars, not db.example.com's

    - name: This shows the DB server's facts, stored under the app server
      ansible.builtin.debug:
        msg: "ansible_default_ipv4 for {{ inventory_hostname }}: {{ ansible_default_ipv4.address }}"
      # This actually shows the DB server's IP, but it is stored as if it
      # belongs to the app server. This is misleading.
```

## Using delegate_facts: true

Adding `delegate_facts: true` fixes this by assigning the gathered facts to the correct host.

```yaml
# with-delegate-facts.yml - Correct fact assignment to delegate host
---
- name: Gather facts from database server and assign them correctly
  hosts: appservers
  gather_facts: true   # Gather app server facts normally
  tasks:
    - name: Gather facts from the database server
      ansible.builtin.setup:
      delegate_to: db.example.com
      delegate_facts: true    # Facts go to db.example.com's hostvars
      run_once: true          # Only need to do this once

    - name: Now access DB server facts correctly through hostvars
      ansible.builtin.debug:
        msg: >
          App server: {{ inventory_hostname }} ({{ ansible_default_ipv4.address }})
          DB server IP: {{ hostvars['db.example.com']['ansible_default_ipv4']['address'] }}

    - name: Configure application to connect to database
      ansible.builtin.template:
        src: app-config.yml.j2
        dest: /opt/myapp/config.yml
      vars:
        db_host: "{{ hostvars['db.example.com']['ansible_default_ipv4']['address'] }}"
        db_port: 5432
```

## Practical Example: Multi-Tier Application Setup

Here is a realistic example where `delegate_facts` is essential. You are setting up a three-tier application (load balancer, app servers, database) and each tier needs to know about the others.

```yaml
# multi-tier-setup.yml - Cross-tier fact sharing
---
- name: Gather facts from all tiers
  hosts: appservers
  gather_facts: true
  tasks:
    # Gather facts from load balancer
    - name: Gather load balancer facts
      ansible.builtin.setup:
      delegate_to: "{{ item }}"
      delegate_facts: true
      loop: "{{ groups['loadbalancers'] }}"
      run_once: true

    # Gather facts from database servers
    - name: Gather database server facts
      ansible.builtin.setup:
      delegate_to: "{{ item }}"
      delegate_facts: true
      loop: "{{ groups['databases'] }}"
      run_once: true

    # Now configure the app server with knowledge of all tiers
    - name: Configure application with tier addresses
      ansible.builtin.template:
        src: app-config.yml.j2
        dest: /opt/myapp/config.yml
      vars:
        lb_ip: "{{ hostvars[groups['loadbalancers'][0]]['ansible_default_ipv4']['address'] }}"
        db_primary_ip: "{{ hostvars[groups['databases'][0]]['ansible_default_ipv4']['address'] }}"
        db_replica_ip: "{{ hostvars[groups['databases'][1]]['ansible_default_ipv4']['address'] | default('none') }}"
```

The template can then use these variables:

```yaml
# templates/app-config.yml.j2
# Application configuration - auto-generated by Ansible
database:
  primary:
    host: {{ db_primary_ip }}
    port: 5432
  replica:
    host: {{ db_replica_ip }}
    port: 5432

load_balancer:
  address: {{ lb_ip }}

app_servers:
{% for host in groups['appservers'] %}
  - name: {{ host }}
    address: {{ hostvars[host]['ansible_default_ipv4']['address'] }}
{% endfor %}
```

## delegate_facts with set_fact

You can also use `delegate_facts: true` with `set_fact` to store custom facts on another host.

```yaml
# set-fact-delegate.yml - Store custom facts on delegate host
---
- name: Store deployment state across hosts
  hosts: appservers
  tasks:
    - name: Check application version
      ansible.builtin.shell: cat /opt/myapp/VERSION
      register: app_version
      changed_when: false

    - name: Store version info on the monitoring server
      ansible.builtin.set_fact:
        monitored_app_versions: >-
          {{ hostvars['monitor.example.com'].get('monitored_app_versions', {}) |
             combine({inventory_hostname: app_version.stdout}) }}
      delegate_to: monitor.example.com
      delegate_facts: true

    - name: Show collected versions (from monitor's perspective)
      ansible.builtin.debug:
        msg: "Versions: {{ hostvars['monitor.example.com']['monitored_app_versions'] }}"
      run_once: true
```

## Building a Dynamic Inventory Configuration

A powerful pattern is using `delegate_facts` to build configuration files that reference multiple hosts dynamically.

```yaml
# haproxy-config.yml - Generate load balancer config from app server facts
---
- name: Configure HAProxy with dynamically discovered backends
  hosts: loadbalancers
  tasks:
    # First, gather facts from all app servers
    - name: Gather facts from all application servers
      ansible.builtin.setup:
      delegate_to: "{{ item }}"
      delegate_facts: true
      loop: "{{ groups['appservers'] }}"

    # Now generate the HAProxy config using those facts
    - name: Generate HAProxy configuration
      ansible.builtin.template:
        src: haproxy.cfg.j2
        dest: /etc/haproxy/haproxy.cfg
      become: true
      notify: Reload HAProxy

  handlers:
    - name: Reload HAProxy
      ansible.builtin.systemd:
        name: haproxy
        state: reloaded
      become: true
```

The HAProxy template uses the gathered facts:

```
# templates/haproxy.cfg.j2
global
    log /dev/log local0
    maxconn 4096

defaults
    mode http
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms

frontend web_frontend
    bind *:80
    default_backend web_backend

backend web_backend
    balance roundrobin
    option httpchk GET /health
{% for host in groups['appservers'] %}
    server {{ host }} {{ hostvars[host]['ansible_default_ipv4']['address'] }}:8080 check inter 5s fall 3 rise 2
{% endfor %}
```

## delegate_facts with Cloud Inventory

When working with dynamic cloud inventories, `delegate_facts` is particularly useful for discovering service endpoints.

```yaml
# cloud-service-discovery.yml - Discover cloud service endpoints
---
- name: Configure app servers with cloud service endpoints
  hosts: appservers
  gather_facts: true
  tasks:
    - name: Discover RDS endpoint from AWS
      amazon.aws.rds_instance_info:
        db_instance_identifier: myapp-production
        region: us-east-1
      register: rds_info
      delegate_to: localhost
      run_once: true

    - name: Store RDS endpoint as a fact on localhost
      ansible.builtin.set_fact:
        rds_endpoint: "{{ rds_info.instances[0].endpoint.address }}"
        rds_port: "{{ rds_info.instances[0].endpoint.port }}"
      delegate_to: localhost
      delegate_facts: true
      run_once: true

    - name: Discover ElastiCache endpoint
      amazon.aws.elasticache_info:
        name: myapp-cache
        region: us-east-1
      register: cache_info
      delegate_to: localhost
      run_once: true

    - name: Store cache endpoint
      ansible.builtin.set_fact:
        cache_endpoint: "{{ cache_info.elasticache_clusters[0].cache_nodes[0].endpoint.address }}"
      delegate_to: localhost
      delegate_facts: true
      run_once: true

    - name: Configure application with discovered endpoints
      ansible.builtin.template:
        src: database-config.yml.j2
        dest: /opt/myapp/database.yml
      vars:
        db_host: "{{ hostvars['localhost']['rds_endpoint'] }}"
        db_port: "{{ hostvars['localhost']['rds_port'] }}"
        cache_host: "{{ hostvars['localhost']['cache_endpoint'] }}"
```

## When NOT to Use delegate_facts

There are situations where you should not use `delegate_facts`:

```yaml
# when-not-to-use.yml - Cases where delegate_facts is not needed
---
- name: Cases where delegate_facts is unnecessary
  hosts: webservers
  tasks:
    # You do NOT need delegate_facts for simple API calls
    # API results are registered as variables, not facts
    - name: Call an API (delegate_facts not needed)
      ansible.builtin.uri:
        url: http://api.example.com/status
      register: api_status
      delegate_to: localhost
      # register stores the result under the CURRENT host's variables
      # delegate_facts only affects ansible_* facts from setup module

    # You do NOT need delegate_facts when you just want to run
    # a command on another host and do not care about its facts
    - name: Run cleanup on another host
      ansible.builtin.shell: rm -rf /tmp/old-releases/*
      delegate_to: build.example.com
```

## Summary

The `delegate_facts: true` directive solves a specific but important problem: correctly assigning gathered facts to the host they came from when using task delegation. Without it, facts from a delegated `setup` or `set_fact` task are stored under the wrong host's `hostvars`. Use it when you need cross-host fact sharing for template generation, dynamic configuration, multi-tier deployments, or cloud service discovery. Skip it when you are just running commands on other hosts without needing their facts.
