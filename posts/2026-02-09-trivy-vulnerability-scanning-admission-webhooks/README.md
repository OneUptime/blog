# How to Integrate Trivy Vulnerability Scanning into Kubernetes Admission Webhooks

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: Kubernetes, Security, Trivy

Description: Learn how to build a custom Kubernetes admission webhook that integrates Trivy vulnerability scanning to block container images with critical vulnerabilities from being deployed.

---

Preventing vulnerable container images from running in production is essential for maintaining cluster security. While scanning images in CI/CD pipelines is important, runtime admission control provides an additional security layer that catches vulnerabilities that might have been missed or introduced after the initial scan.

In this guide, we'll build a Kubernetes admission webhook that integrates Trivy to scan container images at deployment time and reject pods containing images with critical vulnerabilities.

## Understanding Admission Webhooks

Kubernetes admission webhooks are HTTP callbacks that intercept requests to the API server before objects are persisted. They come in two types:

- **Validating webhooks**: Accept or reject requests based on validation logic
- **Mutating webhooks**: Modify objects before they're stored

For vulnerability scanning, we'll use a validating webhook that scans images and rejects deployments if critical vulnerabilities are found.

## Prerequisites

Before starting, ensure you have:

- A Kubernetes cluster (version 1.16 or later)
- kubectl with cluster admin access
- Go 1.21 or later installed
- Docker or Podman for building images
- Trivy CLI installed locally for testing
- A container registry for hosting the webhook image

## Setting Up the Webhook Server

First, let's create a Go-based webhook server that integrates with Trivy. Create a new project:

```bash
mkdir trivy-admission-webhook
cd trivy-admission-webhook
go mod init github.com/yourorg/trivy-admission-webhook
```

Install the required dependencies:

```bash
go get k8s.io/api/admission/v1
go get k8s.io/apimachinery/pkg/runtime
go get k8s.io/apimachinery/pkg/runtime/serializer
go get github.com/aquasecurity/trivy/pkg/commands
```

Create the main webhook handler in `main.go`:

```go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "os/exec"

    admissionv1 "k8s.io/api/admission/v1"
    corev1 "k8s.io/api/core/v1"
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
    "k8s.io/apimachinery/pkg/runtime"
    "k8s.io/apimachinery/pkg/runtime/serializer"
)

var (
    scheme = runtime.NewScheme()
    codecs = serializer.NewCodecFactory(scheme)
)

type WebhookServer struct {
    severityThreshold string
}

// ScanResult represents Trivy scan results
type ScanResult struct {
    Vulnerabilities []Vulnerability `json:"Results"`
}

type Vulnerability struct {
    Target          string          `json:"Target"`
    Vulnerabilities []VulnDetail    `json:"Vulnerabilities"`
}

type VulnDetail struct {
    VulnerabilityID string `json:"VulnerabilityID"`
    Severity        string `json:"Severity"`
    Title           string `json:"Title"`
}

func (ws *WebhookServer) handleAdmission(w http.ResponseWriter, r *http.Request) {
    body, err := io.ReadAll(r.Body)
    if err != nil {
        http.Error(w, "Failed to read request body", http.StatusBadRequest)
        return
    }

    // Parse admission review request
    admissionReview := admissionv1.AdmissionReview{}
    if _, _, err := codecs.UniversalDeserializer().Decode(body, nil, &admissionReview); err != nil {
        http.Error(w, fmt.Sprintf("Failed to decode request: %v", err), http.StatusBadRequest)
        return
    }

    // Extract pod from request
    pod := corev1.Pod{}
    if err := json.Unmarshal(admissionReview.Request.Object.Raw, &pod); err != nil {
        http.Error(w, fmt.Sprintf("Failed to unmarshal pod: %v", err), http.StatusBadRequest)
        return
    }

    // Scan all containers in the pod
    allowed := true
    var messages []string

    for _, container := range pod.Spec.Containers {
        hasVulns, msg := ws.scanImage(container.Image)
        if hasVulns {
            allowed = false
            messages = append(messages, msg)
        }
    }

    // Create admission response
    response := admissionv1.AdmissionReview{
        TypeMeta: metav1.TypeMeta{
            APIVersion: "admission.k8s.io/v1",
            Kind:       "AdmissionReview",
        },
        Response: &admissionv1.AdmissionResponse{
            UID:     admissionReview.Request.UID,
            Allowed: allowed,
        },
    }

    if !allowed {
        response.Response.Result = &metav1.Status{
            Message: fmt.Sprintf("Image vulnerabilities detected: %v", messages),
        }
    }

    // Send response
    respBytes, err := json.Marshal(response)
    if err != nil {
        http.Error(w, fmt.Sprintf("Failed to marshal response: %v", err), http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    w.Write(respBytes)
}

func (ws *WebhookServer) scanImage(image string) (bool, string) {
    // Run Trivy scan
    cmd := exec.Command("trivy", "image",
        "--format", "json",
        "--severity", ws.severityThreshold,
        "--exit-code", "0",
        "--no-progress",
        image,
    )

    output, err := cmd.Output()
    if err != nil {
        return true, fmt.Sprintf("Failed to scan image %s: %v", image, err)
    }

    // Parse scan results
    var results ScanResult
    if err := json.Unmarshal(output, &results); err != nil {
        return true, fmt.Sprintf("Failed to parse scan results for %s: %v", image, err)
    }

    // Check for vulnerabilities
    vulnCount := 0
    for _, result := range results.Vulnerabilities {
        vulnCount += len(result.Vulnerabilities)
    }

    if vulnCount > 0 {
        return true, fmt.Sprintf("Image %s contains %d %s+ vulnerabilities",
            image, vulnCount, ws.severityThreshold)
    }

    return false, ""
}

func main() {
    ws := &WebhookServer{
        severityThreshold: "CRITICAL",
    }

    http.HandleFunc("/validate", ws.handleAdmission)
    http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
    })

    fmt.Println("Starting webhook server on :8443")
    if err := http.ListenAndServeTLS(":8443", "/etc/webhook/certs/tls.crt",
        "/etc/webhook/certs/tls.key", nil); err != nil {
        panic(err)
    }
}
```

## Creating the Dockerfile

Build a container image that includes both the webhook server and Trivy:

```dockerfile
FROM golang:1.21 as builder

WORKDIR /workspace
COPY go.mod go.sum ./
RUN go mod download

COPY main.go .
RUN CGO_ENABLED=0 GOOS=linux go build -o webhook main.go

FROM aquasec/trivy:latest

# Copy webhook binary from builder
COPY --from=builder /workspace/webhook /usr/local/bin/webhook

# Ensure Trivy DB is updated
RUN trivy image --download-db-only

ENTRYPOINT ["/usr/local/bin/webhook"]
```

Build and push the image:

```bash
docker build -t myregistry.azurecr.io/trivy-webhook:v1.0.0 .
docker push myregistry.azurecr.io/trivy-webhook:v1.0.0
```

## Generating TLS Certificates

Admission webhooks require TLS. Generate self-signed certificates:

```bash
# Generate private key
openssl genrsa -out webhook.key 2048

# Generate certificate signing request
openssl req -new -key webhook.key -out webhook.csr \
  -subj "/CN=trivy-webhook.trivy-system.svc"

# Generate self-signed certificate
openssl x509 -req -in webhook.csr -signkey webhook.key \
  -out webhook.crt -days 365

# Create Kubernetes secret
kubectl create namespace trivy-system
kubectl create secret tls webhook-certs \
  --cert=webhook.crt \
  --key=webhook.key \
  -n trivy-system
```

## Deploying the Webhook

Create a deployment for the webhook server:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: trivy-webhook
  namespace: trivy-system
spec:
  replicas: 2
  selector:
    matchLabels:
      app: trivy-webhook
  template:
    metadata:
      labels:
        app: trivy-webhook
    spec:
      containers:
      - name: webhook
        image: myregistry.azurecr.io/trivy-webhook:v1.0.0
        ports:
        - containerPort: 8443
        volumeMounts:
        - name: certs
          mountPath: /etc/webhook/certs
          readOnly: true
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "500m"
      volumes:
      - name: certs
        secret:
          secretName: webhook-certs
---
apiVersion: v1
kind: Service
metadata:
  name: trivy-webhook
  namespace: trivy-system
spec:
  ports:
  - port: 443
    targetPort: 8443
  selector:
    app: trivy-webhook
```

## Configuring the ValidatingWebhookConfiguration

Create the webhook configuration to intercept pod creation:

```yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: trivy-webhook
webhooks:
- name: trivy-webhook.trivy-system.svc
  clientConfig:
    service:
      name: trivy-webhook
      namespace: trivy-system
      path: /validate
    caBundle: <base64-encoded-ca-cert>
  rules:
  - operations: ["CREATE", "UPDATE"]
    apiGroups: [""]
    apiVersions: ["v1"]
    resources: ["pods"]
  admissionReviewVersions: ["v1"]
  sideEffects: None
  timeoutSeconds: 30
  failurePolicy: Ignore  # Change to Fail for strict enforcement
  namespaceSelector:
    matchExpressions:
    - key: trivy-webhook
      operator: In
      values: ["enabled"]
```

Get the base64-encoded CA certificate:

```bash
cat webhook.crt | base64 | tr -d '\n'
```

Replace `<base64-encoded-ca-cert>` with the output.

## Testing the Webhook

Enable the webhook for a test namespace:

```bash
kubectl create namespace test-app
kubectl label namespace test-app trivy-webhook=enabled
```

Try deploying a pod with a vulnerable image:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: vulnerable-app
  namespace: test-app
spec:
  containers:
  - name: app
    image: nginx:1.14.0  # Known to have vulnerabilities
```

The webhook should reject this deployment if critical vulnerabilities are found.

## Monitoring and Optimization

Add Prometheus metrics to track scan performance:

```go
import "github.com/prometheus/client_golang/prometheus"

var (
    scansTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "trivy_scans_total",
            Help: "Total number of image scans performed",
        },
        []string{"result"},
    )
)
```

Configure caching to avoid repeated scans of the same image:

```go
type ScanCache struct {
    cache map[string]CacheEntry
    ttl   time.Duration
}

type CacheEntry struct {
    hasVulns  bool
    message   string
    timestamp time.Time
}
```

## Conclusion

Integrating Trivy into a Kubernetes admission webhook provides runtime protection against vulnerable container images. This approach complements CI/CD scanning by catching images that might have been deployed without proper validation or that have newly discovered vulnerabilities.

Start with a lenient `failurePolicy: Ignore` to avoid blocking legitimate deployments, monitor the webhook logs to understand scan patterns, and gradually move to strict enforcement as your teams adapt their workflows to address vulnerabilities before deployment.
