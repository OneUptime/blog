# How to Configure Crossplane Connection Secrets Management

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: Crossplane, Kubernetes, Secrets, Security, Infrastructure-as-Code

Description: Learn how to configure Crossplane connection secrets management to securely handle credentials generated by managed resources like databases, storage buckets, and cloud services.

---

Cloud resources generate credentials that applications need to consume. An RDS database creates connection strings with passwords. An S3 bucket generates access keys. A Redis instance returns auth tokens. Managing these dynamically generated secrets is a critical part of infrastructure automation.

Crossplane handles this through connection secrets. When you provision managed resources, Crossplane automatically stores the connection details in Kubernetes secrets. Your applications reference those secrets without knowing anything about the underlying cloud provider. This guide shows you how to configure connection secret management effectively.

## Understanding Connection Secrets

Connection secrets store information that applications need to connect to managed resources. When Crossplane provisions an RDS instance, it retrieves the connection endpoint, username, password, and port. These values get written to a Kubernetes secret automatically.

The key benefit is decoupling. Applications consume standard Kubernetes secrets. The infrastructure layer handles credential generation and rotation. You can swap out a self-hosted database for a cloud-managed one without changing application configuration.

## Basic Connection Secret Configuration

Start with a simple managed resource that generates connection secrets.

```yaml
# rds-instance.yaml
apiVersion: rds.aws.upbound.io/v1beta1
kind: Instance
metadata:
  name: postgres-db
spec:
  forProvider:
    region: us-west-2
    engine: postgres
    engineVersion: "15.4"
    instanceClass: db.t3.medium
    allocatedStorage: 100
    username: dbadmin
    passwordSecretRef:
      namespace: crossplane-system
      name: db-password
      key: password
  writeConnectionSecretToRef:
    namespace: production
    name: postgres-connection
```

Create the password secret that the database will use.

```bash
kubectl create secret generic db-password \
  -n crossplane-system \
  --from-literal=password=$(openssl rand -base64 32)
```

Apply the managed resource.

```bash
kubectl apply -f rds-instance.yaml
```

Crossplane provisions the RDS instance and writes connection details to the specified secret.

```bash
kubectl get secret postgres-connection -n production -o yaml
```

You'll see keys like endpoint, port, username, and password populated automatically.

## Customizing Connection Secret Keys

Control which keys appear in the connection secret.

```yaml
# rds-custom-keys.yaml
apiVersion: rds.aws.upbound.io/v1beta1
kind: Instance
metadata:
  name: postgres-db
spec:
  forProvider:
    region: us-west-2
    engine: postgres
    engineVersion: "15.4"
    instanceClass: db.t3.medium
    allocatedStorage: 100
    username: dbadmin
    passwordSecretRef:
      namespace: crossplane-system
      name: db-password
      key: password
  writeConnectionSecretToRef:
    namespace: production
    name: postgres-connection
  # Specify exactly which connection details to expose
  writeConnectionDetailsToConfigRef:
    name: postgres-connection-config
```

Define the connection details configuration.

```yaml
# connection-config.yaml
apiVersion: apiextensions.crossplane.io/v1alpha1
kind: ConnectionDetailsConfig
metadata:
  name: postgres-connection-config
spec:
  writeConnectionDetailsToRef:
    namespace: production
    name: postgres-connection
  connectionDetails:
    - name: host
      fromConnectionSecretKey: endpoint
    - name: port
      fromConnectionSecretKey: port
    - name: database
      value: "defaultdb"
    - name: username
      fromConnectionSecretKey: username
    - name: password
      fromConnectionSecretKey: password
```

This maps provider-specific keys to standardized names your applications expect.

## Using Connection Secrets in Compositions

Propagate connection secrets from managed resources to composite resources.

```yaml
# composition-database.yaml
apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: postgres-composition
spec:
  compositeTypeRef:
    apiVersion: database.example.com/v1alpha1
    kind: PostgreSQLInstance
  resources:
    - name: rds-instance
      base:
        apiVersion: rds.aws.upbound.io/v1beta1
        kind: Instance
        spec:
          forProvider:
            region: us-west-2
            engine: postgres
            engineVersion: "15.4"
            instanceClass: db.t3.medium
            allocatedStorage: 100
            username: dbadmin
            passwordSecretRef:
              namespace: crossplane-system
              name: db-password
              key: password
      # Propagate connection secret from managed resource
      connectionDetails:
        - name: endpoint
          fromConnectionSecretKey: endpoint
        - name: port
          fromConnectionSecretKey: port
        - name: username
          fromConnectionSecretKey: username
        - name: password
          fromConnectionSecretKey: password

    - name: security-group
      base:
        apiVersion: ec2.aws.upbound.io/v1beta1
        kind: SecurityGroup
        spec:
          forProvider:
            region: us-west-2
            description: PostgreSQL security group
      # Security groups don't produce connection secrets
```

When you create a claim, specify where the composite's connection secret should go.

```yaml
# database-claim.yaml
apiVersion: database.example.com/v1alpha1
kind: PostgreSQLInstance
metadata:
  name: app-database
  namespace: production
spec:
  parameters:
    storageSize: 100
  writeConnectionSecretToRef:
    name: app-db-connection
```

The connection details flow from the RDS instance through the composition to the claim's secret.

## Merging Connection Secrets from Multiple Resources

Some compositions create multiple resources that each produce connection details. Merge them into a single secret.

```yaml
# composition-app-stack.yaml
apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: app-stack
spec:
  compositeTypeRef:
    apiVersion: platform.example.com/v1alpha1
    kind: ApplicationStack
  resources:
    # Database resource
    - name: database
      base:
        apiVersion: rds.aws.upbound.io/v1beta1
        kind: Instance
        spec:
          forProvider:
            region: us-west-2
            engine: postgres
            engineVersion: "15.4"
            instanceClass: db.t3.medium
            allocatedStorage: 50
            username: appuser
            passwordSecretRef:
              namespace: crossplane-system
              name: db-password
              key: password
      connectionDetails:
        - name: db_host
          fromConnectionSecretKey: endpoint
        - name: db_port
          fromConnectionSecretKey: port
        - name: db_username
          fromConnectionSecretKey: username
        - name: db_password
          fromConnectionSecretKey: password

    # Redis cache
    - name: redis
      base:
        apiVersion: cache.aws.upbound.io/v1beta1
        kind: Cluster
        spec:
          forProvider:
            region: us-west-2
            cacheNodeType: cache.t3.micro
            engine: redis
            numCacheNodes: 1
      connectionDetails:
        - name: redis_host
          fromConnectionSecretKey: cacheNodes[0].address
        - name: redis_port
          fromConnectionSecretKey: cacheNodes[0].port

    # S3 bucket
    - name: storage
      base:
        apiVersion: s3.aws.upbound.io/v1beta1
        kind: Bucket
        spec:
          forProvider:
            region: us-west-2
      connectionDetails:
        - name: bucket_name
          fromFieldPath: metadata.name
        - name: bucket_region
          value: us-west-2
```

The claim's connection secret contains all merged keys.

```yaml
# app-stack-claim.yaml
apiVersion: platform.example.com/v1alpha1
kind: ApplicationStack
metadata:
  name: myapp
  namespace: production
spec:
  parameters:
    environment: production
  writeConnectionSecretToRef:
    name: myapp-credentials
```

The resulting secret has db_host, db_port, redis_host, redis_port, bucket_name, and bucket_region.

## Transforming Connection Secret Values

Apply transforms to connection details before writing them to secrets.

```yaml
# composition-transforms.yaml
apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: postgres-with-transforms
spec:
  compositeTypeRef:
    apiVersion: database.example.com/v1alpha1
    kind: PostgreSQLInstance
  resources:
    - name: rds-instance
      base:
        apiVersion: rds.aws.upbound.io/v1beta1
        kind: Instance
        spec:
          forProvider:
            region: us-west-2
            engine: postgres
            engineVersion: "15.4"
            instanceClass: db.t3.medium
            allocatedStorage: 100
            username: postgres
            passwordSecretRef:
              namespace: crossplane-system
              name: db-password
              key: password
      connectionDetails:
        # Build a complete connection string
        - name: connection_url
          type: FromConnectionSecretKey
          fromConnectionSecretKey: endpoint
          transform:
            type: string
            string:
              type: Format
              fmt: "postgresql://%s:%s@%s:%s/postgres"

        # Convert port to string
        - name: port_string
          fromConnectionSecretKey: port
          transform:
            type: string
            string:
              type: Convert
              convert: ToString

        # Add static values
        - name: ssl_mode
          value: "require"

        # Map environment to connection pool sizes
        - name: max_connections
          fromFieldPath: spec.parameters.environment
          transform:
            type: map
            map:
              development: "10"
              staging: "25"
              production: "100"
```

These transforms let you create application-ready configuration from raw infrastructure details.

## Connection Secret Scoping and RBAC

Control which namespaces can read connection secrets.

```yaml
# rbac-connection-secrets.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: app-service-account
  namespace: production
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: secret-reader
  namespace: production
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    # Only allow reading specific connection secrets
    resourceNames:
      - "app-db-connection"
      - "app-cache-connection"
    verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: app-secret-access
  namespace: production
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: secret-reader
subjects:
  - kind: ServiceAccount
    name: app-service-account
    namespace: production
```

Applications use this service account to access only their required secrets.

```yaml
# deployment-with-secrets.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
  namespace: production
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      serviceAccountName: app-service-account
      containers:
        - name: app
          image: myapp:v1.0.0
          env:
            # Load connection details from secret
            - name: DB_HOST
              valueFrom:
                secretKeyRef:
                  name: app-db-connection
                  key: endpoint
            - name: DB_PORT
              valueFrom:
                secretKeyRef:
                  name: app-db-connection
                  key: port
            - name: DB_USERNAME
              valueFrom:
                secretKeyRef:
                  name: app-db-connection
                  key: username
            - name: DB_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: app-db-connection
                  key: password
```

## Rotating Connection Secrets

Handle credential rotation without downtime.

```yaml
# rds-with-rotation.yaml
apiVersion: rds.aws.upbound.io/v1beta1
kind: Instance
metadata:
  name: postgres-db
spec:
  forProvider:
    region: us-west-2
    engine: postgres
    engineVersion: "15.4"
    instanceClass: db.t3.medium
    allocatedStorage: 100
    username: dbadmin
    # Reference a secret for the master password
    passwordSecretRef:
      namespace: crossplane-system
      name: db-master-password
      key: password
    # Enable automatic minor version upgrades
    autoMinorVersionUpgrade: true
  writeConnectionSecretToRef:
    namespace: production
    name: postgres-connection
```

When you update the password secret, Crossplane propagates the change.

```bash
# Generate new password
NEW_PASSWORD=$(openssl rand -base64 32)

# Update the secret
kubectl create secret generic db-master-password \
  -n crossplane-system \
  --from-literal=password="$NEW_PASSWORD" \
  --dry-run=client -o yaml | kubectl apply -f -
```

The managed resource detects the change and updates the RDS password. The connection secret automatically reflects the new password.

## External Secret Stores Integration

Integrate with external secret management systems.

```yaml
# external-secrets-integration.yaml
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: aws-secrets-manager
  namespace: production
spec:
  provider:
    aws:
      service: SecretsManager
      region: us-west-2
      auth:
        jwt:
          serviceAccountRef:
            name: external-secrets-sa
---
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: postgres-connection-external
  namespace: production
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: aws-secrets-manager
    kind: SecretStore
  target:
    name: postgres-connection-external
    creationPolicy: Owner
  dataFrom:
    - extract:
        key: prod/database/postgres
```

Reference the Crossplane-generated secret in your SecretStore to sync it.

```yaml
# sync-crossplane-to-external.yaml
apiVersion: v1
kind: Secret
metadata:
  name: postgres-connection-sync
  namespace: production
  annotations:
    # Annotation to trigger external secret sync
    external-secrets.io/sync: "true"
stringData:
  endpoint: ""
  port: ""
  username: ""
  password: ""
```

This pattern works with Vault, AWS Secrets Manager, Azure Key Vault, or any external secret store.

## Monitoring Connection Secret Health

Track connection secret status and lifecycle.

```yaml
# monitoring-connection-secrets.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-crossplane-rules
  namespace: monitoring
data:
  crossplane.rules: |
    groups:
      - name: crossplane
        interval: 30s
        rules:
          # Alert when connection secret is missing
          - alert: CrossplaneConnectionSecretMissing
            expr: |
              kube_secret_info{namespace="production"} == 0
            for: 5m
            labels:
              severity: critical
            annotations:
              summary: "Crossplane connection secret missing"
              description: "Connection secret {{ $labels.secret }} is missing in namespace {{ $labels.namespace }}"

          # Alert when managed resource is not ready but secret exists
          - alert: CrossplaneManagedResourceNotReady
            expr: |
              crossplane_managed_resource_ready{condition="False"} == 1
            for: 10m
            labels:
              severity: warning
            annotations:
              summary: "Managed resource not ready"
              description: "Resource {{ $labels.name }} has been not ready for 10 minutes"
```

## Cleanup and Secret Lifecycle

Configure what happens to secrets when managed resources are deleted.

```yaml
# managed-resource-with-deletion-policy.yaml
apiVersion: rds.aws.upbound.io/v1beta1
kind: Instance
metadata:
  name: postgres-db
  # Control secret cleanup behavior
  annotations:
    # Keep the connection secret after resource deletion
    crossplane.io/connection-secret-deletion-policy: Orphan
spec:
  deletionPolicy: Delete
  forProvider:
    region: us-west-2
    engine: postgres
    engineVersion: "15.4"
    instanceClass: db.t3.medium
    allocatedStorage: 100
    username: dbadmin
    passwordSecretRef:
      namespace: crossplane-system
      name: db-password
      key: password
  writeConnectionSecretToRef:
    namespace: production
    name: postgres-connection
```

Use Orphan to preserve secrets for disaster recovery. Use Delete to clean up automatically.

## Debugging Connection Secret Issues

Troubleshoot common problems.

```bash
# Check if connection secret was created
kubectl get secret postgres-connection -n production

# View the actual secret contents
kubectl get secret postgres-connection -n production -o jsonpath='{.data}' | jq

# Check managed resource status
kubectl describe instance.rds.aws.upbound.io postgres-db

# View Crossplane provider logs
kubectl logs -n crossplane-system -l pkg.crossplane.io/provider=provider-aws

# Check connection secret references in claim
kubectl get postgresqlinstance app-database -n production -o yaml | grep -A 5 writeConnectionSecretToRef
```

## Summary

Crossplane connection secrets automate credential management for cloud resources. Managed resources write connection details to Kubernetes secrets automatically. Compositions merge secrets from multiple resources. Transforms let you shape data for application consumption.

Use writeConnectionSecretToRef to specify where secrets land. Reference secrets in your deployments as environment variables or volume mounts. Apply RBAC to control secret access. Integrate with external secret stores for centralized credential management.

Connection secrets decouple application configuration from infrastructure provisioning. Applications consume standard Kubernetes secrets regardless of the underlying cloud provider. This abstraction makes infrastructure portable and credentials manageable at scale.
