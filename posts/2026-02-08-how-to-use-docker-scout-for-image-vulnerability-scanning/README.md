# How to Use Docker Scout for Image Vulnerability Scanning

Author: [nawazdhandala](https://github.com/nawazdhandala)

Tags: Docker, Docker Scout, Security, Vulnerability Scanning, Container Security, DevOps

Description: Scan Docker images for vulnerabilities using Docker Scout and learn how to interpret results to secure your containers.

---

Every Docker image you pull from a registry carries potential security vulnerabilities. Base images contain operating system packages with known CVEs. Application dependencies ship with security flaws. Even your own code introduces risks through the libraries it imports. Docker Scout analyzes your images against multiple vulnerability databases and tells you exactly what risks exist and how to fix them.

Unlike external scanning tools that require separate setup, Docker Scout integrates directly into Docker Desktop and the Docker CLI. You can scan images during development, before pushing to a registry, and as part of your CI/CD pipeline.

## What Docker Scout Scans

Docker Scout creates a Software Bill of Materials (SBOM) for each image. This SBOM catalogs every package, library, and dependency in the image. Scout then cross-references this inventory against vulnerability databases including:

- National Vulnerability Database (NVD)
- GitHub Advisory Database
- Debian Security Tracker
- Alpine SecDB
- Red Hat Security Data
- Various language-specific advisory databases (npm, PyPI, RubyGems)

The result is a comprehensive list of known vulnerabilities (CVEs) with severity ratings and, when available, fix recommendations.

## Enabling Docker Scout

Docker Scout is available in Docker Desktop 4.17+ and as a CLI plugin.

```bash
# Check if Docker Scout is available
docker scout version

# If not installed, install the CLI plugin
curl -fsSL https://raw.githubusercontent.com/docker/scout-cli/main/install.sh | sh

# Login to Docker Hub (required for full Scout features)
docker login
```

In Docker Desktop, Scout is enabled by default. You can see vulnerability information in the Images section of the Dashboard.

## Scanning Your First Image

Run a vulnerability scan against any local or remote image.

```bash
# Scan a local image
docker scout cves myapp:latest

# Scan a remote image from Docker Hub
docker scout cves nginx:latest

# Scan a remote image from another registry
docker scout cves ghcr.io/myorg/myapp:v1.2.3
```

The output shows vulnerabilities grouped by severity: critical, high, medium, and low.

```bash
# Example output (simplified):
#   Target: nginx:latest
#   Vulnerabilities:
#     Critical: 2
#     High: 5
#     Medium: 12
#     Low: 23
#
#   CVE-2024-XXXXX  Critical  libssl3 (3.0.11-1)  Fixed in 3.0.13-1
#   CVE-2024-YYYYY  High      curl (7.88.1-10)    Fixed in 7.88.1-11
```

## Filtering Scan Results

Focus on what matters by filtering results.

```bash
# Show only critical and high severity vulnerabilities
docker scout cves myapp:latest --only-severity critical,high

# Filter by package name
docker scout cves myapp:latest --only-package openssl

# Filter by CVE ID
docker scout cves myapp:latest --only-cve-id CVE-2024-1234

# Show only vulnerabilities that have a fix available
docker scout cves myapp:latest --only-fixed

# Show only vulnerabilities without a fix
docker scout cves myapp:latest --only-unfixed
```

## Understanding the SBOM

Before diving into vulnerabilities, understand what is in your image.

```bash
# Generate the Software Bill of Materials
docker scout sbom myapp:latest

# Output SBOM in SPDX format for compliance
docker scout sbom --format spdx myapp:latest

# Output as JSON for programmatic processing
docker scout sbom --format json myapp:latest > sbom.json

# List all packages found in the image
docker scout sbom --format list myapp:latest
```

The SBOM is the foundation of vulnerability scanning. It tells you every component in your image, which is valuable for license compliance and supply chain security beyond just CVE scanning.

## Comparing Images

Scout can compare two images to show how vulnerabilities changed between versions. This is invaluable for validating that an update actually reduced risk.

```bash
# Compare vulnerabilities between two image versions
docker scout compare myapp:v2.0 --to myapp:v1.0

# Compare your image against a recommended base image
docker scout compare myapp:latest --to node:20-slim
```

The comparison output shows:
- New vulnerabilities introduced
- Vulnerabilities fixed
- Unchanged vulnerabilities
- Changes in the SBOM (added/removed packages)

## Scanning During Docker Build

Scan images as part of the build process so vulnerabilities are caught before the image leaves your machine.

```bash
# Build and scan in one step
docker build -t myapp:latest . && docker scout cves myapp:latest

# Use the --sbom flag during build to generate SBOM at build time
docker build --sbom=true -t myapp:latest .
```

Add Scout scanning to a Makefile for convenience.

```makefile
# Makefile - Build and scan targets
.PHONY: build scan

build:
	docker build -t myapp:latest .

scan: build
	docker scout cves myapp:latest --only-severity critical,high --exit-code

# Exit code makes the scan fail if critical/high vulnerabilities are found
build-safe: scan
	@echo "Image passed vulnerability scan"
```

```bash
# Build and scan together
make build-safe
```

## Using Exit Codes for Automation

Docker Scout supports exit codes that make it easy to gate deployments on scan results.

```bash
# Fail (exit code 2) if critical vulnerabilities are found
docker scout cves myapp:latest --exit-code --only-severity critical

# Fail if any critical or high vulnerabilities are found
docker scout cves myapp:latest --exit-code --only-severity critical,high

# Use in a script
if docker scout cves myapp:latest --exit-code --only-severity critical; then
    echo "No critical vulnerabilities found. Safe to deploy."
    docker push registry.example.com/myapp:latest
else
    echo "Critical vulnerabilities detected. Blocking deployment."
    exit 1
fi
```

## Output Formats

Get scan results in different formats for different use cases.

```bash
# Default human-readable table output
docker scout cves myapp:latest

# JSON output for programmatic processing
docker scout cves myapp:latest --format json > scan-results.json

# SARIF format for integration with GitHub Code Scanning
docker scout cves myapp:latest --format sarif > scan-results.sarif

# Markdown output for PR comments
docker scout cves myapp:latest --format markdown > scan-report.md
```

Process JSON output to extract specific information.

```bash
# Count vulnerabilities by severity using jq
docker scout cves myapp:latest --format json | \
  jq '.vulnerabilities | group_by(.severity) | map({severity: .[0].severity, count: length})'

# Extract just the critical CVE IDs
docker scout cves myapp:latest --format json | \
  jq '.vulnerabilities[] | select(.severity == "critical") | .cveId'
```

## Scanning Multi-Platform Images

If your images support multiple architectures, scan each platform.

```bash
# Scan the linux/amd64 variant
docker scout cves myapp:latest --platform linux/amd64

# Scan the linux/arm64 variant
docker scout cves myapp:latest --platform linux/arm64

# Different platforms may have different vulnerabilities because
# OS packages differ between architectures
```

## Real-World Scanning Workflow

Here is a practical workflow for incorporating vulnerability scanning into your development process.

```bash
#!/bin/bash
# scan-and-report.sh - Comprehensive image scanning workflow

set -euo pipefail

IMAGE=$1
REPORT_DIR="./security-reports"
mkdir -p "$REPORT_DIR"

echo "=== Scanning $IMAGE ==="

# Step 1: Generate SBOM
echo "Generating SBOM..."
docker scout sbom --format json "$IMAGE" > "$REPORT_DIR/sbom.json"

# Step 2: Full vulnerability scan
echo "Running vulnerability scan..."
docker scout cves "$IMAGE" --format json > "$REPORT_DIR/cves.json"

# Step 3: Count vulnerabilities by severity
echo "=== Vulnerability Summary ==="
for severity in critical high medium low; do
    count=$(cat "$REPORT_DIR/cves.json" | jq "[.vulnerabilities[] | select(.severity == \"$severity\")] | length")
    echo "  $severity: $count"
done

# Step 4: Check for critical vulnerabilities
CRITICAL=$(cat "$REPORT_DIR/cves.json" | jq '[.vulnerabilities[] | select(.severity == "critical")] | length')
if [ "$CRITICAL" -gt 0 ]; then
    echo ""
    echo "WARNING: $CRITICAL critical vulnerabilities found!"
    echo "Critical CVEs:"
    cat "$REPORT_DIR/cves.json" | jq -r '.vulnerabilities[] | select(.severity == "critical") | "  \(.cveId) - \(.packageName) \(.installedVersion)"'
    exit 1
fi

echo ""
echo "No critical vulnerabilities. Image is approved for deployment."
```

```bash
# Run the scanning workflow
chmod +x scan-and-report.sh
./scan-and-report.sh myapp:latest
```

## Reducing Vulnerabilities Before Scanning

The best scan result is one with zero vulnerabilities. Reduce your attack surface before scanning.

```bash
# Use minimal base images
# Bad: Full Ubuntu image with hundreds of packages
FROM ubuntu:22.04

# Good: Alpine has far fewer packages and vulnerabilities
FROM alpine:3.19

# Better: Distroless images contain only your application
FROM gcr.io/distroless/static-debian12

# Best for compiled languages: scratch image (empty)
FROM scratch
```

Keep base images updated. Many vulnerabilities exist in old versions of base images that have long been patched.

```bash
# Check if a newer base image version exists
docker scout recommendations myapp:latest

# Rebuild with the latest base image
docker build --pull --no-cache -t myapp:latest .
```

Docker Scout transforms vulnerability scanning from an afterthought into a natural part of the development workflow. Scan early, scan often, and use exit codes to prevent vulnerable images from reaching production.
