# How to Enable Vulnerability Scanning on Container Images in Artifact Registry

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: GCP, Artifact Registry, Vulnerability Scanning, Container Security, DevOps, Security

Description: Enable and configure automatic vulnerability scanning for container images in Google Artifact Registry to detect security issues before deployment.

---

Pushing Docker images without scanning them for vulnerabilities is like deploying code without running tests - you are just hoping nothing bad slips through. Google Artifact Registry integrates with Container Analysis to automatically scan every image you push for known CVEs in OS packages and application dependencies.

Let me show you how to enable scanning, interpret the results, and set up guardrails to block vulnerable images from being deployed.

## Enabling Vulnerability Scanning

Vulnerability scanning is provided by the Container Analysis API. Enable it along with the on-demand scanning API:

```bash
# Enable the required APIs
gcloud services enable \
  containeranalysis.googleapis.com \
  containerscanning.googleapis.com \
  --project=my-project
```

Once these APIs are enabled, scanning happens automatically. Every Docker image pushed to Artifact Registry is scanned within minutes of being pushed.

## How Scanning Works

When you push an image, Artifact Registry triggers an automatic scan. The scanner:

1. Analyzes the image layers to identify installed OS packages (Debian, Alpine, CentOS, etc.)
2. Checks application dependencies (npm, pip, Maven, Go modules)
3. Compares package versions against known vulnerability databases (NVD, vendor advisories)
4. Generates a vulnerability report attached to the image

The scanning continues after the initial push too. As new CVEs are discovered, Artifact Registry rescans existing images and updates their vulnerability reports.

## Checking Scan Results

### Using the gcloud CLI

```bash
# View vulnerability scan results for a specific image
gcloud artifacts docker images describe \
  us-central1-docker.pkg.dev/my-project/my-repo/my-app:v1.0.0 \
  --show-package-vulnerability \
  --project=my-project
```

This shows a summary of vulnerabilities by severity level.

For more detail:

```bash
# List all vulnerabilities for an image
gcloud artifacts docker images list \
  us-central1-docker.pkg.dev/my-project/my-repo/my-app \
  --show-occurrences \
  --occurrence-filter='kind="VULNERABILITY"' \
  --project=my-project
```

### Using the Console

Navigate to Artifact Registry in the Cloud Console, click on your repository, then click on an image. The vulnerability tab shows a detailed breakdown of all findings with severity levels, CVE IDs, and fix versions.

## Understanding Severity Levels

Vulnerabilities are classified into severity levels:

| Severity | Description | Action |
|---|---|---|
| CRITICAL | Actively exploited or easily exploitable | Fix immediately |
| HIGH | Significant risk, may allow remote code execution | Fix in the current sprint |
| MEDIUM | Moderate risk, typically requires some user interaction | Plan a fix |
| LOW | Minor risk | Fix when convenient |
| MINIMAL | Informational | No action needed |

## On-Demand Scanning

If you want to scan images before pushing them to a repository (shift-left approach), use on-demand scanning:

```bash
# Scan a local image before pushing
gcloud artifacts docker images scan \
  us-central1-docker.pkg.dev/my-project/my-repo/my-app:v1.0.0 \
  --location=us-central1 \
  --project=my-project
```

You can also scan images from other registries:

```bash
# Scan an image during a Cloud Build step
gcloud artifacts docker images scan \
  us-central1-docker.pkg.dev/my-project/my-repo/my-app:$SHORT_SHA \
  --format='value(response.scan)' \
  --location=us-central1 > /tmp/scan_id.txt

# Get the scan results
gcloud artifacts docker images list-vulnerabilities \
  $(cat /tmp/scan_id.txt) \
  --format='table(vulnerability.shortDescription, vulnerability.effectiveSeverity, vulnerability.packageIssue[0].affectedPackage, vulnerability.packageIssue[0].fixedVersion.fullName)'
```

## Integrating Scanning into Cloud Build

Add vulnerability checking to your CI/CD pipeline to block images with critical vulnerabilities:

```yaml
# cloudbuild.yaml - Build, scan, and conditionally deploy
steps:
  # Build the Docker image
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'us-central1-docker.pkg.dev/$PROJECT_ID/my-repo/my-app:$SHORT_SHA', '.']

  # Push to Artifact Registry (this triggers automatic scanning)
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'us-central1-docker.pkg.dev/$PROJECT_ID/my-repo/my-app:$SHORT_SHA']

  # Wait for scan to complete and check for critical vulnerabilities
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Wait a bit for the scan to complete
        echo "Waiting for vulnerability scan..."
        sleep 30

        # Scan the image
        SCAN_OUTPUT=$(gcloud artifacts docker images scan \
          us-central1-docker.pkg.dev/$PROJECT_ID/my-repo/my-app:$SHORT_SHA \
          --location=us-central1 \
          --format='value(response.scan)')

        # Check for critical vulnerabilities
        CRITICAL_COUNT=$(gcloud artifacts docker images list-vulnerabilities \
          $SCAN_OUTPUT \
          --format='value(vulnerability.effectiveSeverity)' | \
          grep -c 'CRITICAL' || true)

        if [ "$CRITICAL_COUNT" -gt 0 ]; then
          echo "CRITICAL vulnerabilities found! Blocking deployment."
          gcloud artifacts docker images list-vulnerabilities \
            $SCAN_OUTPUT \
            --format='table(vulnerability.shortDescription, vulnerability.effectiveSeverity, vulnerability.packageIssue[0].affectedPackage)'
          exit 1
        fi

        echo "No critical vulnerabilities found. Proceeding with deployment."

  # Deploy only if scan passes
  - name: 'gcr.io/cloud-builders/kubectl'
    args: ['set', 'image', 'deployment/my-app', 'my-app=us-central1-docker.pkg.dev/$PROJECT_ID/my-repo/my-app:$SHORT_SHA']
    env:
      - 'CLOUDSDK_COMPUTE_ZONE=us-central1-a'
      - 'CLOUDSDK_CONTAINER_CLUSTER=my-cluster'
```

## Using Binary Authorization

For stronger enforcement, combine vulnerability scanning with Binary Authorization. This creates a policy that prevents GKE from pulling images that have not passed a vulnerability check:

```bash
# Enable Binary Authorization API
gcloud services enable binaryauthorization.googleapis.com --project=my-project

# Create an attestor for vulnerability scanning
gcloud container binauthz attestors create vulnerability-attestor \
  --attestation-authority-note=vulnerability-note \
  --attestation-authority-note-project=my-project
```

Configure the Binary Authorization policy to require attestation:

```yaml
# binauthz-policy.yaml - Require vulnerability attestation
defaultAdmissionRule:
  enforcementMode: ENFORCED_BLOCK_AND_AUDIT_LOG
  evaluationMode: REQUIRE_ATTESTATION
  requireAttestationsBy:
    - projects/my-project/attestors/vulnerability-attestor
```

## Setting Up Alerts for New Vulnerabilities

When new CVEs are discovered, existing images get rescanned. Set up alerts to know about new findings:

```bash
# Create a notification channel (Slack example)
gcloud alpha monitoring channels create \
  --type=slack \
  --display-name="Security Alerts" \
  --channel-labels=channel_name="#security-alerts"

# Create an alert policy for new critical vulnerabilities
gcloud alpha monitoring policies create \
  --display-name="Critical Vulnerability Found" \
  --condition-display-name="Critical CVE in container image" \
  --condition-filter='resource.type="global" AND metric.type="custom.googleapis.com/vulnerability/critical_count"' \
  --notification-channels=CHANNEL_ID
```

## Practical Scanning Strategy

Here is what I recommend for most teams:

1. **Enable automatic scanning** on all Docker repositories. The cost is minimal and the benefit is significant.

2. **Block critical vulnerabilities in CI/CD**. Never deploy an image with known critical CVEs.

3. **Alert on high vulnerabilities** but do not block deployments for them. Review them regularly.

4. **Use on-demand scanning** during development so developers find issues before pushing.

5. **Set up weekly reports** of vulnerability findings across all your images.

6. **Keep base images updated**. Most vulnerabilities come from outdated base images. Use the latest patched versions.

```bash
# Check which base images have the most vulnerabilities
gcloud artifacts docker images list \
  us-central1-docker.pkg.dev/my-project/my-repo \
  --show-occurrences \
  --occurrence-filter='kind="VULNERABILITY" AND vulnerability.effectiveSeverity="CRITICAL"' \
  --format='table(package, createTime, vulnerability.shortDescription)' \
  --project=my-project
```

## Wrapping Up

Enabling vulnerability scanning in Artifact Registry is a quick win for your security posture. Turn on the APIs, and scanning happens automatically. The real value comes from integrating scan results into your CI/CD pipeline to block vulnerable images and setting up alerts so your team can respond to newly discovered CVEs affecting your running containers.
