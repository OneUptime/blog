# How to Connect Rust Applications to PostgreSQL with Diesel

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: Rust, PostgreSQL, Diesel, ORM, Database

Description: Learn how to connect your Rust applications to PostgreSQL using Diesel ORM. This guide covers setup, schema management, CRUD operations, and best practices for building type-safe database-driven applications.

---

Rust's memory safety guarantees and performance make it an excellent choice for building backend services. When those services need to persist data, PostgreSQL is often the database of choice. Diesel is a powerful ORM and query builder that brings compile-time safety to your database interactions, catching SQL errors before your code even runs.

In this guide, we'll build a complete example showing how to connect a Rust application to PostgreSQL using Diesel. You'll learn how to set up the project, define your schema, run migrations, and perform CRUD operations with type-safe queries.

## Why Diesel?

Before diving into the code, let's understand why Diesel stands out among Rust database libraries:

1. **Compile-time query verification** - Diesel checks your queries against your schema at compile time. If you reference a column that doesn't exist or use the wrong type, your code won't compile.

2. **Type-safe schema representation** - Your database schema is represented as Rust types, making it impossible to write queries that don't match your data model.

3. **Zero-cost abstractions** - Diesel generates the same SQL you would write by hand. The abstraction layer doesn't add runtime overhead.

4. **Powerful query builder** - Complex queries with joins, aggregations, and subqueries are all possible with a fluent API.

Here's how Diesel fits into a typical Rust application architecture:

```mermaid
flowchart TB
    subgraph "Rust Application"
        A[Application Code] --> B[Diesel ORM]
        B --> C[Connection Pool]
    end

    subgraph "Database Layer"
        C --> D[(PostgreSQL)]
    end

    subgraph "Development Tools"
        E[diesel_cli] --> F[Migrations]
        F --> D
        E --> G[schema.rs]
        G --> B
    end
```

## Setting Up the Project

Let's start by creating a new Rust project and adding the required dependencies.

```bash
# Create a new Rust project
cargo new rust_diesel_demo
cd rust_diesel_demo
```

Add these dependencies to your `Cargo.toml`:

```toml
[dependencies]
# Diesel with PostgreSQL support
diesel = { version = "2.1", features = ["postgres", "r2d2", "chrono"] }

# Environment variable management
dotenvy = "0.15"

# Connection pooling
r2d2 = "0.8"

# Date/time handling
chrono = { version = "0.4", features = ["serde"] }

# Serialization (useful for API responses)
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
```

Now install the Diesel CLI tool. This command-line utility helps you manage database migrations and generate schema code:

```bash
# Install diesel_cli with PostgreSQL support only
cargo install diesel_cli --no-default-features --features postgres
```

## Configuring the Database Connection

Create a `.env` file in your project root with your PostgreSQL connection string:

```bash
DATABASE_URL=postgres://username:password@localhost/rust_diesel_demo
```

Initialize Diesel in your project:

```bash
# This creates the diesel.toml file and migrations directory
diesel setup
```

This command creates:
- A `diesel.toml` configuration file
- A `migrations` directory for your database migrations
- The database if it doesn't exist

## Creating Your First Migration

Migrations are how Diesel manages your database schema over time. Each migration has an "up" script (to apply changes) and a "down" script (to revert them).

Let's create a migration for a users table:

```bash
diesel migration generate create_users
```

This creates a new directory in `migrations/` with two SQL files. Edit the `up.sql` file:

```sql
-- migrations/YYYY-MM-DD-HHMMSS_create_users/up.sql

CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) NOT NULL UNIQUE,
    username VARCHAR(100) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- Create an index for faster email lookups
CREATE INDEX idx_users_email ON users(email);
```

And the `down.sql` file:

```sql
-- migrations/YYYY-MM-DD-HHMMSS_create_users/down.sql

DROP TABLE users;
```

Run the migration:

```bash
diesel migration run
```

Diesel automatically generates a `src/schema.rs` file that represents your database schema in Rust:

```rust
// src/schema.rs (auto-generated by Diesel)

diesel::table! {
    users (id) {
        id -> Int4,
        email -> Varchar,
        username -> Varchar,
        created_at -> Timestamp,
        updated_at -> Timestamp,
    }
}
```

## Defining Models

Now let's create Rust structs that map to our database tables. Create a `src/models.rs` file:

```rust
// src/models.rs

use chrono::NaiveDateTime;
use diesel::prelude::*;
use serde::{Deserialize, Serialize};

use crate::schema::users;

// Queryable: Used when reading data from the database
// Selectable: Enables type-safe select queries
// Serialize: Allows converting to JSON
#[derive(Queryable, Selectable, Serialize, Debug)]
#[diesel(table_name = users)]
#[diesel(check_for_backend(diesel::pg::Pg))]
pub struct User {
    pub id: i32,
    pub email: String,
    pub username: String,
    pub created_at: NaiveDateTime,
    pub updated_at: NaiveDateTime,
}

// Insertable: Used when creating new records
// Deserialize: Allows parsing from JSON input
#[derive(Insertable, Deserialize, Debug)]
#[diesel(table_name = users)]
pub struct NewUser {
    pub email: String,
    pub username: String,
}

// AsChangeset: Used for update operations
// Only includes fields that can be modified
#[derive(AsChangeset, Deserialize, Debug)]
#[diesel(table_name = users)]
pub struct UpdateUser {
    pub email: Option<String>,
    pub username: Option<String>,
    pub updated_at: Option<NaiveDateTime>,
}
```

## Setting Up the Connection Pool

Production applications need connection pooling to handle multiple concurrent requests efficiently. Create a `src/db.rs` file:

```rust
// src/db.rs

use diesel::pg::PgConnection;
use diesel::r2d2::{self, ConnectionManager, Pool, PooledConnection};
use dotenvy::dotenv;
use std::env;

// Type aliases for cleaner code
pub type DbPool = Pool<ConnectionManager<PgConnection>>;
pub type DbConnection = PooledConnection<ConnectionManager<PgConnection>>;

// Custom error type for database operations
#[derive(Debug)]
pub enum DbError {
    ConnectionError(String),
    PoolError(r2d2::Error),
}

impl std::fmt::Display for DbError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DbError::ConnectionError(msg) => write!(f, "Connection error: {}", msg),
            DbError::PoolError(e) => write!(f, "Pool error: {}", e),
        }
    }
}

impl std::error::Error for DbError {}

// Creates a new connection pool
pub fn establish_connection_pool() -> Result<DbPool, DbError> {
    // Load environment variables from .env file
    dotenv().ok();

    let database_url = env::var("DATABASE_URL")
        .map_err(|_| DbError::ConnectionError(
            "DATABASE_URL must be set in .env file".to_string()
        ))?;

    let manager = ConnectionManager::<PgConnection>::new(database_url);

    // Configure pool settings
    Pool::builder()
        .max_size(10)           // Maximum connections in the pool
        .min_idle(Some(2))      // Keep at least 2 idle connections
        .test_on_check_out(true) // Verify connections before use
        .build(manager)
        .map_err(DbError::PoolError)
}

// Helper to get a connection from the pool
pub fn get_connection(pool: &DbPool) -> Result<DbConnection, DbError> {
    pool.get().map_err(DbError::PoolError)
}
```

## Implementing CRUD Operations

Now let's implement the core database operations. Create a `src/operations.rs` file:

```rust
// src/operations.rs

use chrono::Utc;
use diesel::prelude::*;

use crate::db::DbConnection;
use crate::models::{NewUser, UpdateUser, User};
use crate::schema::users;

// Result type alias for database operations
pub type DbResult<T> = Result<T, diesel::result::Error>;

// CREATE: Insert a new user
pub fn create_user(conn: &mut DbConnection, new_user: NewUser) -> DbResult<User> {
    diesel::insert_into(users::table)
        .values(&new_user)
        .returning(User::as_returning())
        .get_result(conn)
}

// READ: Get a user by ID
pub fn get_user_by_id(conn: &mut DbConnection, user_id: i32) -> DbResult<User> {
    users::table
        .find(user_id)
        .select(User::as_select())
        .first(conn)
}

// READ: Get a user by email
pub fn get_user_by_email(conn: &mut DbConnection, user_email: &str) -> DbResult<User> {
    users::table
        .filter(users::email.eq(user_email))
        .select(User::as_select())
        .first(conn)
}

// READ: List all users with pagination
pub fn list_users(
    conn: &mut DbConnection,
    page: i64,
    per_page: i64
) -> DbResult<Vec<User>> {
    let offset = (page - 1) * per_page;

    users::table
        .select(User::as_select())
        .order(users::created_at.desc())
        .limit(per_page)
        .offset(offset)
        .load(conn)
}

// UPDATE: Update a user by ID
pub fn update_user(
    conn: &mut DbConnection,
    user_id: i32,
    mut changes: UpdateUser
) -> DbResult<User> {
    // Set the updated_at timestamp
    changes.updated_at = Some(Utc::now().naive_utc());

    diesel::update(users::table.find(user_id))
        .set(&changes)
        .returning(User::as_returning())
        .get_result(conn)
}

// DELETE: Remove a user by ID
pub fn delete_user(conn: &mut DbConnection, user_id: i32) -> DbResult<usize> {
    diesel::delete(users::table.find(user_id))
        .execute(conn)
}

// COUNT: Get total number of users (useful for pagination)
pub fn count_users(conn: &mut DbConnection) -> DbResult<i64> {
    users::table
        .count()
        .get_result(conn)
}
```

## Advanced Query Patterns

Diesel supports complex queries. Here are some common patterns you'll encounter:

```rust
// src/advanced_queries.rs

use diesel::prelude::*;
use diesel::dsl::now;

use crate::db::DbConnection;
use crate::models::User;
use crate::schema::users;

pub type DbResult<T> = Result<T, diesel::result::Error>;

// Search users with ILIKE (case-insensitive pattern matching)
pub fn search_users(
    conn: &mut DbConnection,
    search_term: &str
) -> DbResult<Vec<User>> {
    let pattern = format!("%{}%", search_term);

    users::table
        .filter(
            users::username.ilike(&pattern)
                .or(users::email.ilike(&pattern))
        )
        .select(User::as_select())
        .load(conn)
}

// Get users created within a date range
pub fn users_created_between(
    conn: &mut DbConnection,
    start: chrono::NaiveDateTime,
    end: chrono::NaiveDateTime,
) -> DbResult<Vec<User>> {
    users::table
        .filter(users::created_at.between(start, end))
        .select(User::as_select())
        .order(users::created_at.asc())
        .load(conn)
}

// Batch insert multiple users
pub fn create_users_batch(
    conn: &mut DbConnection,
    new_users: Vec<crate::models::NewUser>,
) -> DbResult<Vec<User>> {
    diesel::insert_into(users::table)
        .values(&new_users)
        .returning(User::as_returning())
        .get_results(conn)
}

// Check if an email already exists
pub fn email_exists(conn: &mut DbConnection, email: &str) -> DbResult<bool> {
    use diesel::dsl::exists;
    use diesel::select;

    select(exists(
        users::table.filter(users::email.eq(email))
    ))
    .get_result(conn)
}

// Conditional updates - only update if a condition is met
pub fn update_username_if_not_taken(
    conn: &mut DbConnection,
    user_id: i32,
    new_username: &str,
) -> DbResult<Option<User>> {
    // First check if the username is available
    let username_taken: bool = diesel::select(diesel::dsl::exists(
        users::table
            .filter(users::username.eq(new_username))
            .filter(users::id.ne(user_id))
    ))
    .get_result(conn)?;

    if username_taken {
        return Ok(None);
    }

    // Update if available
    diesel::update(users::table.find(user_id))
        .set((
            users::username.eq(new_username),
            users::updated_at.eq(now),
        ))
        .returning(User::as_returning())
        .get_result(conn)
        .map(Some)
}
```

## Handling Transactions

Diesel provides transaction support for operations that need to be atomic:

```rust
// src/transactions.rs

use diesel::prelude::*;
use diesel::Connection;

use crate::db::DbConnection;
use crate::models::{NewUser, User};
use crate::operations::{create_user, update_user, UpdateUser};

pub type DbResult<T> = Result<T, diesel::result::Error>;

// Create a user and immediately update their username - atomically
pub fn create_and_update_user(
    conn: &mut DbConnection,
    new_user: NewUser,
    final_username: String,
) -> DbResult<User> {
    conn.transaction(|conn| {
        // Create the user
        let user = create_user(conn, new_user)?;

        // Update the username
        let changes = UpdateUser {
            username: Some(final_username),
            email: None,
            updated_at: None,
        };

        update_user(conn, user.id, changes)
    })
}

// Transfer operation example - demonstrates rollback on failure
pub fn transfer_data_between_users(
    conn: &mut DbConnection,
    from_user_id: i32,
    to_user_id: i32,
    new_email: String,
) -> DbResult<(User, User)> {
    conn.transaction(|conn| {
        // Get both users first
        let from_user = crate::operations::get_user_by_id(conn, from_user_id)?;
        let _to_user = crate::operations::get_user_by_id(conn, to_user_id)?;

        // Update the target user with the email from source
        let updated_to = update_user(conn, to_user_id, UpdateUser {
            email: Some(from_user.email),
            username: None,
            updated_at: None,
        })?;

        // Update the source user with the new email
        let updated_from = update_user(conn, from_user_id, UpdateUser {
            email: Some(new_email),
            username: None,
            updated_at: None,
        })?;

        // If any of these operations fail, the entire transaction rolls back
        Ok((updated_from, updated_to))
    })
}
```

## Putting It All Together

Here's a complete `main.rs` that demonstrates all the operations:

```rust
// src/main.rs

mod db;
mod models;
mod operations;
mod schema;

use db::{establish_connection_pool, get_connection};
use models::NewUser;
use operations::{
    count_users, create_user, delete_user, get_user_by_id,
    list_users, update_user,
};

fn main() {
    println!("Rust + Diesel + PostgreSQL Demo\n");

    // Establish connection pool
    let pool = establish_connection_pool()
        .expect("Failed to create connection pool");

    // Get a connection from the pool
    let conn = &mut get_connection(&pool)
        .expect("Failed to get connection from pool");

    // CREATE: Add a new user
    println!("Creating a new user...");
    let new_user = NewUser {
        email: "alice@example.com".to_string(),
        username: "alice".to_string(),
    };

    match create_user(conn, new_user) {
        Ok(user) => println!("Created user: {:?}\n", user),
        Err(e) => println!("Error creating user: {}\n", e),
    }

    // READ: Get user by ID
    println!("Fetching user with ID 1...");
    match get_user_by_id(conn, 1) {
        Ok(user) => println!("Found user: {:?}\n", user),
        Err(e) => println!("User not found: {}\n", e),
    }

    // UPDATE: Modify a user
    println!("Updating user...");
    let changes = models::UpdateUser {
        username: Some("alice_updated".to_string()),
        email: None,
        updated_at: None,
    };

    match update_user(conn, 1, changes) {
        Ok(user) => println!("Updated user: {:?}\n", user),
        Err(e) => println!("Error updating user: {}\n", e),
    }

    // LIST: Get paginated users
    println!("Listing users (page 1, 10 per page)...");
    match list_users(conn, 1, 10) {
        Ok(users) => {
            println!("Found {} users:", users.len());
            for user in users {
                println!("  - {} ({})", user.username, user.email);
            }
            println!();
        }
        Err(e) => println!("Error listing users: {}\n", e),
    }

    // COUNT: Get total users
    match count_users(conn) {
        Ok(count) => println!("Total users in database: {}\n", count),
        Err(e) => println!("Error counting users: {}\n", e),
    }

    // DELETE: Remove a user
    println!("Deleting user with ID 1...");
    match delete_user(conn, 1) {
        Ok(count) => println!("Deleted {} user(s)\n", count),
        Err(e) => println!("Error deleting user: {}\n", e),
    }

    println!("Demo complete!");
}
```

## Best Practices

When working with Diesel in production, keep these guidelines in mind:

**1. Use connection pooling** - Never create a new connection for each request. The r2d2 pool we configured handles this efficiently.

**2. Keep migrations small and reversible** - Each migration should do one thing. Always write a working `down.sql` so you can roll back if needed.

**3. Use transactions for related operations** - If multiple database changes need to succeed or fail together, wrap them in a transaction.

**4. Handle errors gracefully** - Diesel returns `Result` types. Pattern match on errors to provide meaningful feedback to users.

**5. Index your queries** - If you're filtering or sorting on a column frequently, add an index in your migration.

**6. Run migrations in CI** - Test your migrations against a real PostgreSQL instance in your CI pipeline before deploying.

## Conclusion

Diesel brings the compile-time safety that Rust developers love to database interactions. By catching type mismatches and schema errors at compile time, Diesel eliminates an entire class of runtime bugs that plague applications using raw SQL or less strict ORMs.

The setup requires more upfront investment than dynamically typed alternatives, but the payoff is substantial: queries that are guaranteed to work, code that's easier to refactor, and fewer surprises in production.

For complex applications where database correctness matters, Diesel is the right choice. Combined with PostgreSQL's reliability and Rust's performance, you have a solid foundation for building services that scale.

If you're looking to monitor your Rust applications in production, OneUptime provides observability tools that integrate with your existing infrastructure. Track database query performance, set up alerts for slow queries, and gain visibility into your application's health.
