# How to Use Ansible Playbook Callbacks for Custom Output

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: Ansible, Callbacks, Plugins, DevOps, Monitoring

Description: Learn how to use Ansible callback plugins to customize playbook output, send notifications, log to external systems, and create custom reporting.

---

When you run an Ansible playbook, the output you see in your terminal is generated by a callback plugin. By default, Ansible uses the `default` callback, which shows task names, host results, and a play recap. But there is nothing stopping you from replacing or extending that output. Callback plugins let you hook into every stage of playbook execution: when a play starts, when a task succeeds or fails, when a host is unreachable, and when everything wraps up. You can use this to send Slack notifications, log results to a database, generate HTML reports, or simply format the output in a way that makes more sense for your team.

## Built-in Callback Plugins

Ansible ships with several callback plugins you can switch to immediately:

```bash
# List all available callback plugins
ansible-doc -t callback -l
```

Some useful built-in callbacks:

```ini
# ansible.cfg
# Change the stdout callback to get different terminal output

[defaults]
# Shows only task changes and failures (much quieter)
stdout_callback = actionable

# JSON output (great for piping to other tools)
# stdout_callback = json

# Shows task timing information
# stdout_callback = timer

# Shows profile information per task
# stdout_callback = profile_tasks

# YAML-formatted output (easier to read than default)
# stdout_callback = yaml
```

To enable non-stdout callbacks (notifications, logging), use the `callbacks_enabled` setting:

```ini
# ansible.cfg
[defaults]
# Enable additional callback plugins alongside the stdout callback
callbacks_enabled = timer, profile_tasks, profile_roles
```

## The profile_tasks Callback

This is one of the most practical built-in callbacks. It shows how long each task took, which is invaluable for optimizing slow playbooks:

```ini
# ansible.cfg
[defaults]
callbacks_enabled = profile_tasks
```

Output looks like:

```
Wednesday 21 February 2026  10:30:00 +0000 (0:00:00.000)   0:02:15.000 ******
===============================================================================
Install packages ------------------------------------------ 45.23s
Deploy application config --------------------------------- 12.01s
Run database migrations ----------------------------------- 38.45s
Restart application service ------------------------------- 3.12s
Health check ---------------------------------------------- 15.88s
```

## Writing a Custom Callback Plugin

Let me walk through building a callback plugin that sends deployment results to a Slack webhook.

First, create the plugin directory structure:

```bash
# Create the callback plugins directory in your project
mkdir -p callback_plugins
```

Now create the plugin:

```python
# callback_plugins/slack_notify.py
# Ansible callback plugin that sends deployment results to Slack

from __future__ import absolute_import, division, print_function
__metaclass__ = type

DOCUMENTATION = '''
    name: slack_notify
    type: notification
    short_description: Sends playbook results to Slack
    description:
        - Sends a summary notification to a Slack webhook when a playbook completes.
    requirements:
        - requests Python library
    options:
        webhook_url:
            description: Slack incoming webhook URL
            env:
                - name: SLACK_WEBHOOK_URL
            ini:
                - section: callback_slack_notify
                  key: webhook_url
'''

import json
import os
from datetime import datetime

from ansible.plugins.callback import CallbackBase

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False


class CallbackModule(CallbackBase):
    """Sends playbook completion notifications to Slack."""

    CALLBACK_VERSION = 2.0
    CALLBACK_TYPE = 'notification'
    CALLBACK_NAME = 'slack_notify'
    CALLBACK_NEEDS_WHITELIST = True

    def __init__(self):
        super(CallbackModule, self).__init__()
        self.start_time = None
        self.task_results = {
            'ok': 0,
            'changed': 0,
            'failures': 0,
            'unreachable': 0,
            'skipped': 0,
        }
        self.failed_tasks = []
        self.playbook_name = ''

        if not HAS_REQUESTS:
            self._display.warning(
                'The requests Python library is required for slack_notify callback.'
            )
            self.disabled = True

    def set_options(self, task_keys=None, var_options=None, direct=None):
        super(CallbackModule, self).set_options(
            task_keys=task_keys, var_options=var_options, direct=direct
        )
        self.webhook_url = os.environ.get('SLACK_WEBHOOK_URL', '')
        if not self.webhook_url:
            self._display.warning('SLACK_WEBHOOK_URL not set, disabling slack_notify.')
            self.disabled = True

    def v2_playbook_on_start(self, playbook):
        self.start_time = datetime.now()
        self.playbook_name = os.path.basename(playbook._file_name)

    def v2_runner_on_ok(self, result, **kwargs):
        if result._result.get('changed', False):
            self.task_results['changed'] += 1
        else:
            self.task_results['ok'] += 1

    def v2_runner_on_failed(self, result, **kwargs):
        self.task_results['failures'] += 1
        self.failed_tasks.append({
            'host': result._host.get_name(),
            'task': result._task.get_name(),
            'msg': result._result.get('msg', 'No error message'),
        })

    def v2_runner_on_unreachable(self, result, **kwargs):
        self.task_results['unreachable'] += 1

    def v2_runner_on_skipped(self, result, **kwargs):
        self.task_results['skipped'] += 1

    def v2_playbook_on_stats(self, stats):
        """Called at the end of the playbook run. Send the Slack notification."""
        duration = datetime.now() - self.start_time
        minutes = int(duration.total_seconds() // 60)
        seconds = int(duration.total_seconds() % 60)

        # Determine if the playbook was successful
        has_failures = self.task_results['failures'] > 0 or self.task_results['unreachable'] > 0
        status_emoji = ':x:' if has_failures else ':white_check_mark:'
        color = '#ff0000' if has_failures else '#36a64f'

        # Build failure details section
        failure_text = ''
        if self.failed_tasks:
            failure_lines = []
            for f in self.failed_tasks:
                failure_lines.append(
                    "- Host: {host}, Task: {task}\n  Error: {msg}".format(**f)
                )
            failure_text = '\n'.join(failure_lines)

        # Construct the Slack message payload
        payload = {
            'attachments': [{
                'color': color,
                'title': '{emoji} Playbook: {name}'.format(
                    emoji=status_emoji, name=self.playbook_name
                ),
                'fields': [
                    {'title': 'Duration', 'value': '{m}m {s}s'.format(m=minutes, s=seconds), 'short': True},
                    {'title': 'OK', 'value': str(self.task_results['ok']), 'short': True},
                    {'title': 'Changed', 'value': str(self.task_results['changed']), 'short': True},
                    {'title': 'Failures', 'value': str(self.task_results['failures']), 'short': True},
                    {'title': 'Unreachable', 'value': str(self.task_results['unreachable']), 'short': True},
                    {'title': 'Skipped', 'value': str(self.task_results['skipped']), 'short': True},
                ],
                'footer': 'Ansible Deployment',
                'ts': int(datetime.now().timestamp()),
            }]
        }

        if failure_text:
            payload['attachments'][0]['fields'].append({
                'title': 'Failed Tasks',
                'value': '```{text}```'.format(text=failure_text),
                'short': False,
            })

        # Send to Slack
        try:
            requests.post(self.webhook_url, json=payload, timeout=10)
        except Exception as e:
            self._display.warning('Failed to send Slack notification: {}'.format(str(e)))
```

## Configuring the Custom Callback

Enable it in your `ansible.cfg`:

```ini
# ansible.cfg
[defaults]
# Tell Ansible where to find custom callback plugins
callback_plugins = ./callback_plugins

# Enable the custom notification callback
callbacks_enabled = slack_notify

[callback_slack_notify]
webhook_url = https://hooks.slack.com/services/T00000/B00000/XXXX
```

Or set the webhook URL via environment variable:

```bash
# Set the Slack webhook URL and run the playbook
export SLACK_WEBHOOK_URL="https://hooks.slack.com/services/T00000/B00000/XXXX"
ansible-playbook deploy.yml
```

## A Simpler Callback: Log to File

Here is a more basic callback that logs task results to a JSON file:

```python
# callback_plugins/json_log.py
# Logs all task results to a JSON file for later analysis

from __future__ import absolute_import, division, print_function
__metaclass__ = type

import json
import os
from datetime import datetime
from ansible.plugins.callback import CallbackBase

LOGFILE = '/var/log/ansible/playbook-runs.jsonl'


class CallbackModule(CallbackBase):
    """Logs each task result as a JSON line to a file."""

    CALLBACK_VERSION = 2.0
    CALLBACK_TYPE = 'notification'
    CALLBACK_NAME = 'json_log'
    CALLBACK_NEEDS_WHITELIST = True

    def __init__(self):
        super(CallbackModule, self).__init__()
        # Ensure the log directory exists
        log_dir = os.path.dirname(LOGFILE)
        if not os.path.exists(log_dir):
            os.makedirs(log_dir, exist_ok=True)

    def _log_entry(self, event_type, host, task_name, result):
        entry = {
            'timestamp': datetime.utcnow().isoformat(),
            'event': event_type,
            'host': host,
            'task': task_name,
            'changed': result.get('changed', False),
        }
        if event_type == 'failed':
            entry['msg'] = result.get('msg', '')

        with open(LOGFILE, 'a') as f:
            f.write(json.dumps(entry) + '\n')

    def v2_runner_on_ok(self, result, **kwargs):
        self._log_entry('ok', result._host.get_name(),
                        result._task.get_name(), result._result)

    def v2_runner_on_failed(self, result, **kwargs):
        self._log_entry('failed', result._host.get_name(),
                        result._task.get_name(), result._result)

    def v2_runner_on_unreachable(self, result, **kwargs):
        self._log_entry('unreachable', result._host.get_name(),
                        result._task.get_name(), result._result)
```

## Wrapping Up

Callback plugins give you full control over what happens at every stage of playbook execution. Start with the built-in options like `profile_tasks` and `yaml` for better terminal output. When you need integration with external systems, writing a custom notification callback is straightforward. The key callback methods to implement are `v2_playbook_on_start`, `v2_runner_on_ok`, `v2_runner_on_failed`, and `v2_playbook_on_stats`. With these hooks, you can feed playbook results into any monitoring, alerting, or reporting system your team uses.
