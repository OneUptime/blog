# How to Use ansible-galaxy collection init to Start a Collection

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: Ansible, Ansible Galaxy, Collections, Development

Description: How to scaffold a new Ansible collection using ansible-galaxy collection init with proper structure, metadata, and development workflow.

---

Starting a new Ansible collection from scratch means creating dozens of directories and files in a specific layout. The `ansible-galaxy collection init` command generates this skeleton for you in seconds, giving you a properly structured starting point that Galaxy and ansible-test understand. This post covers how to use the command, what it generates, and how to build on top of it.

## The Basic Command

The syntax is straightforward. You provide the namespace and collection name in `namespace.collection` format:

```bash
# Initialize a new collection
ansible-galaxy collection init myorg.infrastructure
```

This creates the following directory tree:

```
myorg/infrastructure/
    docs/
    meta/
        runtime.yml
    plugins/
        README.md
    roles/
    galaxy.yml
    README.md
```

The namespace (`myorg`) becomes the parent directory, and the collection name (`infrastructure`) is the subdirectory. This two-level structure matches how collections are stored when installed.

## Specifying an Output Directory

By default, the collection is created in the current working directory. Use `--init-path` to put it somewhere specific:

```bash
# Create the collection in a specific directory
ansible-galaxy collection init myorg.infrastructure --init-path ~/projects/ansible-collections/
```

This creates `~/projects/ansible-collections/myorg/infrastructure/`.

## What Each File Does

Let us go through every generated file and directory.

### galaxy.yml

This is the collection manifest, similar to `package.json` in Node.js:

```yaml
# galaxy.yml - generated by collection init, customize this
---
namespace: myorg
name: infrastructure
version: 1.0.0
readme: README.md
authors:
  - your name <example@domain.com>
description: your collection description
license:
  - GPL-2.0-or-later
tags: []
dependencies: {}
repository: http://example.com/repository
documentation: http://docs.example.com
homepage: http://example.com
issues: http://example.com/issue/tracker
build_ignore: []
```

You should immediately update this with real values:

```yaml
# galaxy.yml - customized for our infrastructure collection
---
namespace: myorg
name: infrastructure
version: 0.1.0
readme: README.md
authors:
  - DevOps Team <devops@myorg.com>
description: Modules and roles for managing myorg infrastructure
license:
  - MIT
tags:
  - infrastructure
  - linux
  - networking
  - monitoring
dependencies:
  ansible.utils: ">=2.0.0"
repository: https://github.com/myorg/ansible-collection-infrastructure
documentation: https://github.com/myorg/ansible-collection-infrastructure/wiki
homepage: https://myorg.com
issues: https://github.com/myorg/ansible-collection-infrastructure/issues
build_ignore:
  - .gitignore
  - .github
  - tests/output
  - "*.tar.gz"
```

### meta/runtime.yml

This file configures module routing, deprecation, and the minimum Ansible version:

```yaml
# meta/runtime.yml - configure runtime behavior
---
requires_ansible: ">=2.14.0"
plugin_routing:
  modules: {}
```

As your collection grows, you will use this file to manage module renames and deprecations:

```yaml
# meta/runtime.yml - with routing examples
---
requires_ansible: ">=2.14.0"
plugin_routing:
  modules:
    # When a module gets renamed, add a redirect
    old_module_name:
      redirect: myorg.infrastructure.new_module_name
    # When a module is deprecated
    legacy_module:
      deprecation:
        removal_version: "2.0.0"
        warning_text: Use myorg.infrastructure.modern_module instead
```

### plugins/ Directory

This is where all your plugins go. The init command creates it with just a README, but you will add subdirectories for each plugin type:

```bash
# Create plugin subdirectories manually
mkdir -p myorg/infrastructure/plugins/{modules,module_utils,inventory,lookup,filter,callback,connection}
```

### roles/ Directory

Collections can contain multiple roles. Each role follows the standard role structure:

```bash
# Create a role within the collection
mkdir -p myorg/infrastructure/roles/webserver/{tasks,defaults,handlers,templates,files,vars,meta}
```

### docs/ Directory

Place documentation here. Galaxy renders RST files from this directory.

## Building Out the Collection

After initialization, here is how I typically build out the structure for a real project.

### Adding a Custom Module

Create a Python module file in `plugins/modules/`:

```python
#!/usr/bin/python
# plugins/modules/server_config.py - Module for managing server configuration

from ansible.module_utils.basic import AnsibleModule

DOCUMENTATION = r"""
---
module: server_config
short_description: Manage server configuration files
description:
  - This module manages configuration files for myorg servers.
  - It supports creating, updating, and validating configuration.
version_added: "0.1.0"
author:
  - DevOps Team (@myorg)
options:
  config_path:
    description: Path to the configuration file.
    required: true
    type: str
  settings:
    description: Dictionary of settings to apply.
    required: true
    type: dict
  validate:
    description: Whether to validate the config before writing.
    required: false
    type: bool
    default: true
"""

EXAMPLES = r"""
- name: Configure the application server
  myorg.infrastructure.server_config:
    config_path: /etc/myapp/server.conf
    settings:
      max_connections: 1000
      log_level: info
      bind_address: "0.0.0.0"
    validate: true
"""

RETURN = r"""
changed:
  description: Whether the configuration was changed.
  type: bool
  returned: always
backup_path:
  description: Path to the backup file if changes were made.
  type: str
  returned: when changed
"""

def main():
    module = AnsibleModule(
        argument_spec=dict(
            config_path=dict(type="str", required=True),
            settings=dict(type="dict", required=True),
            validate=dict(type="bool", default=True),
        ),
        supports_check_mode=True,
    )

    config_path = module.params["config_path"]
    settings = module.params["settings"]

    # Module logic would go here
    # For brevity, this is a simplified example

    result = dict(
        changed=False,
        backup_path="",
    )

    module.exit_json(**result)


if __name__ == "__main__":
    main()
```

### Adding a Role

Create a role within the collection:

```yaml
# roles/webserver/tasks/main.yml - Webserver role tasks
---
- name: Install nginx
  ansible.builtin.package:
    name: nginx
    state: present

- name: Deploy nginx configuration
  ansible.builtin.template:
    src: nginx.conf.j2
    dest: /etc/nginx/nginx.conf
    owner: root
    group: root
    mode: "0644"
  notify: Restart nginx

- name: Ensure nginx is running
  ansible.builtin.service:
    name: nginx
    state: started
    enabled: true
```

```yaml
# roles/webserver/defaults/main.yml - Default variables
---
webserver_port: 80
webserver_worker_processes: auto
webserver_worker_connections: 1024
```

```yaml
# roles/webserver/handlers/main.yml - Handlers
---
- name: Restart nginx
  ansible.builtin.service:
    name: nginx
    state: restarted
```

### Adding Filter Plugins

```python
# plugins/filter/infra_filters.py - Custom filter plugins

class FilterModule:
    """Custom filters for infrastructure management."""

    def filters(self):
        return {
            "to_nginx_upstream": self.to_nginx_upstream,
        }

    def to_nginx_upstream(self, servers, port=80):
        """Convert a list of server IPs to nginx upstream format."""
        lines = []
        for server in servers:
            lines.append(f"server {server}:{port};")
        return "\n    ".join(lines)
```

## Setting Up Tests

Create test infrastructure alongside the collection:

```bash
# Create test directories
mkdir -p myorg/infrastructure/tests/{unit,integration,sanity}
```

Add a basic sanity test ignore file:

```
# tests/sanity/ignore-2.14.txt - Ignore known issues for specific versions
plugins/modules/server_config.py validate-modules:missing-gplv3-license
```

## Setting Up for Development

Initialize a Git repository and configure your development environment:

```bash
# Initialize Git in the collection directory
cd myorg/infrastructure
git init
```

Create a `.gitignore`:

```
# .gitignore - files to exclude from version control
*.tar.gz
*.retry
tests/output/
__pycache__/
*.pyc
.tox/
```

## Building and Testing

Once your collection has content, build and test it:

```bash
# Build the collection tarball
cd myorg/infrastructure
ansible-galaxy collection build

# Run sanity tests
ansible-test sanity --docker

# Install locally for testing
ansible-galaxy collection install myorg-infrastructure-0.1.0.tar.gz -p ./test-install/
```

## The Complete Workflow

Here is the full sequence from init to first usable version:

1. Run `ansible-galaxy collection init myorg.infrastructure`
2. Edit `galaxy.yml` with real metadata
3. Add modules, roles, and plugins
4. Write documentation in `docs/`
5. Set up tests
6. Build with `ansible-galaxy collection build`
7. Test with `ansible-test sanity`
8. Publish with `ansible-galaxy collection publish`

The `collection init` command saves you from memorizing the directory structure and gives you a solid foundation to build on. From there, it is all about adding content and testing it.

## Summary

The `ansible-galaxy collection init` command is the starting point for any new Ansible collection. It generates the required directory structure and metadata files, letting you focus on writing modules, roles, and plugins rather than scaffolding. After initialization, customize `galaxy.yml` with accurate metadata, add your content to the appropriate directories, and set up tests. The generated skeleton follows Galaxy conventions, so when you are ready to publish, everything is in the right place.
