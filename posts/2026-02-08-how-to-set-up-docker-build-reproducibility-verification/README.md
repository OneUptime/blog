# How to Set Up Docker Build Reproducibility Verification

Author: [nawazdhandala](https://github.com/nawazdhandala)

Tags: docker, reproducible builds, verification, supply chain security, BuildKit, content trust, CI/CD

Description: Set up Docker build reproducibility verification to ensure your container images produce identical results across different build environments.

---

Can you rebuild the same Docker image and get an identical result? For most teams, the answer is no. Timestamps, random build IDs, non-pinned dependencies, and cache variations mean that building the same Dockerfile twice produces different images. This is a problem for security audits, compliance, and supply chain trust.

Reproducible Docker builds mean that given the same source code and build instructions, any builder produces a bit-for-bit identical image. This guide shows you how to achieve reproducibility and verify it.

## Why Builds Are Not Reproducible by Default

Several factors introduce non-determinism into Docker builds:

1. **Timestamps** - Layer creation times differ between builds
2. **Package manager updates** - `apt-get install` pulls the latest versions
3. **Build cache** - Cache hits change the effective build steps
4. **Randomness** - Some tools embed random IDs or nonces
5. **Network fetches** - Downloaded files may change over time

Each of these must be addressed to achieve reproducibility.

## Pinning Every Dependency

The most important step is pinning all dependencies to exact versions.

```dockerfile
# Dockerfile with fully pinned dependencies for reproducibility
# Pin the base image by digest, not just tag
FROM python:3.12.2-slim@sha256:abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890

# Pin OS packages to exact versions
RUN apt-get update && apt-get install -y --no-install-recommends \
    libpq-dev=15.4-0+deb12u1 \
    curl=7.88.1-10+deb12u5 \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements with hashed dependencies (generated by pip-compile)
COPY requirements.txt .

# Install Python packages with hash verification
RUN pip install --no-cache-dir --require-hashes -r requirements.txt

COPY . /app
WORKDIR /app

USER nobody
CMD ["python", "app.py"]
```

Generate a requirements file with hashes using pip-compile:

```bash
# Generate requirements.txt with pinned versions and hash verification
pip-compile --generate-hashes requirements.in -o requirements.txt
```

The output pins every package and includes hashes:

```
# requirements.txt (generated by pip-compile with hashes)
flask==3.0.2 \
    --hash=sha256:abcdef1234567890 \
    --hash=sha256:fedcba0987654321
werkzeug==3.0.1 \
    --hash=sha256:1234567890abcdef
```

## Eliminating Timestamps

Docker BuildKit can produce images without embedded timestamps using the `SOURCE_DATE_EPOCH` approach.

```bash
# Build with a fixed timestamp to eliminate time-based variation
# SOURCE_DATE_EPOCH sets all timestamps to a fixed point (Unix epoch 0)
SOURCE_DATE_EPOCH=0 docker buildx build \
  --no-cache \
  --build-arg SOURCE_DATE_EPOCH=0 \
  -t myapp:reproducible \
  .
```

In your Dockerfile, use the build argument to control file timestamps:

```dockerfile
# Accept the epoch argument for timestamp normalization
ARG SOURCE_DATE_EPOCH=0

# After copying files, normalize their timestamps
COPY . /app
RUN find /app -exec touch -d @${SOURCE_DATE_EPOCH} {} +
```

## BuildKit Reproducible Output

Docker BuildKit 0.12+ supports the `--source-date-epoch` flag directly:

```bash
# Use BuildKit's native reproducibility support
docker buildx build \
  --provenance=true \
  --sbom=true \
  --output type=oci,dest=myapp.tar,rewrite-timestamp=true,source-date-epoch=0 \
  .
```

## Verifying Build Reproducibility

The core verification process: build the same image in two different environments and compare the results.

```bash
#!/bin/bash
# verify-reproducibility.sh
# Builds an image twice and compares the results to verify reproducibility

set -euo pipefail

IMAGE_NAME="myapp"
BUILD_CONTEXT="."
DOCKERFILE="Dockerfile"

echo "=== Build Reproducibility Verification ==="

# Build the image the first time
echo "Building image (attempt 1)..."
docker buildx build \
  --no-cache \
  --output type=oci,dest=/tmp/build1.tar \
  -f "$DOCKERFILE" \
  "$BUILD_CONTEXT"

# Build the image the second time
echo "Building image (attempt 2)..."
docker buildx build \
  --no-cache \
  --output type=oci,dest=/tmp/build2.tar \
  -f "$DOCKERFILE" \
  "$BUILD_CONTEXT"

# Calculate SHA-256 hashes of both builds
HASH1=$(sha256sum /tmp/build1.tar | awk '{print $1}')
HASH2=$(sha256sum /tmp/build2.tar | awk '{print $1}')

echo ""
echo "Build 1 hash: $HASH1"
echo "Build 2 hash: $HASH2"

if [ "$HASH1" = "$HASH2" ]; then
    echo "PASS: Builds are reproducible (identical hashes)"
else
    echo "FAIL: Builds differ"

    # Extract and compare manifests to identify what differs
    mkdir -p /tmp/build1 /tmp/build2
    tar xf /tmp/build1.tar -C /tmp/build1
    tar xf /tmp/build2.tar -C /tmp/build2

    echo ""
    echo "Differing files:"
    diff -rq /tmp/build1 /tmp/build2

    rm -rf /tmp/build1 /tmp/build2
fi

rm -f /tmp/build1.tar /tmp/build2.tar
```

## Layer-by-Layer Comparison

When builds differ, identify which layer is the culprit:

```bash
#!/bin/bash
# compare-layers.sh
# Compares two Docker images layer by layer to find reproducibility issues

IMAGE1="$1"
IMAGE2="$2"

if [ -z "$IMAGE1" ] || [ -z "$IMAGE2" ]; then
    echo "Usage: compare-layers.sh <image1> <image2>"
    exit 1
fi

# Save both images as tar archives
docker save "$IMAGE1" > /tmp/img1.tar
docker save "$IMAGE2" > /tmp/img2.tar

# Extract layer information
mkdir -p /tmp/layers1 /tmp/layers2
tar xf /tmp/img1.tar -C /tmp/layers1
tar xf /tmp/img2.tar -C /tmp/layers2

# Compare manifests
echo "=== Manifest Comparison ==="
diff <(jq -S . /tmp/layers1/manifest.json) <(jq -S . /tmp/layers2/manifest.json)

# Compare each layer's hash
echo ""
echo "=== Layer Hash Comparison ==="
LAYERS1=$(jq -r '.[0].Layers[]' /tmp/layers1/manifest.json)
LAYERS2=$(jq -r '.[0].Layers[]' /tmp/layers2/manifest.json)

paste <(echo "$LAYERS1") <(echo "$LAYERS2") | while IFS=$'\t' read L1 L2; do
    H1=$(sha256sum "/tmp/layers1/$L1" | awk '{print $1}')
    H2=$(sha256sum "/tmp/layers2/$L2" | awk '{print $1}')
    if [ "$H1" = "$H2" ]; then
        echo "MATCH: $L1"
    else
        echo "DIFF:  $L1 vs $L2"
    fi
done

# Clean up
rm -rf /tmp/img1.tar /tmp/img2.tar /tmp/layers1 /tmp/layers2
```

## CI/CD Integration for Reproducibility Checks

Add reproducibility verification to your CI/CD pipeline:

```yaml
# .github/workflows/reproducibility.yml
# Verifies that Docker builds are reproducible on every merge to main

name: Build Reproducibility Check

on:
  push:
    branches: [main]

jobs:
  verify:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Run two independent builds and compare their output hashes
      - name: Build attempt 1
        run: |
          docker buildx build \
            --no-cache \
            --output type=oci,dest=/tmp/build1.tar \
            .

      - name: Build attempt 2
        run: |
          docker buildx build \
            --no-cache \
            --output type=oci,dest=/tmp/build2.tar \
            .

      - name: Compare builds
        run: |
          HASH1=$(sha256sum /tmp/build1.tar | awk '{print $1}')
          HASH2=$(sha256sum /tmp/build2.tar | awk '{print $1}')
          echo "Build 1: $HASH1"
          echo "Build 2: $HASH2"
          if [ "$HASH1" != "$HASH2" ]; then
            echo "::error::Builds are not reproducible"
            exit 1
          fi
          echo "Builds are reproducible"
```

## Using Build Provenance and Attestations

Docker BuildKit can generate provenance attestations that record exactly how an image was built:

```bash
# Build with provenance attestation
docker buildx build \
  --provenance=mode=max \
  --push \
  -t registry.example.com/myapp:v1.0 \
  .

# Inspect the provenance attestation
docker buildx imagetools inspect \
  registry.example.com/myapp:v1.0 \
  --format '{{json .Provenance}}' | jq .
```

Verify an image's provenance with cosign:

```bash
# Install cosign for image verification
go install github.com/sigstore/cosign/v2/cmd/cosign@latest

# Verify the provenance attestation against a known builder
cosign verify-attestation \
  --type slsaprovenance \
  --certificate-identity "https://github.com/my-org/my-repo/.github/workflows/build.yml@refs/heads/main" \
  --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \
  registry.example.com/myapp:v1.0
```

## Common Pitfalls and Fixes

| Issue | Cause | Fix |
|-------|-------|-----|
| Different image digests | Timestamps in layers | Use `SOURCE_DATE_EPOCH=0` |
| Package version drift | Unpinned `apt-get install` | Pin every package version |
| Python package changes | Unpinned pip install | Use `--require-hashes` with pip-compile |
| Node module variation | npm install without lockfile | Commit `package-lock.json`, use `npm ci` |
| Go binary differences | CGO linking, build flags | Use `CGO_ENABLED=0`, pin Go version |

## Summary

Reproducible Docker builds require discipline at every step: pinning base images by digest, locking dependency versions with hashes, eliminating timestamps, and controlling the build environment. Verify reproducibility by building the same image twice and comparing hashes. Integrate these checks into CI/CD so regressions get caught immediately. Build provenance attestations provide an additional layer of trust by recording exactly how each image was constructed. The result is a build pipeline where every image can be independently verified.
