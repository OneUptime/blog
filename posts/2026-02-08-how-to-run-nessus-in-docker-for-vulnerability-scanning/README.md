# How to Run Nessus in Docker for Vulnerability Scanning

Author: [nawazdhandala](https://github.com/nawazdhandala)

Tags: Docker, Nessus, Vulnerability Scanning, Security, Compliance, Penetration Testing

Description: Deploy Tenable Nessus vulnerability scanner in Docker for automated security assessments, compliance checks, and network scanning.

---

Nessus by Tenable is one of the most trusted vulnerability scanners in the security industry. It identifies security weaknesses across operating systems, applications, network services, and configurations. Organizations use it for compliance auditing (PCI DSS, HIPAA, CIS benchmarks), penetration testing preparation, and continuous vulnerability management.

Running Nessus in Docker lets you deploy the scanner quickly, isolate it from your primary systems, and manage it alongside your other containerized infrastructure. This guide covers deploying both Nessus Essentials (free, up to 16 IPs) and Nessus Professional in Docker.

## Nessus Editions

Tenable offers several Nessus editions:

- **Nessus Essentials**: Free for up to 16 IP addresses. Good for home labs and small environments.
- **Nessus Professional**: Unlimited IP scanning with compliance checks and advanced features. Requires a paid license.
- **Nessus Expert**: Adds attack surface discovery, cloud infrastructure scanning, and IaC analysis.

## Quick Start

Launch Nessus in Docker with a single command.

```bash
# Start Nessus with persistent data storage
# Port 8834 serves the web interface over HTTPS
docker run -d \
  --name nessus \
  -p 8834:8834 \
  -v nessus-data:/opt/nessus \
  tenable/nessus:latest-ubuntu
```

After starting, Nessus needs several minutes to initialize and compile its plugins. This process can take 10-20 minutes on first run.

## Docker Compose Setup

A production deployment benefits from resource limits and health monitoring.

```yaml
# docker-compose.yml - Nessus vulnerability scanner
# Includes persistent storage and resource management
version: "3.8"

services:
  nessus:
    image: tenable/nessus:latest-ubuntu
    container_name: nessus-scanner
    restart: unless-stopped
    ports:
      - "8834:8834"    # HTTPS web interface
    volumes:
      - nessus-data:/opt/nessus
    environment:
      # Set these for automatic registration on first boot
      - USERNAME=admin
      - PASSWORD=StrongPassword123!
      - ACTIVATION_CODE=XXXX-XXXX-XXXX-XXXX-XXXX
      # Set to "essentials", "professional", or "expert"
      - LICENSE_TYPE=essentials
    deploy:
      resources:
        limits:
          cpus: "4.0"
          memory: 4G
        reservations:
          cpus: "2.0"
          memory: 2G
    healthcheck:
      test: ["CMD", "curl", "-k", "-f", "https://localhost:8834/"]
      interval: 60s
      timeout: 10s
      retries: 5
      start_period: 300s    # Nessus needs time to compile plugins

volumes:
  nessus-data:
    driver: local
```

## Initial Setup

Access the Nessus web interface at https://your-server:8834 (note HTTPS). The browser will show a certificate warning because Nessus uses a self-signed certificate.

```bash
# Start Nessus
docker compose up -d

# Monitor the initialization progress
docker compose logs -f nessus

# Watch for the "Nessus is ready" message
# Plugin compilation can take 10-20 minutes on first run

# Check if Nessus is ready by testing the web interface
curl -k -s https://localhost:8834/server/status
```

If you did not set environment variables for registration, the web interface will walk you through creating an admin account and entering your activation code.

## Getting an Activation Code

For Nessus Essentials, register for a free activation code on the Tenable website.

```bash
# You can also register via the command line inside the container
docker exec -it nessus-scanner /opt/nessus/sbin/nessuscli fetch --register XXXX-XXXX-XXXX-XXXX-XXXX

# Check the registration status
docker exec -it nessus-scanner /opt/nessus/sbin/nessuscli fix --list
```

## Running Your First Scan

After Nessus finishes initializing, create and launch a scan through the web interface or the API.

```bash
# Nessus uses a REST API with token-based authentication
# First, get authentication tokens
TOKENS=$(curl -k -s -X POST "https://localhost:8834/session" \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"StrongPassword123!"}')

TOKEN=$(echo $TOKENS | python3 -c "import sys,json; print(json.load(sys.stdin)['token'])")

# List available scan templates
curl -k -s "https://localhost:8834/editor/scan/templates" \
  -H "X-Cookie: token=${TOKEN}" | python3 -m json.tool

# Create a basic network scan
SCAN_ID=$(curl -k -s -X POST "https://localhost:8834/scans" \
  -H "X-Cookie: token=${TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{
    "uuid": "731a8e52-3ea6-a291-ec0a-d2ff0619c19d7bd788d6be818b65",
    "settings": {
      "name": "Internal Network Scan",
      "text_targets": "192.168.1.0/24",
      "launch": "ON_DEMAND",
      "enabled": true,
      "scanner_id": 1,
      "description": "Weekly internal vulnerability scan"
    }
  }' | python3 -c "import sys,json; print(json.load(sys.stdin)['scan']['id'])")

echo "Created scan with ID: ${SCAN_ID}"

# Launch the scan
curl -k -s -X POST "https://localhost:8834/scans/${SCAN_ID}/launch" \
  -H "X-Cookie: token=${TOKEN}"
```

## Scan Policies

Configure scan policies to control what Nessus checks for. Common policy templates include:

```bash
# List available scan policy templates
curl -k -s "https://localhost:8834/editor/scan/templates" \
  -H "X-Cookie: token=${TOKEN}" | python3 -c "
import sys, json
templates = json.load(sys.stdin)['templates']
for t in templates:
    print(f\"{t['title']}: {t['desc']}\")"

# Common templates:
# - Basic Network Scan: Standard vulnerability assessment
# - Advanced Scan: Customizable scan with granular plugin selection
# - Credentialed Patch Audit: Checks installed patches via SSH/WMI
# - Web Application Tests: Tests web apps for OWASP Top 10
# - PCI-DSS Compliance: Validates PCI requirements
# - CIS Benchmark: Checks against CIS hardening standards
```

## Credentialed Scanning

Credentialed scans find significantly more vulnerabilities by logging into target systems and inspecting installed packages, configurations, and patches.

```bash
# Create a scan with SSH credentials for Linux targets
curl -k -s -X POST "https://localhost:8834/scans" \
  -H "X-Cookie: token=${TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{
    "uuid": "731a8e52-3ea6-a291-ec0a-d2ff0619c19d7bd788d6be818b65",
    "settings": {
      "name": "Credentialed Linux Scan",
      "text_targets": "192.168.1.10-50",
      "launch": "ON_DEMAND"
    },
    "credentials": {
      "add": {
        "Host": {
          "SSH": [{
            "auth_method": "password",
            "username": "scanner",
            "password": "scanner_password",
            "elevate_privileges_with": "sudo",
            "custom_password": "",
            "escalation_account": "root"
          }]
        }
      }
    }
  }'
```

## Scheduling Scans

Set up recurring scans to maintain continuous visibility into your security posture.

```bash
# Create a scheduled weekly scan that runs every Monday at 2 AM
curl -k -s -X POST "https://localhost:8834/scans" \
  -H "X-Cookie: token=${TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{
    "settings": {
      "name": "Weekly Vulnerability Scan",
      "text_targets": "192.168.1.0/24",
      "launch": "WEEKLY",
      "starttime": "20260209T020000",
      "rrules": "FREQ=WEEKLY;INTERVAL=1;BYDAY=MO",
      "enabled": true
    }
  }'
```

## Exporting Scan Results

Export scan reports in various formats for stakeholders.

```bash
# Get the list of completed scans
curl -k -s "https://localhost:8834/scans" \
  -H "X-Cookie: token=${TOKEN}" | python3 -c "
import sys, json
scans = json.load(sys.stdin)['scans']
for s in scans:
    print(f\"ID: {s['id']}, Name: {s['name']}, Status: {s['status']}\")"

# Export a scan report as PDF
EXPORT_ID=$(curl -k -s -X POST "https://localhost:8834/scans/${SCAN_ID}/export" \
  -H "X-Cookie: token=${TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{"format":"pdf"}' | python3 -c "import sys,json; print(json.load(sys.stdin)['file'])")

# Wait for the export to complete
sleep 10

# Download the report
curl -k -s "https://localhost:8834/scans/${SCAN_ID}/export/${EXPORT_ID}/download" \
  -H "X-Cookie: token=${TOKEN}" \
  -o vulnerability-report.pdf

# Export as CSV for data analysis
curl -k -s -X POST "https://localhost:8834/scans/${SCAN_ID}/export" \
  -H "X-Cookie: token=${TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{"format":"csv"}'
```

## Plugin Updates

Keep Nessus plugins up to date for the latest vulnerability checks.

```bash
# Force a plugin update
docker exec nessus-scanner /opt/nessus/sbin/nessuscli update --all

# Check the current plugin feed version
docker exec nessus-scanner /opt/nessus/sbin/nessuscli fix --list | grep "plugin"

# View the last update timestamp
curl -k -s "https://localhost:8834/server/properties" \
  -H "X-Cookie: token=${TOKEN}" | python3 -c "
import sys, json
props = json.load(sys.stdin)
print(f\"Plugin set: {props.get('loaded_plugin_set', 'N/A')}\")"
```

## Backup and Restore

Protect your scan data, policies, and configuration.

```bash
# Back up the entire Nessus data directory
docker run --rm -v nessus-data:/source:ro -v $(pwd):/backup alpine \
  tar czf /backup/nessus-backup-$(date +%Y%m%d).tar.gz -C /source .

# Restore from backup
docker stop nessus-scanner
docker run --rm -v nessus-data:/target -v $(pwd):/backup alpine \
  sh -c "rm -rf /target/* && tar xzf /backup/nessus-backup-20260208.tar.gz -C /target"
docker start nessus-scanner
```

## Performance Tuning

Nessus can be resource-intensive during large scans. Tune it for your environment.

```bash
# Adjust the maximum number of concurrent hosts scanned
# Default is 5, increase for faster scans on capable hardware
docker exec nessus-scanner /opt/nessus/sbin/nessuscli fix --set max_hosts=15

# Adjust the maximum number of checks per host
docker exec nessus-scanner /opt/nessus/sbin/nessuscli fix --set max_checks=10

# Restart Nessus to apply changes
docker restart nessus-scanner
```

## Security and Network Considerations

Place the Nessus container on a network segment that has access to all target systems. Scanning through firewalls produces incomplete results because blocked ports appear as false negatives. Create dedicated scanner credentials with minimal necessary privileges. Never expose the Nessus web interface to the public internet. Use a VPN or SSH tunnel for remote access. Monitor scan activity to ensure scans run on schedule and complete successfully. Integrate scan completion notifications with OneUptime or your preferred alerting platform.

Nessus in Docker delivers enterprise-grade vulnerability scanning in a container you can deploy in minutes. Regular scanning combined with prompt remediation keeps your attack surface small and your compliance auditors satisfied.
