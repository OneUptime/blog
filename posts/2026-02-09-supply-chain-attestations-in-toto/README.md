# How to Generate Supply Chain Attestations for Kubernetes Container Images Using In-Toto

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: Kubernetes, Security, Supply Chain, In-Toto, SLSA, Container Images

Description: Implement in-toto supply chain attestations for Kubernetes container images to create verifiable evidence of build processes, establish provenance, and meet SLSA supply chain security requirements.

---

Supply chain attacks targeting container images have become increasingly sophisticated. Attackers compromise build systems, inject malicious code during the build process, or tamper with images after creation. Traditional security measures like scanning existing images can't detect these attacks because the malicious code appears legitimate.

In-toto provides a framework for securing the integrity of software supply chains through attestations. Each step in your CI/CD pipeline generates cryptographically signed attestations proving what happened, who did it, and what artifacts were produced. When deploying to Kubernetes, you can verify these attestations to ensure images haven't been tampered with and followed approved build processes.

## Understanding In-Toto Framework Components

In-toto uses a few key concepts. Functionaries are entities that perform supply chain steps like building code or running tests. Each functionary has a keypair for signing attestations. Layouts define the expected supply chain steps, the functionaries authorized to perform each step, and inspection rules. Links are attestations generated by functionaries documenting what they did. Verification happens before deployment, checking that actual links match the expected layout.

For Kubernetes, this means generating attestations during your CI/CD pipeline and verifying them using admission webhooks before pods are created. This ensures every running container has provable provenance.

## Setting Up In-Toto for Container Builds

Start by installing in-toto and generating keys for your build system functionaries.

```bash
# Install in-toto
pip3 install in-toto

# Generate functionary keys for each CI/CD stage
in-toto-keygen builder
in-toto-keygen tester
in-toto-keygen signer

# Keys are stored as PEM files
ls -la *.pem
# builder (private key), builder.pub (public key)
# tester, tester.pub
# signer, signer.pub
```

Create a supply chain layout that defines your expected build process:

```python
# create-layout.py
#!/usr/bin/env python3

from in_toto.models.layout import Layout, Step, Inspection
from in_toto.models.metadata import Metablock

# Define the build step
build_step = Step(
    name="build",
    expected_materials=[
        ["MATCH", "Dockerfile", "WITH", "PRODUCTS", "FROM", "fetch-source"],
        ["MATCH", "src/*", "WITH", "PRODUCTS", "FROM", "fetch-source"]
    ],
    expected_products=[
        ["CREATE", "myapp:*"],  # Docker image created
        ["CREATE", "image-digest.txt"]  # Digest recorded
    ],
    pubkeys=["<builder-public-key-id>"],
    expected_command=[
        "docker",
        "build",
        "-t",
        "myapp:latest",
        "."
    ],
    threshold=1
)

# Define the test step
test_step = Step(
    name="test",
    expected_materials=[
        ["MATCH", "myapp:*", "WITH", "PRODUCTS", "FROM", "build"]
    ],
    expected_products=[
        ["CREATE", "test-results.xml"]
    ],
    pubkeys=["<tester-public-key-id>"],
    expected_command=[
        "pytest",
        "--junitxml=test-results.xml"
    ],
    threshold=1
)

# Define signing step
sign_step = Step(
    name="sign",
    expected_materials=[
        ["MATCH", "myapp:*", "WITH", "PRODUCTS", "FROM", "build"]
    ],
    expected_products=[
        ["CREATE", "signature.sig"]
    ],
    pubkeys=["<signer-public-key-id>"],
    expected_command=[
        "cosign",
        "sign"
    ],
    threshold=1
)

# Create the layout
layout = Layout(
    steps=[build_step, test_step, sign_step],
    inspect=[],
    keys={
        "<builder-public-key-id>": load_public_key("builder.pub"),
        "<tester-public-key-id>": load_public_key("tester.pub"),
        "<signer-public-key-id>": load_public_key("signer.pub")
    },
    expires="2027-12-31T23:59:59Z"
)

# Sign the layout with the root key
metablock = Metablock(signed=layout)
metablock.dump("root.layout")

print("Layout created: root.layout")
```

Run the script to generate your layout:

```bash
chmod +x create-layout.py
./create-layout.py
```

## Generating Attestations During CI/CD Pipeline

Modify your CI/CD pipeline to generate in-toto link attestations at each step. Here's an example GitHub Actions workflow:

```yaml
# .github/workflows/build-with-attestations.yaml
name: Build with In-Toto Attestations

on:
  push:
    branches: [main]

env:
  IMAGE_NAME: myapp
  REGISTRY: ghcr.io

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install in-toto
        run: pip3 install in-toto

      - name: Fetch builder key
        env:
          BUILDER_KEY: ${{ secrets.INTOTO_BUILDER_KEY }}
        run: |
          echo "$BUILDER_KEY" > builder
          chmod 600 builder

      - name: Start build attestation
        run: |
          in-toto-run \
            --step-name build \
            --key builder \
            --materials Dockerfile src/ \
            --products image-digest.txt \
            --verbose \
            -- docker build -t $IMAGE_NAME:${{ github.sha }} .

          # Record image digest
          docker inspect $IMAGE_NAME:${{ github.sha }} \
            --format='{{.Id}}' > image-digest.txt

      - name: Run tests with attestation
        env:
          TESTER_KEY: ${{ secrets.INTOTO_TESTER_KEY }}
        run: |
          echo "$TESTER_KEY" > tester
          chmod 600 tester

          in-toto-run \
            --step-name test \
            --key tester \
            --materials image-digest.txt \
            --products test-results.xml \
            -- docker run --rm $IMAGE_NAME:${{ github.sha }} pytest --junitxml=test-results.xml

      - name: Sign image with attestation
        env:
          SIGNER_KEY: ${{ secrets.INTOTO_SIGNER_KEY }}
          COSIGN_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
        run: |
          echo "$SIGNER_KEY" > signer
          chmod 600 signer
          echo "$COSIGN_KEY" > cosign.key

          # Sign with cosign
          cosign sign --key cosign.key $REGISTRY/$IMAGE_NAME:${{ github.sha }}

          # Generate in-toto attestation for signing
          in-toto-run \
            --step-name sign \
            --key signer \
            --materials image-digest.txt \
            --products signature.sig \
            -- cosign sign --key cosign.key $REGISTRY/$IMAGE_NAME:${{ github.sha }}

      - name: Push image
        run: |
          docker tag $IMAGE_NAME:${{ github.sha }} $REGISTRY/$IMAGE_NAME:${{ github.sha }}
          docker push $REGISTRY/$IMAGE_NAME:${{ github.sha }}

      - name: Bundle attestations
        run: |
          # Collect all link metadata files
          mkdir attestations
          cp build.*.link attestations/
          cp test.*.link attestations/
          cp sign.*.link attestations/
          cp root.layout attestations/

          # Create tarball
          tar czf attestations-${{ github.sha }}.tar.gz attestations/

      - name: Upload attestations to registry
        run: |
          # Attach attestations to image as OCI artifact
          cosign attach attestation \
            --attestation attestations-${{ github.sha }}.tar.gz \
            $REGISTRY/$IMAGE_NAME:${{ github.sha }}

      - name: Upload attestations as artifact
        uses: actions/upload-artifact@v3
        with:
          name: in-toto-attestations
          path: attestations-${{ github.sha }}.tar.gz
```

This workflow generates three link attestations (build, test, sign) and attaches them to the container image.

## Verifying Attestations with Kubernetes Admission Webhook

Create an admission webhook that verifies in-toto attestations before allowing pods to run:

```python
# in-toto-admission-webhook.py
#!/usr/bin/env python3

from flask import Flask, request, jsonify
import in_toto.verifylib
import in_toto.runlib
import subprocess
import json
import base64

app = Flask(__name__)

LAYOUT_PATH = "/etc/intoto/root.layout"
PUBKEYS_PATH = "/etc/intoto/keys/"

def verify_image_attestations(image):
    """Download and verify in-toto attestations for an image"""
    try:
        # Download attestations from registry
        cmd = f"cosign download attestation {image}"
        result = subprocess.run(
            cmd.split(),
            capture_output=True,
            text=True,
            timeout=30
        )

        if result.returncode != 0:
            return False, f"Failed to download attestations: {result.stderr}"

        # Extract attestations
        attestation_data = json.loads(result.stdout)

        # Save link files temporarily
        link_files = []
        for att in attestation_data:
            payload = base64.b64decode(att['payload'])
            link_data = json.loads(payload)
            link_file = f"/tmp/{link_data['_type']}.link"
            with open(link_file, 'w') as f:
                json.dump(link_data, f)
            link_files.append(link_file)

        # Verify using in-toto
        verification_result = in_toto.verifylib.in_toto_verify(
            layout_path=LAYOUT_PATH,
            layout_key_paths=[f"{PUBKEYS_PATH}/root.pub"],
            link_dir="/tmp/"
        )

        return True, "Attestations verified successfully"

    except Exception as e:
        return False, f"Verification failed: {str(e)}"

@app.route('/validate', methods=['POST'])
def validate():
    """Admission webhook endpoint"""
    admission_review = request.get_json()

    uid = admission_review['request']['uid']
    pod = admission_review['request']['object']

    # Extract container images
    images = []
    for container in pod['spec'].get('containers', []):
        images.append(container['image'])

    # Verify attestations for each image
    allowed = True
    messages = []

    for image in images:
        verified, message = verify_image_attestations(image)
        if not verified:
            allowed = False
            messages.append(f"{image}: {message}")

    response = {
        "apiVersion": "admission.k8s.io/v1",
        "kind": "AdmissionReview",
        "response": {
            "uid": uid,
            "allowed": allowed,
            "status": {
                "message": "; ".join(messages) if messages else "All attestations verified"
            }
        }
    }

    return jsonify(response)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8443, ssl_context='adhoc')
```

Deploy the webhook:

```yaml
# in-toto-webhook-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: in-toto-webhook
  namespace: intoto-system
spec:
  replicas: 3
  selector:
    matchLabels:
      app: in-toto-webhook
  template:
    metadata:
      labels:
        app: in-toto-webhook
    spec:
      containers:
      - name: webhook
        image: in-toto-webhook:latest
        ports:
        - containerPort: 8443
        volumeMounts:
        - name: intoto-config
          mountPath: /etc/intoto
          readOnly: true
        - name: webhook-certs
          mountPath: /etc/webhook/certs
          readOnly: true
      volumes:
      - name: intoto-config
        configMap:
          name: intoto-layout
      - name: webhook-certs
        secret:
          secretName: webhook-tls

---
apiVersion: v1
kind: Service
metadata:
  name: in-toto-webhook
  namespace: intoto-system
spec:
  selector:
    app: in-toto-webhook
  ports:
  - port: 443
    targetPort: 8443

---
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: in-toto-attestation-validator
webhooks:
- name: validate.intoto.io
  clientConfig:
    service:
      name: in-toto-webhook
      namespace: intoto-system
      path: /validate
    caBundle: <base64-encoded-ca-cert>
  rules:
  - operations: ["CREATE", "UPDATE"]
    apiGroups: [""]
    apiVersions: ["v1"]
    resources: ["pods"]
  admissionReviewVersions: ["v1"]
  sideEffects: None
  failurePolicy: Fail
  namespaceSelector:
    matchLabels:
      intoto-verification: enabled
```

## Integrating with SLSA Provenance

SLSA (Supply-chain Levels for Software Artifacts) builds on in-toto concepts. Generate SLSA provenance attestations that include detailed build metadata:

```bash
# generate-slsa-provenance.sh
#!/bin/bash

IMAGE_DIGEST=$1
BUILD_TYPE="https://slsa.dev/container-based-build/v0.1"
BUILDER_ID="https://github.com/myorg/myrepo/.github/workflows/build.yaml@refs/heads/main"

cat > provenance.json <<EOF
{
  "_type": "https://in-toto.io/Statement/v0.1",
  "subject": [
    {
      "name": "ghcr.io/myorg/myapp",
      "digest": {
        "sha256": "${IMAGE_DIGEST}"
      }
    }
  ],
  "predicateType": "https://slsa.dev/provenance/v0.2",
  "predicate": {
    "builder": {
      "id": "${BUILDER_ID}"
    },
    "buildType": "${BUILD_TYPE}",
    "invocation": {
      "configSource": {
        "uri": "git+https://github.com/myorg/myrepo@refs/heads/main",
        "digest": {
          "sha1": "$(git rev-parse HEAD)"
        },
        "entryPoint": ".github/workflows/build.yaml"
      }
    },
    "buildConfig": {
      "steps": [
        {
          "command": ["docker", "build", "-t", "myapp", "."],
          "env": []
        }
      ]
    },
    "metadata": {
      "buildInvocationId": "${GITHUB_RUN_ID}",
      "buildStartedOn": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
      "completeness": {
        "parameters": true,
        "environment": false,
        "materials": true
      },
      "reproducible": false
    },
    "materials": [
      {
        "uri": "git+https://github.com/myorg/myrepo@refs/heads/main",
        "digest": {
          "sha1": "$(git rev-parse HEAD)"
        }
      }
    ]
  }
}
EOF

# Sign the provenance
cosign attest --key cosign.key --predicate provenance.json ghcr.io/myorg/myapp@sha256:${IMAGE_DIGEST}
```

## Monitoring Attestation Verification

Track attestation verification metrics to detect supply chain attacks:

```yaml
# prometheus-intoto-rules.yaml
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: intoto-verification-alerts
  namespace: monitoring
spec:
  groups:
  - name: supply_chain_security
    interval: 1m
    rules:
    - alert: AttestationVerificationFailure
      expr: |
        rate(intoto_verification_failures_total[5m]) > 0
      for: 2m
      labels:
        severity: critical
      annotations:
        summary: "In-toto attestation verification failing"
        description: "{{ $value }} verification failures per second"

    - alert: MissingAttestations
      expr: |
        rate(intoto_missing_attestations_total[5m]) > 0
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "Images deployed without attestations"
        description: "{{ $value }} images missing attestations"
```

In-toto supply chain attestations transform container security from reactive scanning to proactive verification. By cryptographically proving each step in your build process, you create an auditable chain of custody from source code to running container. This prevents supply chain attacks by detecting any unauthorized modifications or deviations from approved build processes. Start with attestations for production images and expand to all environments as you mature your supply chain security posture.
