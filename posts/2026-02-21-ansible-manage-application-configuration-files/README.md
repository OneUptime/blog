# How to Use Ansible to Manage Application Configuration Files

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: Ansible, Configuration Management, Templates, DevOps

Description: Manage application configuration files with Ansible using templates, environment-specific variables, and Ansible Vault for secrets.

---

Every application needs configuration: database connections, API keys, feature flags, logging levels, and service endpoints. Managing these configuration files across multiple environments (development, staging, production) and servers is one of the core challenges in operations. Ansible excels at this because its template engine (Jinja2) can generate environment-specific configs from a single template, and Ansible Vault keeps secrets encrypted.

This guide covers strategies for managing application configuration files with Ansible, from simple file deployment to complex multi-environment setups.

## Configuration Management Strategies

There are several approaches to managing config files with Ansible:

1. **Template-based**: Use Jinja2 templates with variables per environment
2. **Copy-based**: Copy static config files for each environment
3. **Line-in-file**: Modify specific lines in existing config files
4. **Blockinfile**: Insert or replace blocks of configuration

Templates are the most flexible and the approach we will focus on.

## Project Structure

```
config-management/
  inventory/
    staging.yml
    production.yml
  group_vars/
    staging/
      vars.yml
      vault.yml
    production/
      vars.yml
      vault.yml
  host_vars/
    web1.yml
    web2.yml
  roles/
    app_config/
      tasks/
        main.yml
      templates/
        app.conf.j2
        database.yml.j2
        redis.conf.j2
        logging.yml.j2
      handlers/
        main.yml
  playbook.yml
```

## Environment-Specific Variables

The key to managing configs across environments is the variable hierarchy. Ansible loads variables from multiple sources, with more specific sources overriding general ones.

```yaml
# group_vars/staging/vars.yml - Staging environment settings
app_env: staging
app_debug: true
log_level: debug

db_host: staging-db.internal
db_port: 5432
db_name: myapp_staging
db_pool_size: 5

redis_host: staging-redis.internal
redis_port: 6379
redis_db: 0

api_base_url: https://staging-api.example.com
cdn_url: https://staging-cdn.example.com
feature_flags:
  new_dashboard: true
  beta_features: true
  maintenance_mode: false
```

```yaml
# group_vars/production/vars.yml - Production environment settings
app_env: production
app_debug: false
log_level: warning

db_host: prod-db.internal
db_port: 5432
db_name: myapp_production
db_pool_size: 20

redis_host: prod-redis.internal
redis_port: 6379
redis_db: 0

api_base_url: https://api.example.com
cdn_url: https://cdn.example.com
feature_flags:
  new_dashboard: false
  beta_features: false
  maintenance_mode: false
```

```yaml
# group_vars/staging/vault.yml (encrypted)
vault_db_password: staging-password-here
vault_secret_key: staging-secret-key-here
vault_api_key: staging-api-key-here
```

```yaml
# group_vars/production/vault.yml (encrypted)
vault_db_password: production-password-here
vault_secret_key: production-secret-key-here
vault_api_key: production-api-key-here
```

## Host-Specific Overrides

Sometimes a specific server needs different configuration:

```yaml
# host_vars/web1.yml - Overrides for a specific server
db_pool_size: 30  # This server handles more traffic
log_level: info   # More logging on this specific host
```

## Configuration Templates

Here is a multi-format configuration template example. First, a YAML-based application config:

```yaml
# roles/app_config/templates/app.conf.j2
# Application Configuration - Generated by Ansible
# Do not edit manually. Changes will be overwritten on next deployment.

app:
  name: {{ app_name }}
  environment: {{ app_env }}
  debug: {{ app_debug | lower }}
  secret_key: {{ vault_secret_key }}

server:
  host: 0.0.0.0
  port: {{ app_port | default(8000) }}
  workers: {{ ansible_processor_vcpus * 2 + 1 }}

database:
  host: {{ db_host }}
  port: {{ db_port }}
  name: {{ db_name }}
  username: {{ db_user | default(app_name) }}
  password: {{ vault_db_password }}
  pool_size: {{ db_pool_size }}
  pool_timeout: 30

redis:
  host: {{ redis_host }}
  port: {{ redis_port }}
  db: {{ redis_db }}

logging:
  level: {{ log_level }}
  format: json
{% if app_env == 'production' %}
  file: /var/log/{{ app_name }}/app.log
{% else %}
  file: stdout
{% endif %}

api:
  base_url: {{ api_base_url }}
  key: {{ vault_api_key }}
  timeout: 30

cdn:
  url: {{ cdn_url }}

features:
{% for flag, enabled in feature_flags.items() %}
  {{ flag }}: {{ enabled | lower }}
{% endfor %}
```

A .env file template for applications that use dotenv:

```bash
# roles/app_config/templates/dotenv.j2
# Environment variables - Generated by Ansible
# Deployed at {{ ansible_date_time.iso8601 }}

APP_ENV={{ app_env }}
APP_DEBUG={{ app_debug | string | lower }}
APP_SECRET={{ vault_secret_key }}

DATABASE_URL=postgresql://{{ db_user | default(app_name) }}:{{ vault_db_password }}@{{ db_host }}:{{ db_port }}/{{ db_name }}
REDIS_URL=redis://{{ redis_host }}:{{ redis_port }}/{{ redis_db }}

LOG_LEVEL={{ log_level }}
API_KEY={{ vault_api_key }}
CDN_URL={{ cdn_url }}
```

An INI-style configuration for applications that use that format:

```ini
# roles/app_config/templates/app.ini.j2
; Application Configuration - Generated by Ansible

[app]
name = {{ app_name }}
environment = {{ app_env }}
debug = {{ app_debug | lower }}
secret_key = {{ vault_secret_key }}

[database]
host = {{ db_host }}
port = {{ db_port }}
name = {{ db_name }}
user = {{ db_user | default(app_name) }}
password = {{ vault_db_password }}
pool_size = {{ db_pool_size }}

[redis]
host = {{ redis_host }}
port = {{ redis_port }}
db = {{ redis_db }}

[logging]
level = {{ log_level }}
{% if app_env == 'production' %}
file = /var/log/{{ app_name }}/app.log
{% else %}
file = stdout
{% endif %}
```

## Role Tasks

```yaml
# roles/app_config/tasks/main.yml
---
- name: Create configuration directory
  file:
    path: "{{ app_dir }}/config"
    state: directory
    owner: "{{ app_user }}"
    group: "{{ app_group }}"
    mode: '0750'

- name: Deploy main application configuration
  template:
    src: app.conf.j2
    dest: "{{ app_dir }}/config/app.conf"
    owner: "{{ app_user }}"
    group: "{{ app_group }}"
    mode: '0640'
    backup: yes
  notify: restart application
  register: config_result

- name: Deploy environment file
  template:
    src: dotenv.j2
    dest: "{{ app_dir }}/.env"
    owner: "{{ app_user }}"
    group: "{{ app_group }}"
    mode: '0600'
  notify: restart application

- name: Validate configuration syntax
  command: "{{ app_dir }}/bin/validate-config {{ app_dir }}/config/app.conf"
  become_user: "{{ app_user }}"
  changed_when: false
  when: config_result.changed

- name: Display config change notification
  debug:
    msg: "Configuration has been updated. Application will be restarted."
  when: config_result.changed
```

## Using lineinfile for Surgical Edits

Sometimes you need to change a single line in an existing config file:

```yaml
# Change a specific setting in an existing configuration file
- name: Update log level in existing config
  lineinfile:
    path: /etc/myapp/settings.conf
    regexp: '^log_level\s*='
    line: "log_level = {{ log_level }}"
    backup: yes
  notify: restart application

- name: Ensure a setting exists in the config
  lineinfile:
    path: /etc/myapp/settings.conf
    line: "max_connections = {{ max_connections }}"
    insertafter: '^\[database\]'
  notify: restart application
```

## Using blockinfile for Multi-Line Changes

When you need to insert or update a block of configuration:

```yaml
# Insert a configuration block into an existing file
- name: Add monitoring configuration block
  blockinfile:
    path: /etc/myapp/settings.conf
    marker: "# {mark} ANSIBLE MANAGED - monitoring"
    block: |
      [monitoring]
      enabled = true
      endpoint = {{ monitoring_endpoint }}
      interval = 60
      metrics = cpu,memory,requests
    insertafter: EOF
  notify: restart application
```

## Configuration Validation

Always validate configuration before restarting services:

```yaml
# Validate configuration and roll back if invalid
- name: Deploy new configuration
  template:
    src: nginx.conf.j2
    dest: /etc/nginx/nginx.conf
    backup: yes
  register: nginx_config

- name: Validate Nginx configuration
  command: nginx -t
  register: nginx_test
  changed_when: false
  ignore_errors: yes

- name: Restore backup if validation fails
  command: "cp {{ nginx_config.backup_file }} /etc/nginx/nginx.conf"
  when: nginx_test.rc != 0

- name: Fail if configuration is invalid
  fail:
    msg: "Nginx configuration validation failed. Previous config restored."
  when: nginx_test.rc != 0
```

## Handlers

```yaml
# roles/app_config/handlers/main.yml
---
- name: restart application
  systemd:
    name: "{{ app_name }}"
    state: restarted
```

## Running the Playbook

```bash
# Deploy configuration to staging
ansible-playbook -i inventory/staging.yml playbook.yml --ask-vault-pass

# Deploy configuration to production
ansible-playbook -i inventory/production.yml playbook.yml --ask-vault-pass

# Preview changes without applying
ansible-playbook -i inventory/production.yml playbook.yml --check --diff
```

The `--diff` flag is particularly useful for configuration management because it shows you exactly what will change in each file before applying.

## Wrapping Up

Managing application configuration with Ansible gives you version-controlled, environment-specific, and secret-safe configuration deployment. The combination of Jinja2 templates for config generation, Ansible's variable hierarchy for environment separation, and Ansible Vault for secret encryption covers most configuration management needs. Always back up configs before changing them, validate syntax where possible, and use `--check --diff` to preview changes before applying to production.
