# How to Use Ansible Delegation for Monitoring Registration

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: Ansible, Monitoring, Delegation, Prometheus, Nagios

Description: Learn how to use Ansible delegation to register and deregister hosts with monitoring systems during provisioning and deployments.

---

Every server you provision needs to be monitored. Every server you decommission needs to be removed from monitoring. And during deployments, you often need to silence alerts to avoid false positives. Ansible delegation makes this straightforward by letting you interact with monitoring APIs or configuration from your server provisioning and deployment playbooks. The monitoring tasks delegate to the monitoring server or to localhost for API-based systems.

## Registering Hosts with Prometheus

Prometheus uses file-based service discovery or API-based targets. Here is how to update Prometheus target files when provisioning new hosts:

```yaml
# prometheus-register.yml - Register hosts with Prometheus
---
- name: Provision and register with Prometheus
  hosts: webservers
  gather_facts: true
  vars:
    prometheus_server: prometheus.internal.example.com
    prometheus_targets_dir: /etc/prometheus/targets
  tasks:
    - name: Install and configure application
      ansible.builtin.apt:
        name: myapp
        state: present
      become: true

    - name: Configure node exporter
      ansible.builtin.apt:
        name: prometheus-node-exporter
        state: present
      become: true

    - name: Ensure node exporter is running
      ansible.builtin.systemd:
        name: prometheus-node-exporter
        state: started
        enabled: true
      become: true

    - name: Generate Prometheus target file for this host
      ansible.builtin.copy:
        content: |
          - targets:
              - "{{ ansible_host }}:9100"
              - "{{ ansible_host }}:8080"
            labels:
              hostname: "{{ inventory_hostname }}"
              environment: "{{ env }}"
              role: webserver
              datacenter: "{{ datacenter | default('dc1') }}"
        dest: "{{ prometheus_targets_dir }}/{{ inventory_hostname }}.yml"
        mode: '0644'
      delegate_to: "{{ prometheus_server }}"
      become: true

    - name: Verify Prometheus can scrape the new target
      ansible.builtin.uri:
        url: "http://{{ prometheus_server }}:9090/api/v1/targets"
        return_content: true
      register: prom_targets
      delegate_to: localhost
      retries: 6
      delay: 10
      until: ansible_host in prom_targets.content
```

## Registering with Nagios/Icinga

For Nagios-style monitoring, you generate host configuration files on the monitoring server:

```yaml
# nagios-register.yml - Register hosts with Nagios/Icinga
---
- name: Register host with Nagios monitoring
  hosts: all
  gather_facts: true
  vars:
    nagios_server: nagios.internal.example.com
    nagios_config_dir: /etc/nagios/conf.d/hosts
  tasks:
    - name: Generate Nagios host configuration
      ansible.builtin.template:
        src: nagios-host.cfg.j2
        dest: "{{ nagios_config_dir }}/{{ inventory_hostname }}.cfg"
        mode: '0644'
      delegate_to: "{{ nagios_server }}"
      become: true
      notify: Reload Nagios

    - name: Verify Nagios configuration
      ansible.builtin.command: nagios -v /etc/nagios/nagios.cfg
      delegate_to: "{{ nagios_server }}"
      become: true
      changed_when: false

  handlers:
    - name: Reload Nagios
      ansible.builtin.systemd:
        name: nagios
        state: reloaded
      delegate_to: "{{ nagios_server }}"
      become: true
```

The Nagios host template:

```cfg
# templates/nagios-host.cfg.j2
# Auto-generated by Ansible - do not edit manually
define host {
    use                     linux-server
    host_name               {{ inventory_hostname }}
    alias                   {{ inventory_hostname_short }}
    address                 {{ ansible_host }}
    max_check_attempts      5
    check_period            24x7
    notification_interval   30
    notification_period     24x7
    _ENVIRONMENT            {{ env }}
    _ROLE                   {{ role | default('generic') }}
}

define service {
    use                     generic-service
    host_name               {{ inventory_hostname }}
    service_description     SSH
    check_command           check_ssh
}

define service {
    use                     generic-service
    host_name               {{ inventory_hostname }}
    service_description     HTTP Health Check
    check_command           check_http!-p 8080 -u /health -e 200
}

{% if 'databases' in group_names %}
define service {
    use                     generic-service
    host_name               {{ inventory_hostname }}
    service_description     PostgreSQL
    check_command           check_pgsql!-d myapp_production
}
{% endif %}
```

## Datadog Registration via API

For SaaS monitoring like Datadog, delegate API calls to localhost:

```yaml
# datadog-register.yml - Register hosts with Datadog
---
- name: Register hosts with Datadog monitoring
  hosts: webservers
  gather_facts: true
  vars:
    datadog_api_key: "{{ vault_datadog_api_key }}"
    datadog_app_key: "{{ vault_datadog_app_key }}"
  tasks:
    - name: Install Datadog agent
      ansible.builtin.apt:
        name: datadog-agent
        state: present
      become: true

    - name: Configure Datadog agent
      ansible.builtin.template:
        src: datadog.yaml.j2
        dest: /etc/datadog-agent/datadog.yaml
        mode: '0640'
        owner: dd-agent
        group: dd-agent
      become: true
      notify: Restart Datadog agent

    - name: Add host tags via Datadog API
      ansible.builtin.uri:
        url: "https://api.datadoghq.com/api/v1/tags/hosts/{{ inventory_hostname }}"
        method: PUT
        headers:
          DD-API-KEY: "{{ datadog_api_key }}"
          DD-APPLICATION-KEY: "{{ datadog_app_key }}"
          Content-Type: "application/json"
        body_format: json
        body:
          tags:
            - "environment:{{ env }}"
            - "role:webserver"
            - "version:{{ app_version }}"
            - "region:{{ aws_region | default('unknown') }}"
        status_code: [200, 201]
      delegate_to: localhost

    - name: Create Datadog monitor for this service
      ansible.builtin.uri:
        url: "https://api.datadoghq.com/api/v1/monitor"
        method: POST
        headers:
          DD-API-KEY: "{{ datadog_api_key }}"
          DD-APPLICATION-KEY: "{{ datadog_app_key }}"
          Content-Type: "application/json"
        body_format: json
        body:
          name: "HTTP Health Check - {{ inventory_hostname }}"
          type: http
          query: ""
          message: "Health check failed on {{ inventory_hostname }}"
          options:
            thresholds:
              critical: 3
            notify_no_data: true
        status_code: [200, 201, 409]
      delegate_to: localhost
      run_once: true

  handlers:
    - name: Restart Datadog agent
      ansible.builtin.systemd:
        name: datadog-agent
        state: restarted
      become: true
```

## Maintenance Windows During Deployments

During deployments, you need to suppress alerts. Here are patterns for different monitoring systems:

```yaml
# maintenance-windows.yml - Set monitoring maintenance during deployment
---
- name: Deploy with monitoring maintenance windows
  hosts: webservers
  serial: 2
  tasks:
    # Prometheus/Alertmanager silence
    - name: Create Alertmanager silence for deployment
      ansible.builtin.uri:
        url: "http://alertmanager.internal:9093/api/v2/silences"
        method: POST
        body_format: json
        body:
          matchers:
            - name: instance
              value: "{{ ansible_host }}:.*"
              isRegex: true
            - name: job
              value: "myapp"
          startsAt: "{{ now(utc=true).isoformat() }}"
          endsAt: "{{ '%Y-%m-%dT%H:%M:%S' | strftime(now().timestamp() | int + 1800) }}Z"
          createdBy: "ansible-deployer"
          comment: "Deployment of v{{ version }} in progress"
        status_code: [200, 201]
      register: silence
      delegate_to: localhost

    # Datadog downtime
    - name: Set Datadog downtime
      ansible.builtin.uri:
        url: "https://api.datadoghq.com/api/v1/downtime"
        method: POST
        headers:
          DD-API-KEY: "{{ datadog_api_key }}"
          DD-APPLICATION-KEY: "{{ datadog_app_key }}"
        body_format: json
        body:
          scope: "host:{{ inventory_hostname }}"
          start: "{{ now().timestamp() | int }}"
          end: "{{ now().timestamp() | int + 1800 }}"
          message: "Deployment v{{ version }}"
      register: downtime
      delegate_to: localhost

    # Deploy application
    - name: Stop application
      ansible.builtin.systemd:
        name: myapp
        state: stopped
      become: true

    - name: Deploy new version
      ansible.builtin.copy:
        src: /releases/{{ version }}/
        dest: /opt/myapp/
      become: true

    - name: Start application
      ansible.builtin.systemd:
        name: myapp
        state: started
      become: true

    - name: Verify health
      ansible.builtin.uri:
        url: "http://{{ ansible_host }}:8080/health"
        status_code: 200
      delegate_to: localhost
      register: health
      retries: 15
      delay: 5
      until: health.status == 200

    # Remove silences after successful deployment
    - name: Remove Alertmanager silence
      ansible.builtin.uri:
        url: "http://alertmanager.internal:9093/api/v2/silence/{{ silence.json.silenceID }}"
        method: DELETE
        status_code: [200, 404]
      delegate_to: localhost
      when: silence is defined and silence.json is defined

    - name: Cancel Datadog downtime
      ansible.builtin.uri:
        url: "https://api.datadoghq.com/api/v1/downtime/{{ downtime.json.id }}"
        method: DELETE
        headers:
          DD-API-KEY: "{{ datadog_api_key }}"
          DD-APPLICATION-KEY: "{{ datadog_app_key }}"
        status_code: [200, 204, 404]
      delegate_to: localhost
      when: downtime is defined and downtime.json is defined
```

## Deregistering Hosts from Monitoring

When decommissioning servers, clean up monitoring configuration:

```yaml
# deregister-monitoring.yml - Remove hosts from all monitoring systems
---
- name: Deregister hosts from monitoring
  hosts: decommission_targets
  gather_facts: false
  vars:
    prometheus_server: prometheus.internal.example.com
    nagios_server: nagios.internal.example.com
  tasks:
    - name: Remove Prometheus target file
      ansible.builtin.file:
        path: "/etc/prometheus/targets/{{ inventory_hostname }}.yml"
        state: absent
      delegate_to: "{{ prometheus_server }}"
      become: true

    - name: Remove Nagios host configuration
      ansible.builtin.file:
        path: "/etc/nagios/conf.d/hosts/{{ inventory_hostname }}.cfg"
        state: absent
      delegate_to: "{{ nagios_server }}"
      become: true
      notify: Reload Nagios on deregister

    - name: Remove host tags from Datadog
      ansible.builtin.uri:
        url: "https://api.datadoghq.com/api/v1/tags/hosts/{{ inventory_hostname }}"
        method: DELETE
        headers:
          DD-API-KEY: "{{ datadog_api_key }}"
          DD-APPLICATION-KEY: "{{ datadog_app_key }}"
        status_code: [200, 204, 404]
      delegate_to: localhost

    - name: Remove Datadog monitors for this host
      ansible.builtin.uri:
        url: "https://api.datadoghq.com/api/v1/monitor/search?query=host:{{ inventory_hostname }}"
        method: GET
        headers:
          DD-API-KEY: "{{ datadog_api_key }}"
          DD-APPLICATION-KEY: "{{ datadog_app_key }}"
      register: monitors
      delegate_to: localhost

    - name: Delete each monitor
      ansible.builtin.uri:
        url: "https://api.datadoghq.com/api/v1/monitor/{{ item.id }}"
        method: DELETE
        headers:
          DD-API-KEY: "{{ datadog_api_key }}"
          DD-APPLICATION-KEY: "{{ datadog_app_key }}"
        status_code: [200, 204]
      loop: "{{ monitors.json.monitors | default([]) }}"
      delegate_to: localhost

  handlers:
    - name: Reload Nagios on deregister
      ansible.builtin.systemd:
        name: nagios
        state: reloaded
      delegate_to: "{{ nagios_server }}"
      become: true
```

## Monitoring Registration as a Reusable Role

Wrap monitoring registration in a role that you include in all your provisioning playbooks:

```yaml
# roles/monitoring_register/tasks/main.yml - Reusable monitoring registration
---
- name: Register with Prometheus (file-based SD)
  ansible.builtin.template:
    src: prometheus-target.yml.j2
    dest: "/etc/prometheus/targets/{{ inventory_hostname }}.yml"
    mode: '0644'
  delegate_to: "{{ prometheus_server }}"
  become: true
  when: prometheus_server is defined

- name: Register with Datadog API
  ansible.builtin.uri:
    url: "https://api.datadoghq.com/api/v1/tags/hosts/{{ inventory_hostname }}"
    method: PUT
    headers:
      DD-API-KEY: "{{ datadog_api_key }}"
      DD-APPLICATION-KEY: "{{ datadog_app_key }}"
    body_format: json
    body:
      tags: "{{ monitoring_tags }}"
    status_code: [200, 201]
  delegate_to: localhost
  when: datadog_api_key is defined

- name: Verify monitoring is receiving data
  ansible.builtin.uri:
    url: "http://{{ prometheus_server }}:9090/api/v1/query?query=up{instance='{{ ansible_host }}:9100'}"
    return_content: true
  register: prom_check
  delegate_to: localhost
  retries: 6
  delay: 30
  until: >
    prom_check.json.data.result | length > 0 and
    prom_check.json.data.result[0].value[1] == "1"
  when: prometheus_server is defined
```

Use it in any provisioning playbook:

```yaml
# provision-server.yml - Using the monitoring registration role
---
- name: Provision new server
  hosts: new_servers
  roles:
    - base_configuration
    - application_deploy
    - monitoring_register
  vars:
    monitoring_tags:
      - "environment:{{ env }}"
      - "role:{{ server_role }}"
```

## Summary

Monitoring registration through Ansible delegation keeps your monitoring configuration in sync with your infrastructure. For file-based monitoring (Prometheus file SD, Nagios), delegate configuration file updates to the monitoring server. For API-based monitoring (Datadog, PagerDuty, cloud-native), delegate API calls to localhost. Always set maintenance windows or silences during deployments, clean up monitoring when decommissioning hosts, and wrap monitoring registration in a reusable role that you include in every provisioning playbook. This ensures no server goes unmonitored and no decommissioned server generates phantom alerts.
