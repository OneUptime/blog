# How to Configure Contract Testing with Pact

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: Contract Testing, Pact, Microservices, API Testing, Consumer-Driven Contracts, Integration Testing, DevOps

Description: A comprehensive guide to setting up and configuring contract testing with Pact to ensure reliable API integrations between microservices.

---

In a microservices architecture, services depend on each other through APIs. When one service changes its API, dependent services can break silently. Contract testing with Pact solves this by creating verifiable agreements between service providers and consumers. This guide shows you how to set up Pact from scratch.

---

## Table of Contents

1. What is Contract Testing?
2. How Pact Works
3. Setting Up the Consumer Side
4. Setting Up the Provider Side
5. Using a Pact Broker
6. CI/CD Integration
7. Advanced Pact Patterns
8. Common Issues and Fixes

---

## 1. What is Contract Testing?

Contract testing verifies that two services can communicate correctly without requiring both services to be running simultaneously.

### Contract Testing vs Integration Testing

```mermaid
flowchart LR
    subgraph "Integration Testing"
        C1[Consumer] --> P1[Provider]
        P1 --> DB1[(Database)]
        Note1[Requires all services running]
    end

    subgraph "Contract Testing"
        C2[Consumer] --> MOCK[Mock Provider]
        PACT[Pact Contract] --> V[Provider Verifier]
        V --> P2[Provider]
        Note2[Services tested independently]
    end
```

| Aspect | Integration Testing | Contract Testing |
|--------|---------------------|------------------|
| **Dependencies** | Requires all services | Services tested independently |
| **Speed** | Slow (network, databases) | Fast (mocked interactions) |
| **Reliability** | Flaky (environment issues) | Stable (isolated tests) |
| **Feedback** | Late (after deployment) | Early (during development) |
| **Scope** | End-to-end behavior | API contract compliance |

### Why Pact?

Pact is the most widely adopted contract testing tool. It supports:

- Multiple languages (JavaScript, Java, Python, Go, Ruby, .NET, Rust)
- Consumer-driven contracts
- Provider verification
- Contract versioning and management

---

## 2. How Pact Works

Pact follows a consumer-driven approach where the consumer defines what it expects from the provider.

```mermaid
sequenceDiagram
    participant Consumer
    participant PactMock as Pact Mock Server
    participant PactFile as Pact Contract File
    participant Broker as Pact Broker
    participant Provider

    Note over Consumer,PactMock: Consumer Test Phase
    Consumer->>PactMock: Define expectations
    PactMock->>Consumer: Return mocked responses
    PactMock->>PactFile: Generate contract

    Note over PactFile,Broker: Contract Publishing
    PactFile->>Broker: Publish contract

    Note over Broker,Provider: Provider Verification Phase
    Broker->>Provider: Fetch contracts
    Provider->>Provider: Replay interactions
    Provider->>Broker: Report verification results
```

### Key Concepts

| Concept | Description |
|---------|-------------|
| **Consumer** | Service that makes API requests |
| **Provider** | Service that handles API requests |
| **Interaction** | A single request/response pair |
| **Pact File** | JSON contract generated by consumer tests |
| **Pact Broker** | Central repository for contracts |

---

## 3. Setting Up the Consumer Side

Let's set up contract testing for a consumer service that calls a user API.

### Installation

```bash
# For JavaScript/TypeScript projects
npm install --save-dev @pact-foundation/pact

# For Python projects
pip install pact-python

# For Go projects
go get github.com/pact-foundation/pact-go/v2
```

### Consumer Test Example (JavaScript)

```javascript
// tests/consumer/userService.pact.test.js
const { PactV3, MatchersV3 } = require('@pact-foundation/pact');
const { fetchUser } = require('../../src/userService');
const path = require('path');

// Define matchers for flexible contract matching
const { like, eachLike, regex, integer, string } = MatchersV3;

describe('User Service Consumer Contract', () => {
  // Configure the mock provider
  const provider = new PactV3({
    consumer: 'OrderService',      // Name of this consumer
    provider: 'UserService',       // Name of the provider we depend on
    dir: path.resolve(process.cwd(), 'pacts'),  // Where to write contracts
    logLevel: 'warn'
  });

  describe('GET /users/:id', () => {
    it('returns a user when the user exists', async () => {
      // Define the expected interaction
      await provider
        .given('a user with ID 123 exists')  // Provider state
        .uponReceiving('a request for user 123')
        .withRequest({
          method: 'GET',
          path: '/users/123',
          headers: {
            Accept: 'application/json',
            Authorization: regex(/^Bearer .+$/, 'Bearer token123')
          }
        })
        .willRespondWith({
          status: 200,
          headers: {
            'Content-Type': 'application/json'
          },
          body: {
            id: integer(123),
            name: string('John Doe'),
            email: regex(/^.+@.+\..+$/, 'john@example.com'),
            roles: eachLike('admin'),  // Array with at least one element
            createdAt: like('2024-01-15T10:30:00Z')
          }
        });

      // Execute the test against the mock provider
      await provider.executeTest(async (mockServer) => {
        // Point our service to the mock server
        const user = await fetchUser(123, {
          baseUrl: mockServer.url,
          token: 'token123'
        });

        // Assert the response matches expectations
        expect(user.id).toBe(123);
        expect(user.name).toBeDefined();
        expect(user.email).toContain('@');
        expect(user.roles).toBeInstanceOf(Array);
      });
    });

    it('returns 404 when user does not exist', async () => {
      await provider
        .given('no user with ID 999 exists')
        .uponReceiving('a request for non-existent user')
        .withRequest({
          method: 'GET',
          path: '/users/999',
          headers: {
            Accept: 'application/json',
            Authorization: regex(/^Bearer .+$/, 'Bearer token123')
          }
        })
        .willRespondWith({
          status: 404,
          headers: {
            'Content-Type': 'application/json'
          },
          body: {
            error: string('User not found'),
            code: string('USER_NOT_FOUND')
          }
        });

      await provider.executeTest(async (mockServer) => {
        await expect(
          fetchUser(999, { baseUrl: mockServer.url, token: 'token123' })
        ).rejects.toThrow('User not found');
      });
    });
  });
});
```

### The Service Being Tested

```javascript
// src/userService.js
async function fetchUser(userId, { baseUrl, token }) {
  const response = await fetch(`${baseUrl}/users/${userId}`, {
    headers: {
      Accept: 'application/json',
      Authorization: `Bearer ${token}`
    }
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error || 'Request failed');
  }

  return response.json();
}

module.exports = { fetchUser };
```

### Running Consumer Tests

```bash
# Run the consumer tests to generate pact files
npm test -- --testPathPattern=pact

# This generates: pacts/OrderService-UserService.json
```

---

## 4. Setting Up the Provider Side

The provider must verify it can fulfill the contracts created by consumers.

### Provider Verification (JavaScript)

```javascript
// tests/provider/userService.pact.verify.js
const { Verifier } = require('@pact-foundation/pact');
const path = require('path');
const app = require('../../src/app');  // Your Express/Fastify app

describe('User Service Provider Verification', () => {
  let server;

  beforeAll(async () => {
    // Start the provider service
    server = app.listen(3001);
  });

  afterAll(async () => {
    server.close();
  });

  it('validates the expectations of OrderService', async () => {
    const options = {
      provider: 'UserService',
      providerBaseUrl: 'http://localhost:3001',

      // Option 1: Load pacts from local files
      pactUrls: [
        path.resolve(__dirname, '../../pacts/OrderService-UserService.json')
      ],

      // Option 2: Load pacts from a broker (preferred for CI)
      // pactBrokerUrl: 'https://your-broker.pactflow.io',
      // pactBrokerToken: process.env.PACT_BROKER_TOKEN,
      // consumerVersionSelectors: [
      //   { mainBranch: true },
      //   { deployedOrReleased: true }
      // ],

      // Provider states setup
      stateHandlers: {
        'a user with ID 123 exists': async () => {
          // Set up test data for this state
          await seedUser({
            id: 123,
            name: 'John Doe',
            email: 'john@example.com',
            roles: ['admin']
          });
        },
        'no user with ID 999 exists': async () => {
          // Ensure no user with this ID exists
          await deleteUser(999);
        }
      },

      // Publish verification results to broker
      publishVerificationResult: process.env.CI === 'true',
      providerVersion: process.env.GIT_COMMIT || '1.0.0',
      providerVersionBranch: process.env.GIT_BRANCH || 'main',

      logLevel: 'warn'
    };

    // Run verification
    await new Verifier(options).verifyProvider();
  });
});

// Helper functions for state setup
async function seedUser(user) {
  // Insert user into test database
  const db = require('../../src/database');
  await db.users.upsert(user);
}

async function deleteUser(id) {
  const db = require('../../src/database');
  await db.users.delete(id);
}
```

### Provider State Management

Provider states are crucial for setting up the right conditions before each interaction is verified.

```javascript
// More complex state handlers
const stateHandlers = {
  // State with parameters
  'a user exists': async (params) => {
    await seedUser({
      id: params.id,
      name: params.name || 'Test User',
      email: params.email || 'test@example.com'
    });
  },

  // Async state setup with cleanup
  'the system has 5 active users': async () => {
    // Clear existing users
    await db.users.deleteAll();

    // Seed 5 users
    for (let i = 1; i <= 5; i++) {
      await seedUser({ id: i, name: `User ${i}` });
    }
  },

  // State for error scenarios
  'the database is unavailable': async () => {
    // Mock database to throw errors
    jest.spyOn(db, 'query').mockRejectedValue(new Error('DB unavailable'));
  }
};
```

---

## 5. Using a Pact Broker

A Pact Broker provides a central place to share contracts and track verification status.

### Setting Up Pact Broker with Docker

```yaml
# docker-compose.yml
version: '3'
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_USER: pact
      POSTGRES_PASSWORD: pact
      POSTGRES_DB: pact
    volumes:
      - pact-db:/var/lib/postgresql/data

  pact-broker:
    image: pactfoundation/pact-broker:latest
    depends_on:
      - postgres
    ports:
      - "9292:9292"
    environment:
      PACT_BROKER_DATABASE_URL: postgres://pact:pact@postgres/pact
      PACT_BROKER_BASIC_AUTH_USERNAME: admin
      PACT_BROKER_BASIC_AUTH_PASSWORD: admin
      PACT_BROKER_ALLOW_PUBLIC_READ: "true"
      PACT_BROKER_BASE_URL: http://localhost:9292

volumes:
  pact-db:
```

### Publishing Contracts to Broker

```javascript
// scripts/publish-pacts.js
const { Publisher } = require('@pact-foundation/pact');
const path = require('path');

async function publishPacts() {
  const publisher = new Publisher({
    pactBroker: process.env.PACT_BROKER_URL || 'http://localhost:9292',
    pactBrokerToken: process.env.PACT_BROKER_TOKEN,

    // Or use basic auth
    // pactBrokerUsername: process.env.PACT_BROKER_USERNAME,
    // pactBrokerPassword: process.env.PACT_BROKER_PASSWORD,

    pactFilesOrDirs: [path.resolve(__dirname, '../pacts')],
    consumerVersion: process.env.GIT_COMMIT || '1.0.0',
    branch: process.env.GIT_BRANCH || 'main',

    // Tag with environment for deployment tracking
    tags: [process.env.GIT_BRANCH || 'main']
  });

  await publisher.publishPacts();
  console.log('Pacts published successfully');
}

publishPacts().catch(console.error);
```

```bash
# Publish pacts after consumer tests pass
npm test && node scripts/publish-pacts.js
```

### Can-I-Deploy Check

Before deploying, verify your service is compatible with all dependencies:

```bash
# Check if OrderService can be deployed to production
pact-broker can-i-deploy \
  --pacticipant OrderService \
  --version $(git rev-parse HEAD) \
  --to-environment production \
  --broker-base-url https://your-broker.pactflow.io \
  --broker-token $PACT_BROKER_TOKEN
```

---

## 6. CI/CD Integration

### GitHub Actions Workflow

```yaml
# .github/workflows/contract-tests.yml
name: Contract Tests

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  PACT_BROKER_URL: ${{ secrets.PACT_BROKER_URL }}
  PACT_BROKER_TOKEN: ${{ secrets.PACT_BROKER_TOKEN }}

jobs:
  consumer-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run consumer contract tests
        run: npm run test:pact:consumer

      - name: Publish pacts to broker
        if: github.ref == 'refs/heads/main'
        run: |
          npm run pact:publish
        env:
          GIT_COMMIT: ${{ github.sha }}
          GIT_BRANCH: ${{ github.ref_name }}

  provider-verification:
    runs-on: ubuntu-latest
    needs: consumer-tests
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm ci

      - name: Start provider service
        run: npm start &
        env:
          NODE_ENV: test

      - name: Wait for service
        run: npx wait-on http://localhost:3001/health

      - name: Verify provider contracts
        run: npm run test:pact:provider
        env:
          GIT_COMMIT: ${{ github.sha }}
          GIT_BRANCH: ${{ github.ref_name }}
          CI: true

  can-i-deploy:
    runs-on: ubuntu-latest
    needs: provider-verification
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Can I Deploy?
        uses: pactflow/actions/can-i-deploy@v1
        with:
          broker_url: ${{ secrets.PACT_BROKER_URL }}
          broker_token: ${{ secrets.PACT_BROKER_TOKEN }}
          application_name: OrderService
          version: ${{ github.sha }}
          to_environment: production
```

---

## 7. Advanced Pact Patterns

### Message Pact for Async Communication

```javascript
// Consumer side - testing message consumption
const { MessageConsumerPact, synchronousBodyHandler } = require('@pact-foundation/pact');

describe('Order Created Event Consumer', () => {
  const messagePact = new MessageConsumerPact({
    consumer: 'InventoryService',
    provider: 'OrderService',
    dir: path.resolve(process.cwd(), 'pacts')
  });

  it('handles order created events', () => {
    return messagePact
      .given('an order is created')
      .expectsToReceive('an order created event')
      .withContent({
        eventType: 'ORDER_CREATED',
        orderId: like('order-123'),
        items: eachLike({
          productId: like('product-456'),
          quantity: integer(2)
        }),
        timestamp: like('2024-01-15T10:30:00Z')
      })
      .withMetadata({
        'content-type': 'application/json'
      })
      .verify(synchronousBodyHandler(async (message) => {
        // Test your message handler
        const result = await handleOrderCreatedEvent(message);
        expect(result.success).toBe(true);
      }));
  });
});
```

### Bi-Directional Contract Testing

For existing OpenAPI specs, use bi-directional contract testing:

```javascript
// Verify provider against OpenAPI spec
const { Verifier } = require('@pact-foundation/pact');

const verifier = new Verifier({
  provider: 'UserService',
  providerBaseUrl: 'http://localhost:3001',

  // Use OpenAPI spec as the contract
  pactUrls: [],
  providerStatesSetupUrl: 'http://localhost:3001/_pact/provider-states',

  // Compare against OpenAPI
  enablePending: true,
  includeWipPactsSince: '2024-01-01'
});
```

---

## 8. Common Issues and Fixes

### Issue: Pact Mock Server Port Conflicts

```javascript
// Specify a unique port for each test suite
const provider = new PactV3({
  consumer: 'MyConsumer',
  provider: 'MyProvider',
  port: 0  // Let the OS assign an available port
});
```

### Issue: Provider States Not Being Called

```javascript
// Ensure state handler URL is configured on provider
const options = {
  stateHandlers: {
    // State handlers must match exactly what consumers define
    'a user with ID 123 exists': async () => {
      // Setup code
    }
  },
  // Or use a setup URL for external state management
  providerStatesSetupUrl: 'http://localhost:3001/_pact/setup'
};
```

### Issue: Matching Failures with Dynamic Data

```javascript
// Use flexible matchers for dynamic data
const response = {
  // Match any integer, not a specific value
  id: integer(),

  // Match any ISO date string
  createdAt: regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/, '2024-01-15T10:00:00Z'),

  // Match UUID format
  uuid: regex(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/),

  // Match any non-empty string
  name: like('placeholder'),

  // Match array with at least one element matching structure
  items: eachLike({ name: string(), price: decimal() })
};
```

---

## Key Takeaways

1. **Start with consumers** - They define what they need from providers
2. **Use a Pact Broker** - Central contract management is essential for teams
3. **Implement provider states** - They ensure the right test data exists
4. **Run can-i-deploy checks** - Prevent breaking changes from reaching production
5. **Use flexible matchers** - Avoid brittle tests that break on dynamic data
6. **Integrate into CI/CD** - Contract tests should run on every build
7. **Keep contracts focused** - Test the contract, not business logic

---

*Want to monitor your microservices and ensure they stay compatible in production? [OneUptime](https://oneuptime.com) provides comprehensive monitoring that complements your contract testing strategy.*
