# How to Use the quote Filter for Shell Escaping in Ansible

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: Ansible, Jinja2, Filters, Security, Shell

Description: Learn how to use the quote filter in Ansible to safely escape shell arguments and prevent command injection vulnerabilities.

---

If you run shell commands in Ansible using the `shell` or `command` module with variable data, you are exposed to command injection attacks and breakage from special characters unless you properly escape the inputs. The `quote` filter wraps a string with appropriate shell quoting so it is treated as a single, safe argument. This is one of the most important security-related filters in Ansible, yet it is often overlooked.

## The Problem Without quote

Consider this seemingly innocent task:

```yaml
# DANGEROUS - Do not do this without quoting
- name: Create a backup file
  ansible.builtin.shell: "cp /etc/myapp/config.yml /backup/{{ backup_name }}.yml"
```

If `backup_name` contains something like `foo; rm -rf /`, the resulting shell command becomes:

```bash
cp /etc/myapp/config.yml /backup/foo; rm -rf /.yml
```

That semicolon makes the shell execute `rm -rf /` as a separate command. This is a classic command injection vulnerability.

## The Solution: quote Filter

The `quote` filter escapes the variable so it is treated as a literal string:

```yaml
# SAFE - The variable is properly quoted
- name: Create a backup file
  ansible.builtin.shell: "cp /etc/myapp/config.yml /backup/{{ backup_name | quote }}.yml"
```

Now even if `backup_name` contains `foo; rm -rf /`, the resulting command is:

```bash
cp /etc/myapp/config.yml /backup/'foo; rm -rf /'.yml
```

The shell treats the entire value as a literal string, and no injection occurs.

## Basic Usage

```jinja2
{# Quote a simple string #}
{{ "hello world" | quote }}
{# Output: 'hello world' #}

{# Quote a string with special characters #}
{{ "it's a test" | quote }}
{# Output: "it's a test" #}

{# Quote a string with shell metacharacters #}
{{ "file; rm -rf /" | quote }}
{# Output: 'file; rm -rf /' #}
```

## When to Use quote

Use the `quote` filter whenever you pass variable data into `shell` or `command` module commands. Here are the common scenarios.

### File Operations with Variable Names

```yaml
# file_operations.yml - Safe file operations with variable names
- name: Copy configuration file with safe naming
  ansible.builtin.shell: >
    cp {{ src_path | quote }} {{ dest_path | quote }}
  vars:
    src_path: "/etc/myapp/config.yml"
    dest_path: "/backup/config-{{ ansible_date_time.iso8601 }}.yml"

- name: Archive log files
  ansible.builtin.shell: >
    tar czf {{ archive_path | quote }} {{ log_dir | quote }}
  vars:
    archive_path: "/backup/logs-{{ inventory_hostname }}.tar.gz"
    log_dir: "/var/log/myapp"
```

### Passing User Input to Commands

```yaml
# user_input.yml - Safely handle user-provided values
- name: Search logs for a specific pattern
  ansible.builtin.shell: >
    grep -r {{ search_pattern | quote }} {{ log_directory | quote }}
  register: search_results
  failed_when: false
  changed_when: false

- name: Create database with user-specified name
  ansible.builtin.shell: >
    createdb {{ db_name | quote }}
  become: true
  become_user: postgres
```

### Building Complex Commands

```yaml
# complex_commands.yml - Complex shell commands with proper quoting
- name: Run database migration with environment variables
  ansible.builtin.shell: >
    DATABASE_URL={{ database_url | quote }}
    MIGRATION_TABLE={{ migration_table | quote }}
    /opt/myapp/bin/migrate up
  args:
    chdir: /opt/myapp

- name: Execute remote script with arguments
  ansible.builtin.shell: >
    /usr/local/bin/deploy.sh
    --app-name {{ app_name | quote }}
    --version {{ app_version | quote }}
    --environment {{ deploy_env | quote }}
    --config-file {{ config_path | quote }}
```

## Practical Example: Backup Script Generation

Here is a template that generates a backup script with properly quoted paths:

```yaml
# backup_setup.yml - Generate a safe backup script
- name: Generate backup script
  hosts: all
  vars:
    backup_config:
      base_dir: "/backup/{{ inventory_hostname }}"
      retention_days: 30
      targets:
        - name: "Application Config"
          source: "/etc/myapp"
        - name: "Database Dumps"
          source: "/var/lib/postgresql/dumps"
        - name: "SSL Certificates"
          source: "/etc/ssl/private"
  tasks:
    - name: Create backup script
      ansible.builtin.template:
        src: backup.sh.j2
        dest: /usr/local/bin/backup.sh
        mode: "0750"
```

```jinja2
{# backup.sh.j2 - Backup script with quoted paths #}
#!/bin/bash
# Backup script - Generated by Ansible
# Do not edit manually

BACKUP_BASE={{ backup_config.base_dir | quote }}
DATE=$(date +%Y%m%d_%H%M%S)

echo "Starting backup at $(date)"

# Create backup directory
mkdir -p "${BACKUP_BASE}/${DATE}"

{% for target in backup_config.targets %}
# Backup: {{ target.name }}
echo "Backing up {{ target.name }}..."
if [ -d {{ target.source | quote }} ]; then
    tar czf "${BACKUP_BASE}/${DATE}/{{ target.name | regex_replace('[^a-zA-Z0-9]', '_') | lower }}.tar.gz" \
        -C {{ (target.source | dirname) | quote }} \
        {{ (target.source | basename) | quote }}
    echo "  Done."
else
    echo "  WARNING: Source directory {{ target.source | quote }} does not exist!"
fi

{% endfor %}

# Clean up old backups
echo "Cleaning up backups older than {{ backup_config.retention_days }} days..."
find "${BACKUP_BASE}" -type d -mtime +{{ backup_config.retention_days }} -exec rm -rf {} + 2>/dev/null

echo "Backup completed at $(date)"
```

## Using quote with Loops

```yaml
# loop_commands.yml - Safely run commands in loops
- name: Stop specific services
  ansible.builtin.shell: >
    systemctl stop {{ item | quote }}
  loop: "{{ services_to_stop }}"
  vars:
    services_to_stop:
      - "myapp.service"
      - "myapp-worker.service"
      - "myapp-scheduler.service"

- name: Remove old package versions
  ansible.builtin.shell: >
    apt-get remove -y {{ item | quote }}
  loop: "{{ packages_to_remove }}"
  become: true
```

## quote vs the command Module

The `command` module does not use a shell, so it does not interpret shell metacharacters. This makes it inherently safer than `shell`:

```yaml
# command_vs_shell.yml - Understanding when quote is needed

# The command module does NOT need quote - it doesn't use a shell
- name: Safe without quote (command module)
  ansible.builtin.command: "cp {{ src_file }} {{ dest_file }}"

# The shell module DOES need quote - it uses a shell
- name: Needs quote (shell module)
  ansible.builtin.shell: "cp {{ src_file | quote }} {{ dest_file | quote }}"
```

However, even with the `command` module, `quote` does not hurt and can serve as documentation that you have considered the security implications.

## Quoting in Template-Generated Scripts

When generating shell scripts with Ansible templates, use `quote` for any variable that could contain special characters:

```jinja2
{# deploy.sh.j2 - Deployment script with safe quoting #}
#!/bin/bash
set -euo pipefail

APP_NAME={{ app_name | quote }}
APP_VERSION={{ app_version | quote }}
DEPLOY_DIR={{ deploy_directory | quote }}
CONFIG_FILE={{ config_file_path | quote }}

echo "Deploying ${APP_NAME} version ${APP_VERSION}"

# Stop current version
if systemctl is-active --quiet {{ (app_name ~ '.service') | quote }}; then
    systemctl stop {{ (app_name ~ '.service') | quote }}
fi

# Deploy new version
mkdir -p "${DEPLOY_DIR}"
tar xzf {{ artifact_path | quote }} -C "${DEPLOY_DIR}"

# Apply configuration
cp "${CONFIG_FILE}" "${DEPLOY_DIR}/config.yml"

# Start new version
systemctl start {{ (app_name ~ '.service') | quote }}

echo "Deployment of ${APP_NAME} ${APP_VERSION} complete"
```

## Quoting Inside Environment Variables

```yaml
# env_quoting.yml - Quote values in environment variable assignments
- name: Run command with complex environment
  ansible.builtin.shell: >
    APP_NAME={{ app_name | quote }}
    DATABASE_URL={{ database_url | quote }}
    SECRET_KEY={{ secret_key | quote }}
    /opt/myapp/bin/start
```

This is especially important when the values contain characters like `$`, backticks, or semicolons that the shell would interpret.

## What quote Actually Does

Under the hood, `quote` uses Python's `shlex.quote()` function. It wraps the string in single quotes and escapes any existing single quotes within the string:

```jinja2
{# How quote handles various inputs #}
{{ "simple" | quote }}
{# Output: simple (no quoting needed) #}

{{ "has spaces" | quote }}
{# Output: 'has spaces' #}

{{ "has'quote" | quote }}
{# Output: "has'quote" #}

{{ "has$dollar" | quote }}
{# Output: 'has$dollar' #}

{{ "has`backtick`" | quote }}
{# Output: 'has`backtick`' #}
```

## Common Mistakes

**Forgetting to quote paths with spaces:**

```yaml
# Wrong - breaks if path contains spaces
- name: Bad
  ansible.builtin.shell: "cat {{ config_path }}"

# Right - handles spaces safely
- name: Good
  ansible.builtin.shell: "cat {{ config_path | quote }}"
```

**Quoting entire commands instead of arguments:**

```yaml
# Wrong - quotes the whole command
- name: Bad
  ansible.builtin.shell: "{{ full_command | quote }}"

# Right - quote only the variable arguments
- name: Good
  ansible.builtin.shell: "/usr/bin/myapp --config {{ config_path | quote }}"
```

**Using quote when not using shell:**

```yaml
# Unnecessary but harmless with command module
- name: Redundant quoting
  ansible.builtin.command: "ls {{ path | quote }}"
```

## Wrapping Up

The `quote` filter is your primary defense against shell injection in Ansible. Use it every time you pass variable data to the `shell` module, in shell scripts generated by templates, and when building command lines with user-provided values. It costs nothing in performance and can save you from catastrophic security vulnerabilities. Make it a habit to quote every variable in every shell command, and your automation will be both safer and more robust.
