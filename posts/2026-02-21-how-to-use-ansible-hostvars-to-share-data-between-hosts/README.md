# How to Use Ansible hostvars to Share Data Between Hosts

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: Ansible, Variables, Infrastructure Automation, Configuration Management

Description: Learn how to use the Ansible hostvars magic variable to share and access data between different hosts during playbook execution.

---

When you run Ansible playbooks across multiple servers, you often need one host to know something about another. Maybe the application server needs to know the database server's IP address. Maybe the load balancer needs to know the ports each web server is listening on. This is where `hostvars` comes in.

The `hostvars` variable is one of Ansible's "magic variables" that gives you access to variables and facts from any host in the inventory, not just the one currently being processed. This makes cross-host communication straightforward without resorting to external data stores or hardcoded values.

## What is hostvars?

`hostvars` is a dictionary keyed by hostname. Each entry contains all the variables associated with that host, including gathered facts, inventory variables, and any variables that were set during the play. You access it like this:

```yaml
# Access the IP address of a specific host
{{ hostvars['db-server-01']['ansible_default_ipv4']['address'] }}
```

The key thing to understand is that `hostvars` only contains facts for a host if facts have already been gathered for that host. If you skip fact gathering for a host, its facts will not be available through `hostvars`.

## Basic hostvars Usage

Here is a simple inventory with a web server and a database server.

```ini
# inventory/hosts.ini
[webservers]
web-01 ansible_host=192.168.1.10

[dbservers]
db-01 ansible_host=192.168.1.20

[dbservers:vars]
db_port=5432
db_name=myapp
```

Now, here is a playbook that configures the web server with the database server's connection details.

```yaml
# configure-webapp.yml
# This playbook gathers facts from all hosts first, then uses
# hostvars to pass the DB server info to the web server config.
---
- name: Gather facts from all hosts
  hosts: all
  gather_facts: yes
  tasks: []

- name: Configure web application
  hosts: webservers
  become: yes
  tasks:
    - name: Generate application config
      ansible.builtin.template:
        src: app-config.j2
        dest: /etc/myapp/config.yml
        owner: myapp
        group: myapp
        mode: '0640'
```

And the corresponding Jinja2 template that pulls data from the database host.

```jinja2
# templates/app-config.j2
# Application configuration file generated by Ansible
database:
  host: {{ hostvars['db-01']['ansible_default_ipv4']['address'] }}
  port: {{ hostvars['db-01']['db_port'] }}
  name: {{ hostvars['db-01']['db_name'] }}

app:
  listen_address: {{ ansible_default_ipv4.address }}
  listen_port: 8080
```

## Iterating Over Group Members with hostvars

A common pattern is building configuration that references every member of a group. For example, generating an HAProxy backend configuration that lists every web server.

```yaml
# configure-haproxy.yml
# Sets up HAProxy with backends discovered from hostvars
---
- name: Gather facts from all hosts
  hosts: all
  gather_facts: yes
  tasks: []

- name: Configure load balancer
  hosts: loadbalancers
  become: yes
  tasks:
    - name: Deploy HAProxy configuration
      ansible.builtin.template:
        src: haproxy.cfg.j2
        dest: /etc/haproxy/haproxy.cfg
        owner: root
        group: root
        mode: '0644'
      notify: restart haproxy

  handlers:
    - name: restart haproxy
      ansible.builtin.service:
        name: haproxy
        state: restarted
```

The template iterates over the webservers group using `groups` and `hostvars` together.

```jinja2
# templates/haproxy.cfg.j2
# HAProxy config - backends populated from Ansible inventory
frontend http_front
    bind *:80
    default_backend web_servers

backend web_servers
    balance roundrobin
{% for host in groups['webservers'] %}
    server {{ host }} {{ hostvars[host]['ansible_default_ipv4']['address'] }}:8080 check
{% endfor %}
```

If you have three web servers in your inventory, this generates three `server` lines automatically. Add or remove hosts from inventory and the config updates on the next run.

## Sharing Registered Variables via hostvars

When a task registers a variable on one host, you can access it from another host through `hostvars`. This is useful when you need the result of a command run on one host to make decisions on another.

```yaml
# cross-host-registered-vars.yml
# Demonstrates accessing a registered variable from another host
---
- name: Check database version
  hosts: dbservers
  tasks:
    - name: Get PostgreSQL version
      ansible.builtin.command: psql --version
      register: pg_version
      changed_when: false

- name: Configure application based on DB version
  hosts: webservers
  tasks:
    - name: Show the DB version from the other host
      ansible.builtin.debug:
        msg: >
          Database server is running:
          {{ hostvars['db-01']['pg_version']['stdout'] }}

    - name: Set connection pool size based on DB version
      ansible.builtin.set_fact:
        pool_size: "{{ 20 if '15' in hostvars['db-01']['pg_version']['stdout'] else 10 }}"

    - name: Display chosen pool size
      ansible.builtin.debug:
        msg: "Connection pool size set to {{ pool_size }}"
```

## Using hostvars with Dynamic Inventory

When you use dynamic inventory (like from AWS, GCP, or Azure), the hostnames in `hostvars` match whatever the dynamic inventory plugin names them. Usually this is the instance ID or a tag value.

```yaml
# dynamic-inventory-hostvars.yml
# Works with AWS EC2 dynamic inventory
---
- name: Gather facts from all EC2 instances
  hosts: all
  gather_facts: yes
  tasks: []

- name: Configure monitoring on app servers
  hosts: tag_Role_app
  tasks:
    - name: Build list of all monitoring targets
      ansible.builtin.set_fact:
        monitoring_targets: >-
          {{
            groups['tag_Role_app'] | map('extract', hostvars, ['ansible_default_ipv4', 'address']) | list
          }}

    - name: Show monitoring targets
      ansible.builtin.debug:
        var: monitoring_targets
```

The `extract` filter is a clean way to pull a specific nested value from hostvars for a list of hosts. It avoids the need for a loop in Jinja2.

## Common Pitfalls

**Facts not gathered yet.** The most frequent issue is trying to access `hostvars` for a host whose facts have not been gathered. If you see errors like "undefined variable," make sure you have a play that gathers facts from that host first.

```yaml
# Wrong - facts for dbservers not gathered in this play
- name: Configure webservers
  hosts: webservers
  tasks:
    - debug:
        msg: "{{ hostvars['db-01']['ansible_os_family'] }}"
        # This will fail if no previous play gathered facts for db-01
```

**Host not in inventory.** You can only access hostvars for hosts that exist in the inventory. Trying to reference a hostname that is not in the inventory results in an error.

**Serial execution.** When using `serial` to process hosts in batches, registered variables from hosts in later batches are not yet available to hosts in earlier batches.

## Practical Pattern: Service Discovery

Here is a real-world pattern for a microservices setup where each service needs to know about the others.

```yaml
# service-discovery.yml
# Builds a service registry from inventory hostvars
---
- name: Gather all service information
  hosts: all
  gather_facts: yes
  tasks:
    - name: Set service metadata
      ansible.builtin.set_fact:
        service_port: "{{ service_port | default(8080) }}"
        service_health_path: "{{ service_health_path | default('/health') }}"

- name: Deploy service registry config to all hosts
  hosts: all
  tasks:
    - name: Generate service registry
      ansible.builtin.template:
        src: service-registry.json.j2
        dest: /etc/services/registry.json
        mode: '0644'
```

```jinja2
{# templates/service-registry.json.j2 #}
{# Generates a JSON service registry from inventory data #}
{
  "services": {
{% for group_name in groups if group_name not in ['all', 'ungrouped'] %}
    "{{ group_name }}": [
{% for host in groups[group_name] %}
      {
        "host": "{{ hostvars[host]['ansible_default_ipv4']['address'] }}",
        "port": {{ hostvars[host]['service_port'] }},
        "health": "{{ hostvars[host]['service_health_path'] }}"
      }{{ "," if not loop.last else "" }}
{% endfor %}
    ]{{ "," if not loop.last else "" }}
{% endfor %}
  }
}
```

## Summary

The `hostvars` magic variable is essential for any multi-host Ansible setup. It lets you reference variables and facts from any host in your inventory, enabling patterns like service discovery, load balancer configuration, and cross-host dependency management. The key rules are simple: make sure facts are gathered before you reference them, and make sure the host exists in your inventory. With those basics in place, `hostvars` becomes a powerful tool for building dynamic, interconnected infrastructure configurations.
