# How to Use Vault Dynamic Secrets

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: HashiCorp Vault, Dynamic Secrets, Security, Database, DevOps

Description: Learn how to use Vault dynamic secrets for databases, AWS, and other services with automatic credential rotation and TTLs.

---

Static credentials are a security nightmare. They get shared, copied to configuration files, committed to repositories, and rarely rotated. HashiCorp Vault's dynamic secrets solve this problem by generating credentials on-demand with automatic expiration. In this guide, you will learn how to set up and use dynamic secrets for databases and cloud providers.

## What Are Dynamic Secrets?

Dynamic secrets are credentials generated by Vault when an application requests them. Unlike static secrets that live forever until manually rotated, dynamic secrets have a built-in TTL (time-to-live) and are automatically revoked when they expire.

```mermaid
sequenceDiagram
    participant App as Application
    participant Vault as HashiCorp Vault
    participant DB as Database

    App->>Vault: Request database credentials
    Vault->>DB: CREATE USER with permissions
    DB-->>Vault: User created
    Vault-->>App: Return username/password (TTL: 1h)
    Note over App: App uses credentials
    Note over Vault: After TTL expires
    Vault->>DB: DROP USER
    DB-->>Vault: User removed
```

## Setting Up Vault

First, let's start Vault in development mode for testing. In production, you would use a proper storage backend and TLS.

```bash
# Start Vault in dev mode (for testing only)
vault server -dev -dev-root-token-id="root"

# In another terminal, set the address and token
export VAULT_ADDR='http://127.0.0.1:8200'
export VAULT_TOKEN='root'

# Verify Vault is running
vault status
```

## Database Dynamic Secrets

The database secrets engine is one of the most commonly used dynamic secrets features. Let's configure it for PostgreSQL.

### Enable the Database Secrets Engine

```bash
# Enable the database secrets engine at the default path
vault secrets enable database
```

### Configure the Database Connection

```bash
# Configure Vault to connect to PostgreSQL
# The connection_url uses Go template syntax for credentials
vault write database/config/my-postgresql-database \
    plugin_name=postgresql-database-plugin \
    allowed_roles="readonly","readwrite" \
    connection_url="postgresql://{{username}}:{{password}}@localhost:5432/myapp?sslmode=disable" \
    username="vault_admin" \
    password="vault_admin_password"
```

### Create Database Roles

Roles define what permissions the generated credentials will have.

```bash
# Create a read-only role
# This SQL statement runs when Vault creates new credentials
vault write database/roles/readonly \
    db_name=my-postgresql-database \
    creation_statements="CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}'; \
        GRANT SELECT ON ALL TABLES IN SCHEMA public TO \"{{name}}\";" \
    default_ttl="1h" \
    max_ttl="24h"

# Create a read-write role with more permissions
vault write database/roles/readwrite \
    db_name=my-postgresql-database \
    creation_statements="CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}'; \
        GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO \"{{name}}\";" \
    default_ttl="1h" \
    max_ttl="24h"
```

### Generate Dynamic Credentials

```bash
# Request new database credentials
vault read database/creds/readonly

# Output will look like:
# Key                Value
# ---                -----
# lease_id           database/creds/readonly/abcd1234
# lease_duration     1h
# lease_renewable    true
# password           A1a-aBcDeFgHiJkLmNoP
# username           v-token-readonly-abcd1234
```

### Using Dynamic Secrets in Applications

Here's a Python example that fetches database credentials from Vault:

```python
import hvac
import psycopg2
from contextlib import contextmanager

class VaultDatabaseManager:
    """
    Manages database connections using Vault dynamic secrets.
    Automatically fetches new credentials and handles renewal.
    """

    def __init__(self, vault_addr, vault_token, db_host, db_name):
        # Initialize the Vault client
        self.client = hvac.Client(url=vault_addr, token=vault_token)
        self.db_host = db_host
        self.db_name = db_name
        self.lease_id = None

    def get_credentials(self, role="readonly"):
        """
        Fetch dynamic credentials from Vault.
        Returns a tuple of (username, password).
        """
        # Request new credentials from the database secrets engine
        response = self.client.secrets.database.generate_credentials(
            name=role,
            mount_point="database"
        )

        # Store the lease_id for potential renewal or revocation
        self.lease_id = response["lease_id"]

        # Extract and return the credentials
        return (
            response["data"]["username"],
            response["data"]["password"]
        )

    def revoke_credentials(self):
        """
        Explicitly revoke credentials before TTL expires.
        Good practice when your application shuts down.
        """
        if self.lease_id:
            self.client.sys.revoke_lease(self.lease_id)
            self.lease_id = None

    @contextmanager
    def get_connection(self, role="readonly"):
        """
        Context manager that provides a database connection
        with automatic credential cleanup.
        """
        username, password = self.get_credentials(role)

        # Create the database connection with dynamic credentials
        conn = psycopg2.connect(
            host=self.db_host,
            database=self.db_name,
            user=username,
            password=password
        )

        try:
            yield conn
        finally:
            # Always close the connection
            conn.close()
            # Revoke credentials immediately after use
            self.revoke_credentials()


# Example usage
if __name__ == "__main__":
    manager = VaultDatabaseManager(
        vault_addr="http://127.0.0.1:8200",
        vault_token="your-vault-token",
        db_host="localhost",
        db_name="myapp"
    )

    # Use the context manager for automatic cleanup
    with manager.get_connection("readonly") as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM users LIMIT 10")
        results = cursor.fetchall()
        print(results)
```

## AWS Dynamic Secrets

Vault can also generate dynamic AWS credentials. This is useful for applications that need temporary access to AWS services.

```mermaid
flowchart LR
    A[Application] -->|1. Request AWS creds| B[Vault]
    B -->|2. AssumeRole or CreateAccessKey| C[AWS IAM]
    C -->|3. Temporary credentials| B
    B -->|4. Return credentials| A
    A -->|5. Use credentials| D[AWS Services]

    style B fill:#7B42BC,color:#fff
    style C fill:#FF9900,color:#fff
```

### Enable and Configure AWS Secrets Engine

```bash
# Enable the AWS secrets engine
vault secrets enable aws

# Configure the root credentials that Vault uses to create IAM users
# These credentials need IAM permissions to create/delete users
vault write aws/config/root \
    access_key=AKIAIOSFODNN7EXAMPLE \
    secret_key=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY \
    region=us-east-1
```

### Create AWS Roles

You can create roles that either generate IAM users or use STS AssumeRole.

```bash
# Option 1: IAM User role (creates actual IAM users)
# Best for longer-running processes
vault write aws/roles/s3-readonly \
    credential_type=iam_user \
    policy_document=-<<EOF
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "s3:GetObject",
        "s3:ListBucket"
      ],
      "Resource": [
        "arn:aws:s3:::my-bucket",
        "arn:aws:s3:::my-bucket/*"
      ]
    }
  ]
}
EOF

# Option 2: Assumed Role (uses STS)
# Best for short-lived, frequent requests
vault write aws/roles/deploy-role \
    credential_type=assumed_role \
    role_arns=arn:aws:iam::123456789012:role/deploy-role \
    default_sts_ttl=1h \
    max_sts_ttl=4h
```

### Generate AWS Credentials

```bash
# Get credentials for the s3-readonly role
vault read aws/creds/s3-readonly

# Output:
# Key                Value
# ---                -----
# lease_id           aws/creds/s3-readonly/abcd1234
# lease_duration     768h
# lease_renewable    true
# access_key         AKIAIOSFODNN7EXAMPLE
# secret_key         wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
# security_token     <nil>
```

### Using AWS Dynamic Secrets in Applications

```python
import hvac
import boto3

class VaultAWSManager:
    """
    Manages AWS credentials using Vault dynamic secrets.
    Provides boto3 clients with automatic credential refresh.
    """

    def __init__(self, vault_addr, vault_token):
        self.client = hvac.Client(url=vault_addr, token=vault_token)
        self.lease_id = None

    def get_aws_credentials(self, role):
        """
        Fetch AWS credentials from Vault for the specified role.
        """
        response = self.client.secrets.aws.generate_credentials(
            name=role,
            mount_point="aws"
        )

        self.lease_id = response["lease_id"]

        return {
            "aws_access_key_id": response["data"]["access_key"],
            "aws_secret_access_key": response["data"]["secret_key"],
            # security_token is present for assumed_role credential type
            "aws_session_token": response["data"].get("security_token")
        }

    def get_s3_client(self, role="s3-readonly"):
        """
        Returns a boto3 S3 client configured with dynamic credentials.
        """
        creds = self.get_aws_credentials(role)

        return boto3.client(
            "s3",
            aws_access_key_id=creds["aws_access_key_id"],
            aws_secret_access_key=creds["aws_secret_access_key"],
            aws_session_token=creds["aws_session_token"]
        )

    def revoke_credentials(self):
        """Revoke the current lease."""
        if self.lease_id:
            self.client.sys.revoke_lease(self.lease_id)
            self.lease_id = None


# Example usage
if __name__ == "__main__":
    manager = VaultAWSManager(
        vault_addr="http://127.0.0.1:8200",
        vault_token="your-vault-token"
    )

    # Get an S3 client with dynamic credentials
    s3 = manager.get_s3_client("s3-readonly")

    # List objects in a bucket
    response = s3.list_objects_v2(Bucket="my-bucket", MaxKeys=10)
    for obj in response.get("Contents", []):
        print(f"Found: {obj['Key']}")

    # Clean up when done
    manager.revoke_credentials()
```

## Lease Management

Understanding lease management is important for production use of dynamic secrets.

```mermaid
stateDiagram-v2
    [*] --> Active: Credential Generated
    Active --> Active: Renew (within max_ttl)
    Active --> Expired: TTL expires
    Active --> Revoked: Manual revocation
    Expired --> [*]: Credential deleted
    Revoked --> [*]: Credential deleted
```

### Renewing Leases

If your application needs credentials longer than the default TTL, you can renew them:

```bash
# Renew a lease (extends the TTL)
vault lease renew database/creds/readonly/abcd1234

# Renew with a specific duration
vault lease renew -increment=2h database/creds/readonly/abcd1234
```

### Revoking Leases

When you are done with credentials, revoke them immediately:

```bash
# Revoke a specific lease
vault lease revoke database/creds/readonly/abcd1234

# Revoke all leases for a path (useful during incidents)
vault lease revoke -prefix database/creds/readonly
```

## Production Best Practices

### 1. Use AppRole Authentication

Never use root tokens in production. Use AppRole for application authentication:

```bash
# Enable AppRole auth method
vault auth enable approle

# Create a policy for your application
vault policy write myapp-policy -<<EOF
path "database/creds/readonly" {
  capabilities = ["read"]
}
path "aws/creds/s3-readonly" {
  capabilities = ["read"]
}
EOF

# Create an AppRole
vault write auth/approle/role/myapp \
    token_policies="myapp-policy" \
    token_ttl=1h \
    token_max_ttl=4h \
    secret_id_ttl=10m \
    secret_id_num_uses=1
```

### 2. Set Appropriate TTLs

Choose TTLs based on your use case:

```bash
# Short-lived for batch jobs (revoke when done)
vault write database/roles/batch-job \
    db_name=my-postgresql-database \
    creation_statements="..." \
    default_ttl="15m" \
    max_ttl="1h"

# Longer TTL for services with renewal
vault write database/roles/web-service \
    db_name=my-postgresql-database \
    creation_statements="..." \
    default_ttl="1h" \
    max_ttl="24h"
```

### 3. Monitor Lease Usage

Set up monitoring for lease counts and expirations:

```bash
# Check current lease counts
vault read sys/metrics | grep -i lease

# List all leases for a path
vault list sys/leases/lookup/database/creds/readonly
```

### 4. Handle Credential Expiration Gracefully

Your application should handle credential expiration:

```python
import hvac
import psycopg2
from psycopg2 import OperationalError
import time

class ResilientDatabaseClient:
    """
    Database client that handles credential expiration gracefully.
    Automatically refreshes credentials on authentication failures.
    """

    def __init__(self, vault_client, db_config):
        self.vault_client = vault_client
        self.db_config = db_config
        self.connection = None
        self.credentials = None
        self.lease_id = None

    def _get_fresh_credentials(self):
        """Fetch new credentials from Vault."""
        response = self.vault_client.secrets.database.generate_credentials(
            name="readonly"
        )
        self.lease_id = response["lease_id"]
        self.credentials = {
            "user": response["data"]["username"],
            "password": response["data"]["password"]
        }

    def _connect(self):
        """Establish database connection with current credentials."""
        if not self.credentials:
            self._get_fresh_credentials()

        self.connection = psycopg2.connect(
            host=self.db_config["host"],
            database=self.db_config["database"],
            user=self.credentials["user"],
            password=self.credentials["password"]
        )

    def execute_query(self, query, params=None, max_retries=2):
        """
        Execute a query with automatic credential refresh on auth failure.
        """
        for attempt in range(max_retries + 1):
            try:
                if not self.connection or self.connection.closed:
                    self._connect()

                cursor = self.connection.cursor()
                cursor.execute(query, params)
                return cursor.fetchall()

            except OperationalError as e:
                # Check if this is an authentication error
                if "authentication failed" in str(e).lower():
                    print(f"Auth failed, refreshing credentials (attempt {attempt + 1})")
                    # Get fresh credentials and retry
                    self._get_fresh_credentials()
                    self.connection = None

                    if attempt == max_retries:
                        raise
                else:
                    raise
```

## Summary

Dynamic secrets provide significant security improvements over static credentials:

- Credentials are unique per request, limiting blast radius if compromised
- Automatic expiration means no forgotten credentials lingering in systems
- Centralized audit logging shows exactly who accessed what and when
- Immediate revocation capability during security incidents

The initial setup requires more effort than storing static passwords, but the security benefits are worth it for any production system handling sensitive data.

## Further Reading

- [Vault Database Secrets Engine Documentation](https://developer.hashicorp.com/vault/docs/secrets/databases)
- [Vault AWS Secrets Engine Documentation](https://developer.hashicorp.com/vault/docs/secrets/aws)
- [Vault Production Hardening Guide](https://developer.hashicorp.com/vault/tutorials/operations/production-hardening)
