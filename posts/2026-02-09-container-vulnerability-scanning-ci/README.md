# How to Implement Container Image Vulnerability Scanning Gates in Kubernetes CI Pipelines

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: Kubernetes, Security, CI/CD, Container Scanning, DevSecOps

Description: Implement automated vulnerability scanning gates in Kubernetes CI pipelines to prevent insecure container images from reaching production environments with Trivy, Grype, and policy enforcement.

---

Container vulnerabilities pose significant security risks in production environments. Implementing vulnerability scanning gates in CI pipelines catches security issues before deployment, enforcing security standards automatically. This guide shows you how to integrate vulnerability scanning into Kubernetes CI pipelines with quality gates that prevent vulnerable images from progressing through your deployment pipeline.

## Understanding Vulnerability Scanning Gates

Security gates are automated checkpoints in CI/CD pipelines that block deployments based on security criteria. For container images, this means scanning for known vulnerabilities (CVEs), checking against security policies, and failing builds when critical issues are found. Gates should be fast, accurate, and provide actionable feedback to developers.

## Choosing a Vulnerability Scanner

Popular scanners include Trivy (comprehensive, fast), Grype (accurate, detailed), and Clair (database-centric). We will focus on Trivy for its speed and ease of integration:

```bash
# Install Trivy locally for testing
curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin

# Scan an image
trivy image nginx:latest

# Scan with severity filtering
trivy image --severity HIGH,CRITICAL nginx:latest

# Exit with error on vulnerabilities
trivy image --exit-code 1 --severity CRITICAL nginx:latest
```

## Integrating Trivy in GitHub Actions

Create a workflow with vulnerability scanning gates:

```yaml
name: Build and Scan
on: [push, pull_request]

jobs:
  build-and-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Build Docker image
        run: |
          docker build -t myapp:${{ github.sha }} .

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: myapp:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Generate human-readable report
        if: failure()
        run: |
          trivy image --format table myapp:${{ github.sha }}

      - name: Push image only if scan passes
        if: success()
        run: |
          docker tag myapp:${{ github.sha }} registry.example.com/myapp:${{ github.sha }}
          docker push registry.example.com/myapp:${{ github.sha }}
```

## Implementing Gates in GitLab CI

Configure vulnerability scanning in `.gitlab-ci.yml`:

```yaml
stages:
  - build
  - scan
  - deploy

variables:
  IMAGE_NAME: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA

build:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  script:
    - docker build -t $IMAGE_NAME .
    - docker push $IMAGE_NAME

container_scanning:
  stage: scan
  image: aquasec/trivy:latest
  variables:
    TRIVY_NO_PROGRESS: "true"
    TRIVY_CACHE_DIR: ".trivycache/"
  cache:
    paths:
      - .trivycache/
  script:
    # Scan and fail on CRITICAL vulnerabilities
    - trivy image --exit-code 0 --severity LOW,MEDIUM,HIGH $IMAGE_NAME
    - trivy image --exit-code 1 --severity CRITICAL $IMAGE_NAME
    # Generate reports
    - trivy image --format json --output scan-results.json $IMAGE_NAME
    - trivy image --format template --template "@contrib/gitlab.tpl" --output gl-container-scanning-report.json $IMAGE_NAME
  artifacts:
    reports:
      container_scanning: gl-container-scanning-report.json
    paths:
      - scan-results.json
  allow_failure: false

deploy:
  stage: deploy
  script:
    - kubectl set image deployment/myapp myapp=$IMAGE_NAME
  only:
    - main
  when: on_success
```

## Creating a Tekton Pipeline with Scanning Gates

Build a Tekton pipeline with integrated scanning:

```yaml
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: build-scan-deploy
spec:
  params:
    - name: image-url
      type: string
    - name: max-critical
      type: string
      default: "0"
    - name: max-high
      type: string
      default: "5"

  workspaces:
    - name: source-workspace

  tasks:
    - name: build-image
      taskRef:
        name: kaniko
      params:
        - name: IMAGE
          value: $(params.image-url)
      workspaces:
        - name: source
          workspace: source-workspace

    - name: scan-image
      runAfter: [build-image]
      taskRef:
        name: trivy-scanner
      params:
        - name: IMAGE
          value: $(params.image-url)
        - name: MAX_CRITICAL
          value: $(params.max-critical)
        - name: MAX_HIGH
          value: $(params.max-high)

    - name: deploy-to-dev
      runAfter: [scan-image]
      taskRef:
        name: kubectl-deploy
      params:
        - name: IMAGE
          value: $(params.image-url)
        - name: NAMESPACE
          value: development
```

Create the Trivy scanner task:

```yaml
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: trivy-scanner
spec:
  params:
    - name: IMAGE
      description: Image to scan
    - name: MAX_CRITICAL
      description: Maximum allowed critical vulnerabilities
      default: "0"
    - name: MAX_HIGH
      description: Maximum allowed high vulnerabilities
      default: "5"

  results:
    - name: SCAN_PASSED
      description: Whether scan passed quality gate

  steps:
    - name: scan
      image: aquasec/trivy:latest
      script: |
        #!/bin/sh
        set -e

        # Perform scan and save results
        trivy image --format json --output /tmp/scan.json $(params.IMAGE)

        # Extract vulnerability counts
        CRITICAL=$(jq '[.Results[].Vulnerabilities[]? | select(.Severity=="CRITICAL")] | length' /tmp/scan.json)
        HIGH=$(jq '[.Results[].Vulnerabilities[]? | select(.Severity=="HIGH")] | length' /tmp/scan.json)

        echo "Found $CRITICAL critical and $HIGH high severity vulnerabilities"

        # Check against thresholds
        if [ "$CRITICAL" -gt "$(params.MAX_CRITICAL)" ]; then
          echo "FAIL: $CRITICAL critical vulnerabilities exceed threshold of $(params.MAX_CRITICAL)"
          trivy image --severity CRITICAL $(params.IMAGE)
          exit 1
        fi

        if [ "$HIGH" -gt "$(params.MAX_HIGH)" ]; then
          echo "FAIL: $HIGH high vulnerabilities exceed threshold of $(params.MAX_HIGH)"
          trivy image --severity HIGH,CRITICAL $(params.IMAGE)
          exit 1
        fi

        echo "PASS: Vulnerability scan passed quality gates"
        echo -n "true" > $(results.SCAN_PASSED.path)
```

## Implementing Policy-Based Scanning

Create custom policies using Open Policy Agent (OPA):

```yaml
# vulnerability-policy.rego
package trivy

deny[msg] {
  input.Results[_].Vulnerabilities[_].Severity == "CRITICAL"
  msg = "Critical vulnerabilities are not allowed"
}

deny[msg] {
  vuln := input.Results[_].Vulnerabilities[_]
  vuln.Severity == "HIGH"
  not has_fix_available(vuln)
  msg = sprintf("HIGH severity vulnerability without fix: %s", [vuln.VulnerabilityID])
}

has_fix_available(vuln) {
  vuln.FixedVersion != ""
}

deny[msg] {
  count([v | v := input.Results[_].Vulnerabilities[_]; v.Severity == "HIGH"]) > 10
  msg = "Too many HIGH severity vulnerabilities (max 10)"
}
```

Use the policy in your scan:

```bash
# Scan with OPA policy
trivy image --format json myapp:latest | \
  opa eval --data vulnerability-policy.rego --input - "data.trivy.deny"

# Exit with error if policy violations found
trivy image --format json myapp:latest | \
  opa eval --fail-defined --data vulnerability-policy.rego --input - "data.trivy.deny"
```

## Scanning with Grype for Enhanced Accuracy

Integrate Grype for cross-verification:

```yaml
# GitHub Actions with Grype
- name: Scan with Grype
  uses: anchore/scan-action@v3
  with:
    image: myapp:${{ github.sha }}
    fail-build: true
    severity-cutoff: high
    output-format: sarif

- name: Compare Trivy and Grype results
  run: |
    # Scan with both tools
    trivy image --format json -o trivy.json myapp:${{ github.sha }}
    grype myapp:${{ github.sha }} -o json > grype.json

    # Extract common vulnerabilities
    jq -r '.Results[].Vulnerabilities[].VulnerabilityID' trivy.json | sort > trivy-cves.txt
    jq -r '.matches[].vulnerability.id' grype.json | sort > grype-cves.txt

    # Find discrepancies
    comm -3 trivy-cves.txt grype-cves.txt > differences.txt

    if [ -s differences.txt ]; then
      echo "Scanners found different vulnerabilities - manual review required"
    fi
```

## Creating a Centralized Scanning Service

Deploy a scanning service in Kubernetes:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: vulnerability-scanner
  namespace: cicd
spec:
  replicas: 2
  selector:
    matchLabels:
      app: scanner
  template:
    metadata:
      labels:
        app: scanner
    spec:
      containers:
        - name: scanner
          image: aquasec/trivy:latest
          command: ["trivy"]
          args: ["server", "--listen", "0.0.0.0:8080"]
          ports:
            - containerPort: 8080
          resources:
            requests:
              memory: "512Mi"
              cpu: "500m"
            limits:
              memory: "2Gi"
              cpu: "2"
          volumeMounts:
            - name: cache
              mountPath: /root/.cache
      volumes:
        - name: cache
          emptyDir: {}

---
apiVersion: v1
kind: Service
metadata:
  name: vulnerability-scanner
  namespace: cicd
spec:
  selector:
    app: scanner
  ports:
    - port: 8080
      targetPort: 8080
```

Use the centralized scanner in pipelines:

```bash
# Scan using remote server
trivy image --server http://vulnerability-scanner.cicd.svc.cluster.local:8080 myapp:latest
```

## Implementing Continuous Monitoring

Scan deployed images regularly:

```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: deployed-image-scanner
  namespace: security
spec:
  schedule: "0 2 * * *"
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: scanner
          containers:
            - name: scanner
              image: aquasec/trivy:latest
              command:
                - /bin/sh
                - -c
                - |
                  # Get all images from deployments
                  kubectl get deployments --all-namespaces -o json | \
                    jq -r '.items[].spec.template.spec.containers[].image' | \
                    sort -u > /tmp/images.txt

                  # Scan each image
                  while read image; do
                    echo "Scanning $image"
                    trivy image --severity HIGH,CRITICAL --format json "$image" >> /tmp/results.json
                  done < /tmp/images.txt

                  # Send results to monitoring system
                  curl -X POST http://monitoring-service/api/scan-results \
                    -H "Content-Type: application/json" \
                    -d @/tmp/results.json
          restartPolicy: OnFailure
```

## Adding Exception Handling

Implement allowlists for known false positives:

```yaml
# .trivyignore file
# Ignore specific CVEs with justification
CVE-2021-12345  # False positive - not applicable to our use case
CVE-2021-67890  # Accepted risk - no fix available, mitigation in place
```

Use in scan:

```bash
trivy image --ignorefile .trivyignore myapp:latest
```

Create a structured exception process:

```yaml
# exceptions.yaml
exceptions:
  - cve: CVE-2021-12345
    severity: HIGH
    justification: "Not exploitable in our configuration"
    approved_by: "security-team"
    expires: "2026-06-01"
  - cve: CVE-2021-67890
    severity: CRITICAL
    justification: "Fix requires major version upgrade, scheduled for Q2"
    approved_by: "ciso"
    expires: "2026-04-01"
```

## Conclusion

Implementing vulnerability scanning gates in Kubernetes CI pipelines prevents vulnerable container images from reaching production. By integrating scanners like Trivy and Grype, defining clear policies, and automating enforcement, you create a robust security layer that catches issues early. Combined with continuous monitoring and proper exception handling, this approach significantly reduces security risk while maintaining development velocity. Security becomes an automated checkpoint rather than a manual bottleneck, enabling true DevSecOps practices.
