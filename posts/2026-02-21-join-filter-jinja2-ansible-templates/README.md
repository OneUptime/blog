# How to Use the join Filter in Jinja2 Ansible Templates

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: Ansible, Jinja2, Filters, Templates

Description: Learn how to use the Jinja2 join filter in Ansible templates to concatenate list elements into strings with custom separators.

---

When you are building configuration files with Ansible templates, you frequently need to turn a list of items into a single string. Maybe you need a comma-separated list of IP addresses for an `allow` directive, a colon-separated PATH variable, or a space-separated list of package names. The `join` filter in Jinja2 does exactly this, and it is one of those filters you will reach for constantly once you know it.

## Basic Syntax

The `join` filter takes a list and concatenates its elements into a single string, with an optional separator between each element:

```jinja2
{# Join a list with a comma separator #}
{{ ["apple", "banana", "cherry"] | join(", ") }}
{# Output: apple, banana, cherry #}
```

If you do not specify a separator, the elements are joined with no separator at all:

```jinja2
{# Join without a separator #}
{{ ["a", "b", "c"] | join }}
{# Output: abc #}
```

## Using join with Ansible Variables

In practice, your lists come from playbook variables, inventory, or gathered facts. Here is a basic example:

```yaml
# playbook.yml - Using join filter with variables
- name: Configure allowed hosts
  hosts: web_servers
  vars:
    allowed_ips:
      - "10.0.1.10"
      - "10.0.1.11"
      - "10.0.1.12"
      - "192.168.1.0/24"
  tasks:
    - name: Render firewall config
      ansible.builtin.template:
        src: firewall.conf.j2
        dest: /etc/firewall/rules.conf
```

```jinja2
{# firewall.conf.j2 - Join IPs into an allow list #}
# Allowed source addresses
allow_from = {{ allowed_ips | join(", ") }}
# Output: allow_from = 10.0.1.10, 10.0.1.11, 10.0.1.12, 192.168.1.0/24
```

## Practical Example: Generating /etc/resolv.conf

A classic use case is generating `/etc/resolv.conf` where you need nameserver entries and a search domain list:

```yaml
# dns_config.yml - Configure DNS resolution
- name: Configure DNS
  hosts: all
  vars:
    dns_nameservers:
      - "8.8.8.8"
      - "8.8.4.4"
      - "1.1.1.1"
    dns_search_domains:
      - "internal.example.com"
      - "example.com"
  tasks:
    - name: Render resolv.conf
      ansible.builtin.template:
        src: resolv.conf.j2
        dest: /etc/resolv.conf
```

```jinja2
{# resolv.conf.j2 - Use join for the search line #}
# Generated by Ansible
search {{ dns_search_domains | join(' ') }}
{% for ns in dns_nameservers %}
nameserver {{ ns }}
{% endfor %}
```

The rendered output:

```
# Generated by Ansible
search internal.example.com example.com
nameserver 8.8.8.8
nameserver 8.8.4.4
nameserver 1.1.1.1
```

The `search` directive needs all domains on one line separated by spaces, which is exactly what `join(' ')` gives us.

## Joining with Newlines

Sometimes you need each element on its own line. Use `join('\n')` for that:

```jinja2
{# Generate a hosts-style file with one entry per line #}
{{ host_entries | join('\n') }}
```

Or with a more specific line format:

```yaml
# vars
cron_jobs:
  - "0 * * * * /usr/local/bin/cleanup.sh"
  - "*/5 * * * * /usr/local/bin/health-check.sh"
  - "0 2 * * * /usr/local/bin/backup.sh"
```

```jinja2
{# crontab.j2 - One cron entry per line #}
# Managed by Ansible
{{ cron_jobs | join('\n') }}
```

## Combining join with Other Filters

The real power of `join` comes from combining it with other Jinja2 filters. Here are some common patterns.

### join with map

When you have a list of objects and want to join a specific attribute:

```yaml
# vars
users:
  - name: alice
    uid: 1001
  - name: bob
    uid: 1002
  - name: charlie
    uid: 1003
```

```jinja2
{# Extract names and join them #}
allowed_users = {{ users | map(attribute='name') | join(', ') }}
{# Output: allowed_users = alice, bob, charlie #}
```

### join with select

Filter items before joining:

```yaml
# vars
all_ports:
  - 80
  - 443
  - 8080
  - 3000
  - 9090
```

```jinja2
{# Join only ports greater than 1000 #}
high_ports = {{ all_ports | select('gt', 1000) | join(', ') }}
{# Output: high_ports = 8080, 3000, 9090 #}
```

### join with format strings

Build formatted strings before joining:

```yaml
# vars
backend_servers:
  - host: "10.0.1.10"
    port: 8080
  - host: "10.0.1.11"
    port: 8080
  - host: "10.0.1.12"
    port: 8081
```

```jinja2
{# Build server:port strings and join with commas #}
upstream_servers = {{ backend_servers | map('regex_replace', '(.*)', '') | join(', ') }}
```

Actually, for this pattern it is cleaner to use a loop inside a list comprehension:

```jinja2
{# Build host:port strings using a for loop with join #}
upstream_servers = {% for s in backend_servers %}{{ s.host }}:{{ s.port }}{% if not loop.last %}, {% endif %}{% endfor %}
```

But there is an even cleaner way using `map` with `format`:

```jinja2
{# Alternative: Format each entry and join #}
{% set server_strings = [] %}
{% for s in backend_servers %}
{%   set _ = server_strings.append(s.host ~ ":" ~ s.port) %}
{% endfor %}
upstream_servers = {{ server_strings | join(', ') }}
```

## Real-World Example: Environment File

Here is a practical example generating an environment file for a Docker container or systemd service:

```yaml
# deploy_app.yml - Generate environment configuration
- name: Deploy application
  hosts: app_servers
  vars:
    app_env:
      DATABASE_URL: "postgresql://db:5432/myapp"
      REDIS_URL: "redis://cache:6379/0"
      SECRET_KEY: "{{ vault_secret_key }}"
      LOG_LEVEL: "info"
      ALLOWED_HOSTS: "{{ allowed_hosts_list }}"
    allowed_hosts_list:
      - "app.example.com"
      - "www.example.com"
      - "api.example.com"
    java_opts:
      - "-Xms512m"
      - "-Xmx2048m"
      - "-XX:+UseG1GC"
      - "-XX:MaxGCPauseMillis=200"
  tasks:
    - name: Render environment file
      ansible.builtin.template:
        src: app.env.j2
        dest: /etc/myapp/app.env
```

```jinja2
{# app.env.j2 - Environment file with joined values #}
# Application Environment - Managed by Ansible
{% for key, value in app_env.items() %}
{% if value is string %}
{{ key }}={{ value }}
{% elif value is iterable %}
{{ key }}={{ value | join(',') }}
{% else %}
{{ key }}={{ value }}
{% endif %}
{% endfor %}

# JVM options joined with spaces
JAVA_OPTS={{ java_opts | join(' ') }}

# Allowed hosts as comma-separated list
ALLOWED_HOSTS={{ allowed_hosts_list | join(',') }}
```

The output:

```
# Application Environment - Managed by Ansible
DATABASE_URL=postgresql://db:5432/myapp
REDIS_URL=redis://cache:6379/0
SECRET_KEY=supersecretvalue
LOG_LEVEL=info
ALLOWED_HOSTS=app.example.com,www.example.com,api.example.com

# JVM options joined with spaces
JAVA_OPTS=-Xms512m -Xmx2048m -XX:+UseG1GC -XX:MaxGCPauseMillis=200

# Allowed hosts as comma-separated list
ALLOWED_HOSTS=app.example.com,www.example.com,api.example.com
```

## Joining Ansible Facts

You can use `join` with gathered facts too. For example, to list all IPv4 addresses on a host:

```jinja2
{# List all IP addresses on the host #}
# Host IPs: {{ ansible_all_ipv4_addresses | join(', ') }}
```

Or to build a PATH-like variable from a list:

```yaml
# vars
custom_paths:
  - "/usr/local/bin"
  - "/opt/myapp/bin"
  - "/opt/tools/bin"
```

```jinja2
{# Build a PATH variable with colon separators #}
export PATH={{ custom_paths | join(':') }}:$PATH
```

## Handling Empty Lists

When the list might be empty, combine `join` with `default`:

```jinja2
{# Safe join that handles undefined or empty lists #}
allowed_origins = {{ cors_origins | default([]) | join(', ') | default('*', true) }}
```

This first ensures `cors_origins` is at least an empty list, then joins it. If the result is an empty string (because the list was empty), the second `default('*', true)` provides a fallback.

## Using join in Playbook Tasks

The `join` filter is not limited to templates. You can use it in task parameters too:

```yaml
# Install a list of packages as a comma-separated string
- name: Install required packages
  ansible.builtin.apt:
    name: "{{ required_packages | join(',') }}"
    state: present
  vars:
    required_packages:
      - nginx
      - python3
      - postgresql-client

# Build a command with joined arguments
- name: Run application with flags
  ansible.builtin.command:
    cmd: "myapp {{ app_flags | join(' ') }}"
  vars:
    app_flags:
      - "--verbose"
      - "--config=/etc/myapp/config.yml"
      - "--workers=4"
```

## Wrapping Up

The `join` filter is a straightforward but essential tool for Ansible template development. It converts lists into delimited strings, which is exactly what you need for configuration files that expect comma-separated values, space-separated arguments, colon-separated paths, or similar formats. Combined with `map`, `select`, and `default`, it gives you flexible control over how list data gets rendered in your configuration files. Keep it in your toolkit alongside `default` as one of the filters you will use in nearly every Ansible project.
