# How to Use Amazon Inspector for EC2 Vulnerability Scanning

Author: [nawazdhandala](https://github.com/nawazdhandala)

Tags: AWS, Inspector, EC2, Security, Vulnerability Scanning

Description: Learn how to set up Amazon Inspector for automated vulnerability scanning of EC2 instances, including SSM agent configuration, finding management, and remediation workflows.

---

Unpatched vulnerabilities in EC2 instances are one of the most common attack vectors in cloud environments. You can have perfect network segmentation and airtight IAM policies, but if an instance is running software with a known CVE, attackers have a path in. Amazon Inspector v2 continuously scans your EC2 instances for software vulnerabilities and network reachability issues without installing any additional agents - it uses the SSM agent that's already on most instances.

This guide covers enabling Inspector for EC2, understanding findings, and building a practical remediation workflow.

## How Inspector EC2 Scanning Works

Inspector v2 (the current version) works differently from the original Inspector. There are no manual assessment runs or assessment templates. It scans continuously and automatically.

For EC2 instances, Inspector uses two data sources:

1. **SSM agent** - Collects software inventory from the instance (installed packages, OS version). This enables vulnerability scanning.
2. **VPC configuration** - Analyzes security groups, NACLs, and routing to identify network reachability issues.

The SSM-based scanning doesn't run vulnerability scanners on the instance itself. It collects the package list and compares it against vulnerability databases (NVD, vendor advisories) on the Inspector side. This means minimal performance impact on your instances.

## Enabling Inspector for EC2

Enabling Inspector is account-wide per region. Once enabled, it automatically discovers and starts scanning all eligible EC2 instances.

```bash
# Enable Inspector for EC2 scanning
aws inspector2 enable \
  --resource-types EC2

# Verify it's enabled
aws inspector2 batch-get-account-status \
  --query 'accounts[0].resourceState.ec2.status'
```

You can enable EC2 scanning alongside other resource types.

```bash
# Enable for EC2 and ECR simultaneously
aws inspector2 enable \
  --resource-types EC2 ECR
```

## SSM Agent Requirements

Inspector needs the SSM agent running on your instances to collect software inventory. Most modern AMIs include it by default, but you should verify.

```bash
# Check SSM agent status across your fleet
aws ssm describe-instance-information \
  --query 'InstanceInformationList[*].{InstanceId:InstanceId,PingStatus:PingStatus,AgentVersion:AgentVersion,Platform:PlatformType}' \
  --output table
```

If instances aren't showing up in SSM, they might need:

1. An IAM instance profile with the `AmazonSSMManagedInstanceCore` policy
2. Network connectivity to SSM endpoints (via NAT gateway or VPC endpoints)
3. The SSM agent installed and running

```bash
# Attach the SSM managed policy to an instance role
aws iam attach-role-policy \
  --role-name MyEC2Role \
  --policy-arn arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
```

For VPC endpoints (recommended for private instances):

```hcl
# VPC endpoints for SSM
resource "aws_vpc_endpoint" "ssm" {
  vpc_id             = var.vpc_id
  service_name       = "com.amazonaws.${data.aws_region.current.name}.ssm"
  vpc_endpoint_type  = "Interface"
  subnet_ids         = var.private_subnet_ids
  security_group_ids = [aws_security_group.vpc_endpoints.id]
  private_dns_enabled = true
}

resource "aws_vpc_endpoint" "ssmmessages" {
  vpc_id             = var.vpc_id
  service_name       = "com.amazonaws.${data.aws_region.current.name}.ssmmessages"
  vpc_endpoint_type  = "Interface"
  subnet_ids         = var.private_subnet_ids
  security_group_ids = [aws_security_group.vpc_endpoints.id]
  private_dns_enabled = true
}

resource "aws_vpc_endpoint" "ec2messages" {
  vpc_id             = var.vpc_id
  service_name       = "com.amazonaws.${data.aws_region.current.name}.ec2messages"
  vpc_endpoint_type  = "Interface"
  subnet_ids         = var.private_subnet_ids
  security_group_ids = [aws_security_group.vpc_endpoints.id]
  private_dns_enabled = true
}
```

## Terraform Setup

Here's a complete Terraform configuration for Inspector with EC2 scanning.

```hcl
# Enable Inspector
resource "aws_inspector2_enabler" "ec2" {
  account_ids    = [data.aws_caller_identity.current.account_id]
  resource_types = ["EC2"]
}

# Optional: Enable for all organization accounts
resource "aws_inspector2_organization_configuration" "main" {
  auto_enable {
    ec2    = true
    ecr    = true
    lambda = false
  }
}

# EventBridge rule for critical findings
resource "aws_cloudwatch_event_rule" "inspector_critical" {
  name = "inspector-critical-findings"

  event_pattern = jsonencode({
    source      = ["aws.inspector2"]
    detail-type = ["Inspector2 Finding"]
    detail = {
      severity = ["CRITICAL", "HIGH"]
      status   = ["ACTIVE"]
    }
  })
}

resource "aws_cloudwatch_event_target" "inspector_alert" {
  rule = aws_cloudwatch_event_rule.inspector_critical.name
  arn  = aws_sns_topic.security_alerts.arn
}
```

## Viewing and Filtering Findings

Inspector generates findings for each vulnerability it detects. Findings include the CVE ID, severity, affected packages, and remediation guidance.

```bash
# List all active EC2 findings sorted by severity
aws inspector2 list-findings \
  --filter-criteria '{
    "findingStatus": [{"comparison": "EQUALS", "value": "ACTIVE"}],
    "findingType": [{"comparison": "EQUALS", "value": "PACKAGE_VULNERABILITY"}],
    "resourceType": [{"comparison": "EQUALS", "value": "AWS_EC2_INSTANCE"}]
  }' \
  --sort-criteria '{"field": "SEVERITY", "sortOrder": "DESC"}' \
  --max-results 20
```

For a specific instance:

```bash
# Get findings for a specific instance
aws inspector2 list-findings \
  --filter-criteria '{
    "resourceId": [{"comparison": "EQUALS", "value": "i-0123456789abcdef0"}],
    "findingStatus": [{"comparison": "EQUALS", "value": "ACTIVE"}]
  }'
```

Get a summary of findings across your fleet:

```bash
# Finding counts by severity
aws inspector2 list-finding-aggregations \
  --aggregation-type SEVERITY \
  --query 'responses[*].{Severity:severityCounts}'
```

## Understanding Finding Details

Each finding provides actionable information. Here's what to look at.

```bash
# Get detailed finding info
aws inspector2 list-findings \
  --filter-criteria '{
    "findingStatus": [{"comparison": "EQUALS", "value": "ACTIVE"}],
    "severity": [{"comparison": "EQUALS", "value": "CRITICAL"}]
  }' \
  --max-results 1 | jq '.findings[0] | {
    title: .title,
    severity: .severity,
    instanceId: .resources[0].id,
    vulnerablePackage: .packageVulnerabilityDetails.vulnerablePackages[0],
    fixAvailable: .fixAvailable,
    remediation: .remediation.recommendation.text,
    cvss: .packageVulnerabilityDetails.cvss[0]
  }'
```

The `fixAvailable` field is particularly useful. If it says "YES", there's a patched version of the package available. If "NO", you might need to use compensating controls until a fix is released.

## Building a Remediation Workflow

For automated patching, combine Inspector findings with SSM Patch Manager.

```bash
# Create a patch baseline for critical security patches
aws ssm create-patch-baseline \
  --name "critical-security-patches" \
  --operating-system "AMAZON_LINUX_2" \
  --approval-rules '{
    "PatchRules": [
      {
        "PatchFilterGroup": {
          "PatchFilters": [
            {"Key": "CLASSIFICATION", "Values": ["Security"]},
            {"Key": "SEVERITY", "Values": ["Critical", "Important"]}
          ]
        },
        "ApproveAfterDays": 0,
        "ComplianceLevel": "CRITICAL"
      }
    ]
  }'

# Run patching on instances with critical vulnerabilities
aws ssm send-command \
  --document-name "AWS-RunPatchBaseline" \
  --parameters '{"Operation": ["Install"]}' \
  --targets '[{"Key": "tag:PatchGroup", "Values": ["production"]}]' \
  --comment "Remediate Inspector critical findings"
```

For a more automated approach, use a Lambda function that responds to Inspector findings.

```python
import boto3
import json

ssm = boto3.client('ssm')
inspector = boto3.client('inspector2')


def lambda_handler(event, context):
    """Auto-remediate Inspector findings by triggering patching."""
    detail = event['detail']

    severity = detail['severity']
    instance_id = detail['resources'][0]['id']
    fix_available = detail.get('fixAvailable', 'NO')

    if severity not in ['CRITICAL', 'HIGH']:
        return {'action': 'skipped', 'reason': 'below threshold'}

    if fix_available != 'YES':
        print(f"No fix available for {instance_id}, alerting only")
        # Send alert instead
        return {'action': 'alert_only'}

    # Trigger patching via SSM
    response = ssm.send_command(
        InstanceIds=[instance_id],
        DocumentName='AWS-RunPatchBaseline',
        Parameters={'Operation': ['Install']},
        Comment=f'Auto-remediation for Inspector finding'
    )

    command_id = response['Command']['CommandId']
    print(f"Initiated patching on {instance_id}: {command_id}")

    return {
        'action': 'patch_initiated',
        'instance_id': instance_id,
        'command_id': command_id
    }
```

## Suppression Rules

Some findings might be acceptable risks or false positives. Use suppression rules to filter them out.

```bash
# Create a suppression rule for a known acceptable vulnerability
aws inspector2 create-filter \
  --name "suppress-known-acceptable" \
  --action SUPPRESS \
  --description "Suppress findings for internal-only services not affected by this CVE" \
  --filter-criteria '{
    "vulnerabilityId": [{"comparison": "EQUALS", "value": "CVE-2023-12345"}],
    "resourceTags": [{"comparison": "EQUALS", "key": "Environment", "value": "internal"}]
  }'
```

## Network Reachability Findings

Beyond software vulnerabilities, Inspector also checks network reachability. It analyzes your VPC configuration to identify instances that might be exposed.

```bash
# List network reachability findings
aws inspector2 list-findings \
  --filter-criteria '{
    "findingType": [{"comparison": "EQUALS", "value": "NETWORK_REACHABILITY"}],
    "findingStatus": [{"comparison": "EQUALS", "value": "ACTIVE"}]
  }'
```

These findings flag instances with security group rules allowing traffic from 0.0.0.0/0 on sensitive ports, or instances in public subnets with unnecessary internet access.

## Multi-Account Setup

For AWS Organizations, designate an Inspector delegated administrator.

```bash
# Designate delegated admin
aws inspector2 enable-delegated-admin-account \
  --delegated-admin-account-id "222233334444"

# Auto-enable for new member accounts
aws inspector2 update-organization-configuration \
  --auto-enable '{"ec2": true, "ecr": true}'
```

## Monitoring Coverage

Make sure Inspector is actually scanning all your instances.

```bash
# Check EC2 scanning coverage
aws inspector2 list-coverage \
  --filter-criteria '{
    "resourceType": [{"comparison": "EQUALS", "value": "AWS_EC2_INSTANCE"}]
  }' \
  --query 'coveredResources[*].{ResourceId:resourceId,Status:scanStatus.statusCode,Reason:scanStatus.reason}'
```

Instances with a status of `INACTIVE` aren't being scanned, usually because the SSM agent isn't reporting.

For container image scanning, see our guide on [Inspector for ECR image scanning](https://oneuptime.com/blog/post/2026-02-12-inspector-ecr-container-image-scanning/view).

## Wrapping Up

Inspector EC2 scanning is one of those things that should be on in every AWS account. It runs continuously, requires no agents beyond SSM, and gives you a clear picture of your vulnerability landscape. Enable it, make sure SSM is working on all instances, set up alerts for critical findings, and build a patching workflow to close the loop. The goal isn't zero vulnerabilities - it's knowing what you have and remediating what matters within a reasonable timeframe.
