# How to Use Ansible to Manage Docker Compose Deployments

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: Ansible, Docker Compose, Deployment, Containers, DevOps

Description: Manage Docker Compose based deployments with Ansible for templated configurations, multi-environment support, and automated deployment workflows.

---

Docker Compose is the standard tool for defining multi-container applications. When you need to deploy Compose-based applications across multiple servers with environment-specific configurations, Ansible adds the orchestration layer that Docker Compose lacks. Ansible can template your compose files, manage environment variables, handle rolling updates, and ensure each deployment environment gets the right configuration.

## Why Ansible with Docker Compose?

Docker Compose alone works well for single-server deployments. But when you need to deploy the same application to staging, production, and multiple regions with different configurations for each, you need a way to manage that variation. Ansible's template engine and inventory system handle this perfectly.

## Basic Docker Compose Deployment

```yaml
# roles/compose_deploy/tasks/main.yml
# Deploy a Docker Compose application
- name: Ensure Docker and Docker Compose are installed
  ansible.builtin.package:
    name:
      - docker.io
      - docker-compose-plugin
    state: present

- name: Create application directory
  ansible.builtin.file:
    path: "{{ app_dir }}"
    state: directory
    mode: '0755'
    owner: "{{ deploy_user }}"

- name: Deploy Docker Compose file
  ansible.builtin.template:
    src: docker-compose.yml.j2
    dest: "{{ app_dir }}/docker-compose.yml"
    mode: '0644'
    owner: "{{ deploy_user }}"

- name: Deploy environment file
  ansible.builtin.template:
    src: env.j2
    dest: "{{ app_dir }}/.env"
    mode: '0600'
    owner: "{{ deploy_user }}"

- name: Pull latest images
  ansible.builtin.command:
    cmd: docker compose pull
    chdir: "{{ app_dir }}"
  changed_when: true

- name: Start application stack
  ansible.builtin.command:
    cmd: docker compose up -d --remove-orphans
    chdir: "{{ app_dir }}"
  changed_when: true

- name: Wait for application to be healthy
  ansible.builtin.uri:
    url: "http://127.0.0.1:{{ app_port }}/health"
    status_code: 200
  register: health
  until: health.status == 200
  retries: 30
  delay: 5
```

## Templated Docker Compose File

```yaml
# roles/compose_deploy/templates/docker-compose.yml.j2
# Docker Compose configuration generated by Ansible
services:
  web:
    image: {{ app_image }}:{{ app_version }}
    restart: unless-stopped
    ports:
      - "{{ app_port }}:8080"
    environment:
      - DATABASE_URL=postgresql://{{ db_user }}:{{ db_password }}@db:5432/{{ db_name }}
      - REDIS_URL=redis://redis:6379/0
      - LOG_LEVEL={{ log_level }}
      - SECRET_KEY={{ vault_app_secret_key }}
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    deploy:
      resources:
        limits:
          cpus: '{{ app_cpu_limit }}'
          memory: {{ app_memory_limit }}
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  db:
    image: postgres:{{ postgres_version }}
    restart: unless-stopped
    volumes:
      - postgres-data:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB={{ db_name }}
      - POSTGRES_USER={{ db_user }}
      - POSTGRES_PASSWORD={{ db_password }}
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U {{ db_user }}"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:{{ redis_version }}
    restart: unless-stopped
    volumes:
      - redis-data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

{% if monitoring_enabled %}
  prometheus:
    image: prom/prometheus:latest
    restart: unless-stopped
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml:ro
{% endif %}

volumes:
  postgres-data:
  redis-data:
```

## Environment-Specific Variables

```yaml
# inventories/production/group_vars/app_servers.yml
# Production deployment configuration
app_image: "registry.example.com/myapp"
app_version: "v2.1.0"
app_port: 8080
app_cpu_limit: "2.0"
app_memory_limit: "1g"
db_name: myapp_production
db_user: myapp
db_password: "{{ vault_db_password }}"
postgres_version: "16"
redis_version: "7-alpine"
log_level: "warn"
monitoring_enabled: true
deploy_user: deploy
app_dir: /opt/myapp
```

```yaml
# inventories/staging/group_vars/app_servers.yml
# Staging deployment configuration
app_image: "registry.example.com/myapp"
app_version: "latest"
app_port: 8080
app_cpu_limit: "0.5"
app_memory_limit: "512m"
db_name: myapp_staging
db_user: myapp
db_password: "{{ vault_db_password_staging }}"
postgres_version: "16"
redis_version: "7-alpine"
log_level: "debug"
monitoring_enabled: false
deploy_user: deploy
app_dir: /opt/myapp
```

## Zero-Downtime Updates

```yaml
# roles/compose_deploy/tasks/update.yml
# Update Docker Compose application with zero downtime
- name: Pull new images
  ansible.builtin.command:
    cmd: docker compose pull
    chdir: "{{ app_dir }}"
  changed_when: true

- name: Scale up new version
  ansible.builtin.command:
    cmd: docker compose up -d --no-deps --scale web=2 web
    chdir: "{{ app_dir }}"
  changed_when: true

- name: Wait for new container to be healthy
  ansible.builtin.pause:
    seconds: 30

- name: Scale back down
  ansible.builtin.command:
    cmd: docker compose up -d --no-deps --scale web=1 web
    chdir: "{{ app_dir }}"
  changed_when: true
```

## Backup Before Deploy

```yaml
# roles/compose_deploy/tasks/backup.yml
# Backup data before deployment
- name: Create backup directory
  ansible.builtin.file:
    path: "{{ backup_dir }}/{{ ansible_date_time.date }}"
    state: directory
    mode: '0755'

- name: Backup database
  ansible.builtin.command:
    cmd: >
      docker compose exec -T db
      pg_dump -U {{ db_user }} {{ db_name }}
    chdir: "{{ app_dir }}"
  register: db_dump
  changed_when: false

- name: Save database backup
  ansible.builtin.copy:
    content: "{{ db_dump.stdout }}"
    dest: "{{ backup_dir }}/{{ ansible_date_time.date }}/{{ db_name }}.sql"
    mode: '0600'
```

## Cleanup Tasks

```yaml
# roles/compose_deploy/tasks/cleanup.yml
# Clean up old Docker resources after deployment
- name: Remove unused images
  ansible.builtin.command:
    cmd: docker image prune -af --filter "until=168h"
  changed_when: true

- name: Remove unused volumes
  ansible.builtin.command:
    cmd: docker volume prune -f
  changed_when: true
  when: prune_volumes | default(false)
```


## Common Use Cases

Here are several practical scenarios where this module proves essential in real-world playbooks.

### Infrastructure Provisioning Workflow

```yaml
# Complete workflow incorporating this module
- name: Infrastructure provisioning
  hosts: all
  become: true
  gather_facts: true
  tasks:
    - name: Gather system information
      ansible.builtin.setup:
        gather_subset:
          - hardware
          - network

    - name: Display system summary
      ansible.builtin.debug:
        msg: >-
          Host {{ inventory_hostname }} has
          {{ ansible_memtotal_mb }}MB RAM,
          {{ ansible_processor_vcpus }} vCPUs,
          running {{ ansible_distribution }} {{ ansible_distribution_version }}

    - name: Install required packages
      ansible.builtin.package:
        name:
          - curl
          - wget
          - git
          - vim
          - htop
          - jq
        state: present

    - name: Configure system timezone
      ansible.builtin.timezone:
        name: "{{ system_timezone | default('UTC') }}"

    - name: Configure hostname
      ansible.builtin.hostname:
        name: "{{ inventory_hostname }}"

    - name: Update /etc/hosts
      ansible.builtin.lineinfile:
        path: /etc/hosts
        regexp: '^127\.0\.1\.1'
        line: "127.0.1.1 {{ inventory_hostname }}"

    - name: Configure SSH hardening
      ansible.builtin.lineinfile:
        path: /etc/ssh/sshd_config
        regexp: "{{ item.regexp }}"
        line: "{{ item.line }}"
      loop:
        - { regexp: '^PermitRootLogin', line: 'PermitRootLogin no' }
        - { regexp: '^PasswordAuthentication', line: 'PasswordAuthentication no' }
      notify: restart sshd

    - name: Configure firewall rules
      community.general.ufw:
        rule: allow
        port: "{{ item }}"
        proto: tcp
      loop:
        - "22"
        - "80"
        - "443"

    - name: Enable firewall
      community.general.ufw:
        state: enabled
        policy: deny

  handlers:
    - name: restart sshd
      ansible.builtin.service:
        name: sshd
        state: restarted
```

### Integration with Monitoring

```yaml
# Using gathered facts to configure monitoring thresholds
- name: Configure monitoring based on system specs
  hosts: all
  become: true
  tasks:
    - name: Set monitoring thresholds based on hardware
      ansible.builtin.template:
        src: monitoring_config.yml.j2
        dest: /etc/monitoring/config.yml
      vars:
        memory_warning_threshold: "{{ (ansible_memtotal_mb * 0.8) | int }}"
        memory_critical_threshold: "{{ (ansible_memtotal_mb * 0.95) | int }}"
        cpu_warning_threshold: 80
        cpu_critical_threshold: 95

    - name: Register host with monitoring system
      ansible.builtin.uri:
        url: "https://monitoring.example.com/api/hosts"
        method: POST
        body_format: json
        body:
          hostname: "{{ inventory_hostname }}"
          ip_address: "{{ ansible_default_ipv4.address }}"
          os: "{{ ansible_distribution }}"
          memory_mb: "{{ ansible_memtotal_mb }}"
          cpus: "{{ ansible_processor_vcpus }}"
        headers:
          Authorization: "Bearer {{ monitoring_api_token }}"
        status_code: [200, 201, 409]
```

### Error Handling Patterns

```yaml
# Robust error handling with this module
- name: Robust task execution
  hosts: all
  tasks:
    - name: Attempt primary operation
      ansible.builtin.command: /opt/app/primary-task.sh
      register: primary_result
      failed_when: false

    - name: Handle primary failure with fallback
      ansible.builtin.command: /opt/app/fallback-task.sh
      when: primary_result.rc != 0
      register: fallback_result

    - name: Report final status
      ansible.builtin.debug:
        msg: >-
          Task completed via {{ 'primary' if primary_result.rc == 0 else 'fallback' }} path.
          Return code: {{ primary_result.rc if primary_result.rc == 0 else fallback_result.rc }}

    - name: Fail if both paths failed
      ansible.builtin.fail:
        msg: "Both primary and fallback operations failed"
      when:
        - primary_result.rc != 0
        - fallback_result is defined
        - fallback_result.rc != 0
```

### Scheduling and Automation

```yaml
# Set up scheduled compliance scans using cron
- name: Configure automated scans
  hosts: all
  become: true
  tasks:
    - name: Create scan script
      ansible.builtin.copy:
        dest: /opt/scripts/compliance_scan.sh
        mode: '0755'
        content: |
          #!/bin/bash
          cd /opt/ansible
          ansible-playbook playbooks/validate.yml -i inventory/ > /var/log/compliance_scan.log 2>&1
          EXIT_CODE=$?
          if [ $EXIT_CODE -ne 0 ]; then
            curl -X POST https://hooks.example.com/alert \
              -H "Content-Type: application/json" \
              -d "{\"text\":\"Compliance scan failed on $(hostname)\"}"
          fi
          exit $EXIT_CODE

    - name: Schedule weekly compliance scan
      ansible.builtin.cron:
        name: "Weekly compliance scan"
        minute: "0"
        hour: "3"
        weekday: "1"
        job: "/opt/scripts/compliance_scan.sh"
        user: ansible
```


## Conclusion

Docker Compose and Ansible complement each other perfectly. Compose defines your multi-container application, and Ansible handles the deployment orchestration, environment-specific configuration, and lifecycle management. By templating your compose files and managing environment variables through Ansible inventory, you get consistent deployments across all environments while keeping the simplicity of Docker Compose for local development.
