# How to Implement Automated Vulnerability Management with Container Analysis API

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: GCP, Container Analysis, Vulnerability Management, Artifact Registry, Security

Description: A hands-on guide to implementing automated vulnerability management for container images using Google Cloud Container Analysis API and Artifact Registry scanning.

---

Running containers in production without vulnerability scanning is like deploying code without tests - you might get away with it for a while, but eventually something will break badly. Container images pull in dozens or hundreds of dependencies, each of which could have known vulnerabilities. The Container Analysis API on Google Cloud gives you automated scanning that catches these vulnerabilities before they reach production.

This guide covers setting up a complete vulnerability management workflow, from automatic scanning to policy enforcement and remediation tracking.

## How Container Analysis Works

When you push an image to Artifact Registry, Container Analysis automatically scans it for known vulnerabilities by examining the OS packages and language-specific dependencies in the image layers. The results are stored as "occurrences" attached to the image, and you can query them via the API.

The scanning is not a one-time event. Container Analysis performs continuous monitoring, re-scanning existing images when new vulnerabilities are disclosed. This means an image that was clean yesterday might have a critical vulnerability today if a new CVE was published.

## Step 1: Enable Container Analysis

```bash
# Enable the required APIs
gcloud services enable containeranalysis.googleapis.com
gcloud services enable containerscanning.googleapis.com
gcloud services enable artifactregistry.googleapis.com

# Create an Artifact Registry repository if you do not have one
gcloud artifacts repositories create app-images \
  --repository-format=docker \
  --location=us-central1 \
  --description="Application container images"
```

## Step 2: Push an Image and View Scan Results

```bash
# Build and push a sample image
docker build -t us-central1-docker.pkg.dev/PROJECT_ID/app-images/my-app:v1.0 .
docker push us-central1-docker.pkg.dev/PROJECT_ID/app-images/my-app:v1.0

# Wait for the scan to complete (usually takes 1-5 minutes)
# Then check the vulnerability results
gcloud artifacts docker images describe \
  us-central1-docker.pkg.dev/PROJECT_ID/app-images/my-app:v1.0 \
  --show-package-vulnerability

# List vulnerabilities in a more readable format
gcloud artifacts docker images list-vulnerabilities \
  us-central1-docker.pkg.dev/PROJECT_ID/app-images/my-app:v1.0 \
  --format="table(vulnerability.shortDescription,vulnerability.severity,vulnerability.packageIssue[0].affectedPackage,vulnerability.packageIssue[0].fixAvailable)"
```

## Step 3: Build a Vulnerability Assessment Pipeline

Create an automated pipeline that evaluates scan results and makes deployment decisions.

```python
from google.cloud import containeranalysis_v1
from google.cloud import artifactregistry_v1
from grafeas.grafeas_v1 import types as grafeas_types

class VulnerabilityAssessor:
    """Evaluate container image vulnerabilities against policy."""

    def __init__(self, project_id):
        self.project_id = project_id
        self.client = containeranalysis_v1.ContainerAnalysisClient()
        self.grafeas = self.client.get_grafeas_client()

    def get_vulnerabilities(self, image_uri):
        """Retrieve all vulnerability occurrences for an image."""
        # Get the image digest for precise matching
        parent = f"projects/{self.project_id}"
        filter_str = (
            f'resourceUrl="{image_uri}" AND '
            f'kind="VULNERABILITY"'
        )

        vulns = []
        for occurrence in self.grafeas.list_occurrences(
            parent=parent, filter=filter_str
        ):
            vuln = occurrence.vulnerability
            vulns.append({
                "cve": vuln.short_description,
                "severity": str(vuln.severity),
                "cvss_score": vuln.cvss_score,
                "package": vuln.package_issue[0].affected_package
                    if vuln.package_issue else "unknown",
                "fix_available": vuln.package_issue[0].fix_available
                    if vuln.package_issue else False,
                "fixed_version": str(
                    vuln.package_issue[0].fixed_version
                ) if vuln.package_issue and vuln.package_issue[0].fixed_version else None,
            })

        return vulns

    def assess_image(self, image_uri, policy):
        """Assess an image against a vulnerability policy."""
        vulns = self.get_vulnerabilities(image_uri)

        # Count vulnerabilities by severity
        severity_counts = {}
        for vuln in vulns:
            sev = vuln["severity"]
            severity_counts[sev] = severity_counts.get(sev, 0) + 1

        # Check against policy thresholds
        passed = True
        violations = []

        for severity, threshold in policy.items():
            count = severity_counts.get(severity, 0)
            if count > threshold:
                passed = False
                violations.append(
                    f"{severity}: {count} found, max allowed: {threshold}"
                )

        return {
            "image": image_uri,
            "passed": passed,
            "violations": violations,
            "total_vulnerabilities": len(vulns),
            "severity_counts": severity_counts,
            "fixable_count": sum(
                1 for v in vulns if v["fix_available"]
            ),
        }

# Define your vulnerability policy
policy = {
    "CRITICAL": 0,      # No critical vulnerabilities allowed
    "HIGH": 5,           # Up to 5 high severity allowed
    "MEDIUM": 20,        # Up to 20 medium allowed
}

assessor = VulnerabilityAssessor("my-project")
result = assessor.assess_image(
    "us-central1-docker.pkg.dev/my-project/app-images/my-app:v1.0",
    policy,
)

print(f"Assessment: {'PASSED' if result['passed'] else 'FAILED'}")
for violation in result["violations"]:
    print(f"  Violation: {violation}")
```

## Step 4: Integrate with CI/CD Pipeline

Add vulnerability assessment as a gate in your Cloud Build pipeline.

```yaml
# cloudbuild.yaml with vulnerability gate
steps:
  # Build the image
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', '${_IMAGE_URI}:${SHORT_SHA}', '.']

  # Push to Artifact Registry
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', '${_IMAGE_URI}:${SHORT_SHA}']

  # Wait for vulnerability scan to complete
  - name: 'gcr.io/cloud-builders/gcloud'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Poll for scan completion (timeout after 5 minutes)
        echo "Waiting for vulnerability scan to complete..."
        for i in $(seq 1 30); do
          SCAN_STATUS=$(gcloud artifacts docker images describe \
            ${_IMAGE_URI}:${SHORT_SHA} \
            --format="value(image_summary.slsa_build_level)" 2>/dev/null)
          if [ -n "$SCAN_STATUS" ]; then
            echo "Scan complete"
            break
          fi
          echo "Scan in progress, waiting 10 seconds..."
          sleep 10
        done

  # Check for critical vulnerabilities
  - name: 'gcr.io/cloud-builders/gcloud'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Count critical and high vulnerabilities
        CRITICAL=$(gcloud artifacts docker images list-vulnerabilities \
          ${_IMAGE_URI}:${SHORT_SHA} \
          --format="json" | python3 -c "
        import json, sys
        vulns = json.load(sys.stdin)
        critical = sum(1 for v in vulns if v.get('vulnerability', {}).get('severity') == 'CRITICAL')
        print(critical)
        ")

        echo "Critical vulnerabilities found: $CRITICAL"

        if [ "$CRITICAL" -gt "0" ]; then
          echo "FAILED: Image has critical vulnerabilities. Blocking deployment."
          exit 1
        fi

        echo "PASSED: No critical vulnerabilities found."

substitutions:
  _IMAGE_URI: us-central1-docker.pkg.dev/PROJECT_ID/app-images/my-app
```

## Step 5: Set Up Continuous Monitoring Alerts

Get notified when new vulnerabilities affect your running images.

```python
from google.cloud import pubsub_v1
from google.cloud import monitoring_v3

def setup_vulnerability_notifications(project_id):
    """Set up Pub/Sub notifications for new vulnerability findings."""
    # Container Analysis publishes to a topic when new occurrences are created
    # The topic is: projects/PROJECT_ID/topics/container-analysis-occurrences-v1

    # Create a subscription for vulnerability notifications
    subscriber = pubsub_v1.SubscriberClient()
    topic = f"projects/{project_id}/topics/container-analysis-occurrences-v1"
    subscription = f"projects/{project_id}/subscriptions/vuln-alerts"

    subscriber.create_subscription(
        request={
            "name": subscription,
            "topic": topic,
            "filter": 'attributes.kind="VULNERABILITY"',
        }
    )
    print(f"Created subscription: {subscription}")

def process_vulnerability_notification(message):
    """Process incoming vulnerability notifications."""
    import json

    data = json.loads(message.data.decode())
    occurrence_name = data.get("name", "")

    # Fetch the full occurrence details
    client = containeranalysis_v1.ContainerAnalysisClient()
    grafeas = client.get_grafeas_client()

    occurrence = grafeas.get_occurrence(name=occurrence_name)
    vuln = occurrence.vulnerability

    if vuln.severity in ["CRITICAL", "HIGH"]:
        # Send urgent notification
        send_alert(
            severity=str(vuln.severity),
            cve=vuln.short_description,
            image=occurrence.resource_uri,
            fix_available=any(
                pi.fix_available for pi in vuln.package_issue
            ),
        )

    message.ack()
```

## Step 6: Track Remediation Progress

Build a system to track vulnerability remediation across all your images.

```python
from google.cloud import bigquery
from datetime import datetime

def generate_remediation_report(project_id):
    """Generate a vulnerability remediation status report."""
    assessor = VulnerabilityAssessor(project_id)
    client = bigquery.Client(project=project_id)

    # Get all images in the registry
    ar_client = artifactregistry_v1.ArtifactRegistryClient()
    parent = f"projects/{project_id}/locations/us-central1/repositories/app-images"

    report_rows = []

    for image in ar_client.list_docker_images(parent=parent):
        vulns = assessor.get_vulnerabilities(image.uri)

        critical_fixable = sum(
            1 for v in vulns
            if v["severity"] == "CRITICAL" and v["fix_available"]
        )
        high_fixable = sum(
            1 for v in vulns
            if v["severity"] == "HIGH" and v["fix_available"]
        )

        report_rows.append({
            "timestamp": datetime.utcnow().isoformat(),
            "image": image.uri,
            "total_vulns": len(vulns),
            "critical": sum(1 for v in vulns if v["severity"] == "CRITICAL"),
            "high": sum(1 for v in vulns if v["severity"] == "HIGH"),
            "critical_fixable": critical_fixable,
            "high_fixable": high_fixable,
            "tags": ",".join(image.tags),
        })

    # Write to BigQuery for tracking over time
    table_id = f"{project_id}.security.vulnerability_tracking"
    errors = client.insert_rows_json(table_id, report_rows)
    if not errors:
        print(f"Recorded vulnerability data for {len(report_rows)} images")

    return report_rows
```

Container vulnerability management is not something you configure once and forget about. New CVEs are published daily, and your images need continuous monitoring. The combination of automatic scanning at push time, policy gates in CI/CD, continuous monitoring with alerts, and remediation tracking gives you a complete vulnerability management lifecycle for your containerized workloads.
