# How to Use go generate for Code Generation

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: Go, Golang, Code Generation, go generate, Tooling, Automation

Description: Learn how to use go generate to automate code generation in Go projects, including stringer, mock generation, and custom generators.

---

`go generate` is a tool that scans Go source files for special comments and runs the commands they specify. It's commonly used to generate code from templates, create mock implementations, and produce string methods for types.

---

## Basic Usage

Add a generate directive in your Go file:

```go
//go:generate echo "Hello from go generate"
package main
```

Run the generator:
```bash
go generate ./...
```

**Output:**
```
Hello from go generate
```

The directive syntax:
```
//go:generate command arguments...
```

**Note:** No space between `//` and `go:generate`!

---

## Common Use Case: Stringer

Generate `String()` methods for type constants:

```go
// file: status.go
package main

//go:generate stringer -type=Status

type Status int

const (
    StatusPending Status = iota
    StatusApproved
    StatusRejected
    StatusCanceled
)
```

Install stringer:
```bash
go install golang.org/x/tools/cmd/stringer@latest
```

Run generate:
```bash
go generate ./...
```

This creates `status_string.go`:

```go
// Code generated by "stringer -type=Status"; DO NOT EDIT.

package main

import "strconv"

func _() {
    var x [1]struct{}
    _ = x[StatusPending-0]
    _ = x[StatusApproved-1]
    _ = x[StatusRejected-2]
    _ = x[StatusCanceled-3]
}

const _Status_name = "StatusPendingStatusApprovedStatusRejectedStatusCanceled"

var _Status_index = [...]uint8{0, 13, 27, 41, 55}

func (i Status) String() string {
    if i < 0 || i >= Status(len(_Status_index)-1) {
        return "Status(" + strconv.FormatInt(int64(i), 10) + ")"
    }
    return _Status_name[_Status_index[i]:_Status_index[i+1]]
}
```

Now you can:
```go
fmt.Println(StatusApproved)  // Output: StatusApproved
```

---

## Generating Mocks

Using mockgen for interface mocks:

```go
// file: service.go
package user

//go:generate mockgen -source=service.go -destination=mock_service.go -package=user

type UserService interface {
    GetUser(id int) (*User, error)
    CreateUser(name, email string) (*User, error)
    DeleteUser(id int) error
}

type User struct {
    ID    int
    Name  string
    Email string
}
```

Install mockgen:
```bash
go install go.uber.org/mock/mockgen@latest
```

Run generate:
```bash
go generate ./...
```

Use in tests:
```go
func TestSomething(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    
    mock := NewMockUserService(ctrl)
    mock.EXPECT().GetUser(1).Return(&User{ID: 1, Name: "Alice"}, nil)
    
    // Use mock in your test
}
```

---

## Generating from Templates

Create a template generator:

```go
// file: gen.go
//go:build ignore

package main

import (
    "os"
    "text/template"
)

var tmpl = `// Code generated by gen.go; DO NOT EDIT.
package {{.Package}}

type {{.Name}}Set map[{{.Type}}]struct{}

func New{{.Name}}Set(items ...{{.Type}}) {{.Name}}Set {
    s := make({{.Name}}Set)
    for _, item := range items {
        s[item] = struct{}{}
    }
    return s
}

func (s {{.Name}}Set) Add(item {{.Type}}) {
    s[item] = struct{}{}
}

func (s {{.Name}}Set) Contains(item {{.Type}}) bool {
    _, ok := s[item]
    return ok
}

func (s {{.Name}}Set) Remove(item {{.Type}}) {
    delete(s, item)
}
`

type Config struct {
    Package string
    Name    string
    Type    string
}

func main() {
    configs := []Config{
        {"main", "Int", "int"},
        {"main", "String", "string"},
    }
    
    t := template.Must(template.New("set").Parse(tmpl))
    
    for _, cfg := range configs {
        filename := strings.ToLower(cfg.Name) + "_set.go"
        f, _ := os.Create(filename)
        t.Execute(f, cfg)
        f.Close()
    }
}
```

Use in your main file:

```go
// file: main.go
package main

//go:generate go run gen.go

func main() {
    s := NewIntSet(1, 2, 3)
    s.Add(4)
    fmt.Println(s.Contains(2))  // true
}
```

---

## Embedding SQL Queries

Generate SQL query constants:

```go
// file: gen_queries.go
//go:build ignore

package main

import (
    "os"
    "path/filepath"
    "strings"
)

func main() {
    files, _ := filepath.Glob("queries/*.sql")
    
    out, _ := os.Create("queries_gen.go")
    defer out.Close()
    
    out.WriteString("// Code generated; DO NOT EDIT.\n")
    out.WriteString("package db\n\n")
    
    for _, file := range files {
        content, _ := os.ReadFile(file)
        name := strings.TrimSuffix(filepath.Base(file), ".sql")
        name = strings.Title(name)
        
        fmt.Fprintf(out, "const Query%s = `%s`\n\n", name, content)
    }
}
```

```go
// file: db.go
package db

//go:generate go run gen_queries.go
```

---

## Using Environment Variables

```go
//go:generate sh -c "echo $GOFILE $GOLINE $GOPACKAGE"
package main
```

Available variables:
| Variable | Description |
|----------|-------------|
| `$GOFILE` | Current file name |
| `$GOLINE` | Line number of directive |
| `$GOPACKAGE` | Package name |
| `$GOARCH` | Target architecture |
| `$GOOS` | Target OS |
| `$DOLLAR` | Literal `$` character |

---

## Multiple Generators

```go
// file: types.go
package models

//go:generate stringer -type=Status,Priority
//go:generate mockgen -source=repository.go -destination=mock_repository.go
//go:generate go run gen_validators.go

type Status int

const (
    StatusActive Status = iota
    StatusInactive
)

type Priority int

const (
    PriorityLow Priority = iota
    PriorityMedium
    PriorityHigh
)
```

---

## Protobuf Generation

```go
// file: proto.go
package api

//go:generate protoc --go_out=. --go-grpc_out=. api.proto
```

Or with buf:
```go
//go:generate buf generate
```

---

## Custom Generator Pattern

Create reusable generators:

```go
// file: cmd/enumgen/main.go
package main

import (
    "flag"
    "fmt"
    "go/ast"
    "go/parser"
    "go/token"
    "os"
    "strings"
    "text/template"
)

var (
    typeName = flag.String("type", "", "type name")
    output   = flag.String("output", "", "output file")
)

func main() {
    flag.Parse()
    
    if *typeName == "" {
        fmt.Fprintln(os.Stderr, "-type is required")
        os.Exit(1)
    }
    
    // Parse source file
    fset := token.NewFileSet()
    f, err := parser.ParseFile(fset, os.Getenv("GOFILE"), nil, parser.ParseComments)
    if err != nil {
        panic(err)
    }
    
    // Find constants of the given type
    var values []string
    for _, decl := range f.Decls {
        genDecl, ok := decl.(*ast.GenDecl)
        if !ok || genDecl.Tok != token.CONST {
            continue
        }
        for _, spec := range genDecl.Specs {
            vspec := spec.(*ast.ValueSpec)
            if ident, ok := vspec.Type.(*ast.Ident); ok && ident.Name == *typeName {
                for _, name := range vspec.Names {
                    values = append(values, name.Name)
                }
            }
        }
    }
    
    // Generate output
    tmpl := template.Must(template.New("enum").Parse(enumTemplate))
    
    outFile := os.Stdout
    if *output != "" {
        outFile, _ = os.Create(*output)
        defer outFile.Close()
    }
    
    tmpl.Execute(outFile, map[string]interface{}{
        "Package": os.Getenv("GOPACKAGE"),
        "Type":    *typeName,
        "Values":  values,
    })
}

const enumTemplate = `// Code generated by enumgen; DO NOT EDIT.
package {{.Package}}

var {{.Type}}Values = []{{.Type}}{
{{- range .Values}}
    {{.}},
{{- end}}
}

func (v {{.Type}}) IsValid() bool {
    for _, val := range {{.Type}}Values {
        if v == val {
            return true
        }
    }
    return false
}
`
```

Usage:
```go
//go:generate go run ./cmd/enumgen -type=Status -output=status_enum.go
type Status int

const (
    StatusPending Status = iota
    StatusActive
    StatusClosed
)
```

---

## Best Practices

### 1. Add Generated File Header

```go
// Code generated by TOOL; DO NOT EDIT.
```

This tells editors and tools the file is generated.

### 2. Use Build Tags for Generator Code

```go
//go:build ignore

package main

// Generator code here
```

The `ignore` tag prevents the generator from being compiled with your package.

### 3. Makefile Integration

```makefile
.PHONY: generate
generate:
    go generate ./...

.PHONY: build
build: generate
    go build ./...
```

### 4. CI/CD Check

```yaml
# GitHub Actions
- name: Check generated code
  run: |
    go generate ./...
    git diff --exit-code
```

---

## Summary

| Tool | Purpose |
|------|---------|
| `stringer` | Generate String() for constants |
| `mockgen` | Generate mock implementations |
| `protoc` | Generate protobuf code |
| `enumer` | Generate enum methods |
| `go-bindata` | Embed binary data |
| `sqlc` | Generate SQL query code |

**Best Practices:**

1. Put `//go:generate` near the relevant code
2. Include "DO NOT EDIT" in generated files
3. Use build tags for generator source
4. Check generated code into version control
5. Verify generated code is up-to-date in CI
6. Document what generators are required

---

*Automating your Go workflow? [OneUptime](https://oneuptime.com) provides CI/CD monitoring to track build times and catch failures in your code generation pipeline.*
