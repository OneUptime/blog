# How to Use Tracetest with Playwright for End-to-End Trace-Based Browser Testing

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: OpenTelemetry, Tracetest, Playwright, Browser Testing, End-to-End Testing

Description: Set up Tracetest with Playwright to run browser-driven end-to-end tests that validate both UI behavior and backend traces.

Traditional end-to-end tests check if the UI looks right. Trace-based tests check if the backend did the right things. Combining Playwright with Tracetest lets you do both in a single test run: drive the browser with Playwright, then verify that the correct spans, attributes, and status codes appeared in the distributed trace.

## Why Combine Playwright and Tracetest

Playwright tests verify user-facing behavior. You click a button, fill a form, assert that a success message appears. But what if the success message appears even though the payment was never actually processed? Or the order was saved to the database without proper validation?

Tracetest picks up where Playwright stops. It fetches the trace generated by your backend during the Playwright interaction and lets you write assertions against individual spans.

## Setting Up the Stack

You need three things running: your application (instrumented with OpenTelemetry), a trace backend, and Tracetest.

```yaml
# docker-compose.yaml
version: '3.8'
services:
  app:
    build: ./app
    ports:
      - "3000:3000"
    environment:
      - OTEL_EXPORTER_OTLP_ENDPOINT=http://otel-collector:4318
      - OTEL_SERVICE_NAME=web-store

  otel-collector:
    image: otel/opentelemetry-collector-contrib:latest
    volumes:
      - ./otel-config.yaml:/etc/otel/config.yaml
    command: ["--config", "/etc/otel/config.yaml"]
    ports:
      - "4317:4317"
      - "4318:4318"

  tracetest:
    image: kubeshop/tracetest:latest
    ports:
      - "11633:11633"
    environment:
      - TRACETEST_DEV=true
    depends_on:
      - otel-collector
```

## Writing the Playwright Test

The Playwright test drives the browser and captures a trace ID that Tracetest will use to fetch the corresponding trace.

```typescript
// tests/checkout.spec.ts
import { test, expect } from '@playwright/test';
import Tracetest from '@tracetest/playwright';

// Initialize the Tracetest integration
const tracetest = Tracetest();

test.beforeAll(async () => {
  await tracetest.configure({
    serverUrl: 'http://localhost:11633',
    // Point to the test definition file
    testFile: './tracetest/checkout-trace-test.yaml',
  });
});

test('checkout process creates correct backend spans', async ({ page }) => {
  // Navigate to the store
  await page.goto('http://localhost:3000/products');

  // Add item to cart
  await page.click('[data-testid="add-to-cart-btn"]');
  await expect(page.locator('.cart-count')).toHaveText('1');

  // Go to checkout
  await page.click('[data-testid="checkout-btn"]');

  // Fill in payment details
  await page.fill('#card-number', '4242424242424242');
  await page.fill('#expiry', '12/27');
  await page.fill('#cvv', '123');

  // Submit the order - this triggers backend spans
  await page.click('[data-testid="submit-order"]');

  // Wait for confirmation on the UI side
  await expect(page.locator('.order-confirmation')).toBeVisible();

  // Now run the trace-based assertions
  // Tracetest fetches the trace from the backend and validates it
  await tracetest.runTest();
});

test.afterAll(async () => {
  await tracetest.summary();
});
```

## Defining Trace Assertions in Tracetest

The Tracetest definition file specifies what the backend trace should look like:

```yaml
# tracetest/checkout-trace-test.yaml
type: Test
spec:
  name: Checkout Trace Validation
  trigger:
    type: playwright
  specs:
    # Verify the payment service was called
    - selector: span[name="POST /api/payments" service.name="payment-service"]
      assertions:
        - attr:http.status_code = 200
        - attr:payment.amount > 0
        - attr:payment.currency = "USD"

    # Verify the order was persisted to the database
    - selector: span[name="INSERT orders" service.name="order-service"]
      assertions:
        - attr:db.system = "postgresql"
        - attr:db.operation = "INSERT"

    # Verify the confirmation email was queued
    - selector: span[name="publish order.confirmed" service.name="notification-service"]
      assertions:
        - attr:messaging.system = "rabbitmq"
        - attr:messaging.destination = "order.confirmed"

    # Verify there are no error spans in the trace
    - selector: span[status.code="ERROR"]
      assertions:
        - attr:tracetest.selected_spans.count = 0
```

## Handling Trace Propagation from the Browser

For Tracetest to correlate browser activity with backend traces, the frontend needs to propagate trace context. If your frontend uses the OpenTelemetry Browser SDK, this happens automatically. Otherwise, you can inject it manually:

```typescript
// In your frontend app code
import { context, trace, propagation } from '@opentelemetry/api';

async function submitOrder(orderData: OrderData) {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };

  // Inject trace context into the outgoing request headers
  propagation.inject(context.active(), headers);

  const response = await fetch('/api/orders', {
    method: 'POST',
    headers,
    body: JSON.stringify(orderData),
  });

  return response.json();
}
```

## Running Tests in CI

Add this to your CI pipeline to run Playwright tests with trace validation:

```yaml
# .github/workflows/e2e.yaml
name: E2E Trace Tests
on: [push]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Start services
        run: docker compose up -d --wait

      - name: Install Playwright
        run: npx playwright install --with-deps chromium

      - name: Run trace-based E2E tests
        run: npx playwright test
        env:
          TRACETEST_SERVER_URL: http://localhost:11633

      - name: Collect Tracetest results
        if: always()
        run: |
          curl -s http://localhost:11633/api/tests | jq '.items[] | {name, status: .run.state}'
```

## Debugging Failed Trace Assertions

When a trace assertion fails, Tracetest shows you exactly which span did not match and what the actual values were. This is much more useful than a generic "test failed" message from Playwright alone. You can see that the payment span returned a 500 status code, or that the database INSERT span is missing entirely because a service crashed.

This combination of UI testing and trace validation catches a class of bugs that neither approach catches alone. The UI might look fine while the backend silently drops data, or the backend might work correctly while the UI misinterprets the response.
