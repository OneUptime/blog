# How to Implement Dependency Scanning and Vulnerability Detection with Artifact Registry

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: GCP, Artifact Registry, Vulnerability Scanning, Container Security, DevSecOps

Description: Set up automated dependency scanning and vulnerability detection for container images and language packages using GCP Artifact Registry's built-in scanning capabilities.

---

Every application you build depends on libraries, frameworks, and base images that you didn't write. And every one of those dependencies is a potential entry point for attackers if it contains a known vulnerability. The challenge isn't knowing this - it's building a system that catches vulnerable dependencies before they reach production and keeps catching them as new vulnerabilities are discovered.

Artifact Registry on GCP includes built-in vulnerability scanning for container images, and with a bit of additional setup, you can extend this to cover language-specific packages as well. Here's how to build a comprehensive dependency scanning pipeline.

## How Artifact Registry Scanning Works

When you push a container image to Artifact Registry, it can automatically scan the image for known vulnerabilities. The scanner inspects OS packages (Debian, Alpine, Red Hat, etc.) and language packages (Python, Node.js, Java, Go, etc.) against vulnerability databases including the CVE database, Google's own threat intelligence, and distribution-specific advisories.

Scanning happens in two ways: on-push scanning (triggered when you push a new image) and continuous scanning (ongoing monitoring of already-stored images for newly discovered vulnerabilities).

## Enabling Vulnerability Scanning

```bash
# Enable the Container Scanning API
gcloud services enable containerscanning.googleapis.com

# Create an Artifact Registry repository with scanning enabled
gcloud artifacts repositories create app-images \
    --repository-format=docker \
    --location=us-central1 \
    --description="Application images with vulnerability scanning"

# Verify scanning is enabled (it's on by default for new repos)
gcloud artifacts repositories describe app-images \
    --location=us-central1
```

To enable continuous scanning for existing images:

```bash
# Enable Container Analysis for ongoing monitoring
gcloud services enable containeranalysis.googleapis.com

# Continuous scanning is automatic once Container Analysis is enabled
# It will re-scan images when new CVEs are published
```

## Building a Scanning Pipeline in Cloud Build

Here's a Cloud Build pipeline that builds, pushes, scans, and evaluates images:

```yaml
# cloudbuild.yaml
steps:
  # Build the container image
  - name: 'gcr.io/cloud-builders/docker'
    args:
      - 'build'
      - '-t'
      - '${_REGISTRY}/${_IMAGE}:${SHORT_SHA}'
      - '.'
    id: 'build'

  # Push to Artifact Registry (triggers on-push scan)
  - name: 'gcr.io/cloud-builders/docker'
    args:
      - 'push'
      - '${_REGISTRY}/${_IMAGE}:${SHORT_SHA}'
    id: 'push'

  # Wait for the vulnerability scan to complete
  - name: 'gcr.io/cloud-builders/gcloud'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        IMAGE="${_REGISTRY}/${_IMAGE}:${SHORT_SHA}"
        echo "Waiting for vulnerability scan on $IMAGE..."

        # Poll for scan completion (timeout after 10 minutes)
        ATTEMPTS=0
        MAX_ATTEMPTS=60

        while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
          SCAN_STATUS=$(gcloud artifacts docker images describe "$IMAGE" \
            --show-package-vulnerability \
            --format='value(package_vulnerability_summary.severity_count)' \
            2>/dev/null)

          if [ -n "$SCAN_STATUS" ]; then
            echo "Scan completed."
            break
          fi

          ATTEMPTS=$((ATTEMPTS + 1))
          echo "Waiting... attempt $ATTEMPTS/$MAX_ATTEMPTS"
          sleep 10
        done

        if [ $ATTEMPTS -eq $MAX_ATTEMPTS ]; then
          echo "Scan did not complete within timeout"
          exit 1
        fi
    id: 'wait-for-scan'

  # Evaluate scan results against security policy
  - name: 'python:3.11-slim'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        pip install google-cloud-containeranalysis google-cloud-artifactregistry
        python3 scripts/evaluate_scan.py \
          --image "${_REGISTRY}/${_IMAGE}:${SHORT_SHA}" \
          --max-critical 0 \
          --max-high 3 \
          --max-medium 10
    id: 'evaluate'

substitutions:
  _REGISTRY: 'us-central1-docker.pkg.dev/YOUR_PROJECT/app-images'
  _IMAGE: 'myservice'
```

## The Scan Evaluation Script

This Python script checks scan results against your security policy:

```python
# scripts/evaluate_scan.py
import argparse
import sys
from google.cloud import artifactregistry_v1

def evaluate_vulnerabilities(image_url, max_critical, max_high, max_medium):
    """Check if an image's vulnerabilities exceed allowed thresholds"""

    client = artifactregistry_v1.ArtifactRegistryClient()

    # Parse the image URL to get the components
    parts = image_url.replace("https://", "").split("/")
    location = parts[0].split("-docker")[0]
    project = parts[1]
    repo = parts[2]
    image_tag = parts[3]

    # List vulnerabilities for this image
    parent = f"projects/{project}/locations/{location}/repositories/{repo}"

    # Use gcloud CLI to get vulnerability details
    import subprocess
    result = subprocess.run(
        [
            "gcloud", "artifacts", "docker", "images",
            "list-vulnerabilities", image_url,
            "--format=json"
        ],
        capture_output=True, text=True
    )

    if result.returncode != 0:
        print(f"Failed to get vulnerabilities: {result.stderr}")
        sys.exit(1)

    import json
    vulns = json.loads(result.stdout)

    # Count by severity
    counts = {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0}
    fixable_counts = {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0}

    for vuln in vulns:
        severity = vuln.get("vulnerability", {}).get(
            "effectiveSeverity", "UNKNOWN"
        )
        if severity in counts:
            counts[severity] += 1

        # Track fixable vulnerabilities separately
        if vuln.get("vulnerability", {}).get("fixAvailable"):
            fixable_counts[severity] = fixable_counts.get(severity, 0) + 1

    # Print the summary
    print("\n=== Vulnerability Scan Results ===")
    print(f"Image: {image_url}")
    print(f"Critical: {counts['CRITICAL']} ({fixable_counts['CRITICAL']} fixable)")
    print(f"High:     {counts['HIGH']} ({fixable_counts['HIGH']} fixable)")
    print(f"Medium:   {counts['MEDIUM']} ({fixable_counts['MEDIUM']} fixable)")
    print(f"Low:      {counts['LOW']}")
    print("================================\n")

    # Check against policy thresholds
    violations = []
    if counts["CRITICAL"] > max_critical:
        violations.append(
            f"CRITICAL: {counts['CRITICAL']} found, max allowed: {max_critical}"
        )
    if counts["HIGH"] > max_high:
        violations.append(
            f"HIGH: {counts['HIGH']} found, max allowed: {max_high}"
        )
    if counts["MEDIUM"] > max_medium:
        violations.append(
            f"MEDIUM: {counts['MEDIUM']} found, max allowed: {max_medium}"
        )

    if violations:
        print("POLICY VIOLATIONS:")
        for v in violations:
            print(f"  - {v}")
        print("\nBuild FAILED due to vulnerability policy violations.")
        sys.exit(1)

    print("All checks passed. Image meets security policy requirements.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--image", required=True)
    parser.add_argument("--max-critical", type=int, default=0)
    parser.add_argument("--max-high", type=int, default=3)
    parser.add_argument("--max-medium", type=int, default=10)
    args = parser.parse_args()

    evaluate_vulnerabilities(
        args.image, args.max_critical, args.max_high, args.max_medium
    )
```

## Scanning Language-Specific Dependencies

For language packages, scan before building the container:

```yaml
# Additional Cloud Build steps for language-level scanning
steps:
  # Scan Node.js dependencies with npm audit
  - name: 'node:20-alpine'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        npm audit --json > /workspace/npm-audit.json 2>&1 || true
        # Check for critical and high severity issues
        CRITICAL=$(cat /workspace/npm-audit.json | \
          python3 -c "import json,sys; d=json.load(sys.stdin); print(d.get('metadata',{}).get('vulnerabilities',{}).get('critical',0))")
        HIGH=$(cat /workspace/npm-audit.json | \
          python3 -c "import json,sys; d=json.load(sys.stdin); print(d.get('metadata',{}).get('vulnerabilities',{}).get('high',0))")

        echo "npm audit: Critical=$CRITICAL, High=$HIGH"

        if [ "$CRITICAL" -gt 0 ]; then
          echo "BLOCKED: Critical npm vulnerabilities found"
          npm audit --audit-level=critical
          exit 1
        fi
    id: 'npm-audit'

  # Scan Python dependencies with pip-audit
  - name: 'python:3.11-slim'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        pip install pip-audit
        pip-audit -r requirements.txt --format json --output /workspace/pip-audit.json || {
          echo "Vulnerable Python dependencies found:"
          pip-audit -r requirements.txt
          exit 1
        }
    id: 'pip-audit'

  # Scan Go dependencies
  - name: 'golang:1.21'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        go install golang.org/x/vuln/cmd/govulncheck@latest
        govulncheck ./... || {
          echo "Vulnerable Go dependencies found"
          exit 1
        }
    id: 'go-vuln-check'
```

## Continuous Monitoring and Alerting

Set up notifications when new vulnerabilities are found in existing images:

```python
from google.cloud import pubsub_v1
import json

def on_new_vulnerability(event, context):
    """Triggered when a new vulnerability is found in a stored image"""
    # Container Analysis publishes to this topic when new vulns are found
    message = json.loads(
        event["data"].decode("utf-8") if isinstance(event["data"], bytes)
        else event["data"]
    )

    occurrence = message.get("occurrence", {})
    resource_uri = occurrence.get("resourceUri", "")
    vuln_details = occurrence.get("vulnerability", {})
    severity = vuln_details.get("effectiveSeverity", "UNKNOWN")
    cve_id = vuln_details.get("shortDescription", "unknown")

    # Only alert on critical and high severity
    if severity not in ("CRITICAL", "HIGH"):
        return

    # Check if a fix is available
    fix_available = vuln_details.get("fixAvailable", False)

    alert_message = {
        "image": resource_uri,
        "cve": cve_id,
        "severity": severity,
        "fix_available": fix_available,
        "description": vuln_details.get("longDescription", ""),
    }

    # Send to your alerting channel
    send_alert(alert_message)
    print(f"Alert sent for {cve_id} in {resource_uri}")
```

## Generating Vulnerability Reports

Create periodic reports of your vulnerability posture:

```bash
# List all images with critical vulnerabilities
gcloud artifacts docker images list \
    us-central1-docker.pkg.dev/YOUR_PROJECT/app-images \
    --show-package-vulnerability \
    --occurrence-filter='kind="VULNERABILITY" AND vulnerability.effectiveSeverity="CRITICAL"' \
    --format="table(package, version, createTime, vulnerabilities.critical)"

# Export vulnerability data to BigQuery for trending
bq query --use_legacy_sql=false '
SELECT
  resource_uri,
  vulnerability.effective_severity,
  vulnerability.short_description AS cve_id,
  vulnerability.fix_available,
  create_time
FROM `YOUR_PROJECT.container_analysis.occurrences`
WHERE kind = "VULNERABILITY"
  AND create_time > TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY)
ORDER BY create_time DESC
'
```

## Wrapping Up

Dependency scanning is one of those things that seems simple but has a lot of depth. The basics are straightforward - enable Artifact Registry scanning and check results in your build pipeline. But for real security, you need language-level scanning before the container build, continuous monitoring for newly discovered CVEs, automated alerting for critical findings, and clear policies about what severity levels block a deployment. Start with container-level scanning and zero tolerance for critical CVEs, then expand coverage to language packages and lower severity levels as your team builds the muscle to respond to findings quickly.
