# How to Use Migrate to Containers to Convert VMs to GKE Workloads

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: GCP, Migrate to Containers, GKE, Kubernetes, VM Migration

Description: Learn how to use GCP Migrate to Containers to automatically convert virtual machine workloads into container images and Kubernetes deployments running on GKE.

---

You have a fleet of virtual machines running applications that would benefit from containerization - better resource utilization, easier scaling, faster deployments. But rewriting applications and creating Dockerfiles from scratch for dozens or hundreds of VMs is a massive undertaking. Migrate to Containers (M2C) automates this conversion, turning VMs into container images and generating Kubernetes deployment artifacts.

M2C analyzes a running VM, extracts the application and its dependencies, builds a container image, and creates the Kubernetes YAML you need to deploy it on GKE. It is not a magic button - you will still need to tune the results - but it dramatically reduces the effort compared to manual containerization.

## How Migrate to Containers Works

The process has several stages:

```mermaid
flowchart LR
    A[Source VM] --> B[Migration Plan]
    B --> C[Generate Artifacts]
    C --> D[Container Image]
    C --> E[Kubernetes YAML]
    D --> F[GKE Deployment]
    E --> F

    style C fill:#4285f4,stroke:#333,color:#fff
```

1. **Create a migration source**: Connect M2C to where your VMs live (Compute Engine, VMware, AWS)
2. **Create a migration plan**: M2C analyzes the VM and generates a migration plan
3. **Review and customize**: You review the plan, adjust what gets included in the container
4. **Generate artifacts**: M2C builds the container image and Kubernetes manifests
5. **Deploy**: Apply the manifests to your GKE cluster

## Prerequisites

- A GKE cluster with Migrate to Containers installed
- Source VMs (Compute Engine, VMware, or AWS)
- The M2C processing cluster needs at least 3 nodes with 4 vCPUs and 16 GB RAM each

## Step 1: Set Up the GKE Cluster

Create a GKE cluster and install Migrate to Containers:

```bash
# Create a GKE cluster for M2C processing
gcloud container clusters create m2c-cluster \
  --zone=us-central1-a \
  --machine-type=e2-standard-4 \
  --num-nodes=3 \
  --enable-ip-alias \
  --project=PROJECT_ID

# Get credentials
gcloud container clusters get-credentials m2c-cluster \
  --zone=us-central1-a \
  --project=PROJECT_ID
```

Install Migrate to Containers:

```bash
# Download and install migctl
gcloud components install migrate-to-containers

# Set up M2C on the cluster
migctl setup install --gke-cluster=m2c-cluster \
  --gke-zone=us-central1-a \
  --gke-project=PROJECT_ID
```

Verify the installation:

```bash
# Check M2C components are running
migctl doctor
```

## Step 2: Create a Migration Source

Connect M2C to your VM source. For Compute Engine VMs:

```bash
# Create a Compute Engine migration source
migctl source create ce my-ce-source \
  --project=PROJECT_ID \
  --json='{"projectId": "PROJECT_ID"}'
```

For VMware VMs:

```bash
# Create a VMware migration source
migctl source create vsphere my-vmware-source \
  --manager-address=vcenter.example.com \
  --cloud-extension=cloud-extension-name \
  --cloud-details-name=cloud-details-name
```

For AWS EC2 VMs:

```bash
# Create an AWS migration source
migctl source create aws my-aws-source \
  --region=us-east-1 \
  --access-key-id=AKIAIOSFODNN7EXAMPLE \
  --secret-access-key=wJalrXUtnFEMI/K7MDENG
```

## Step 3: Create a Migration

Start a migration for a specific VM:

```bash
# Create a migration for a Compute Engine VM
migctl migration create my-web-server-migration \
  --source=my-ce-source \
  --vm-id=web-server-vm-001 \
  --intent=Image
```

The `--intent` parameter specifies what you want to produce:

- `Image`: Generate a container image and Kubernetes YAML
- `ImageAndData`: Also include stateful data volumes
- `Data`: Only migrate data, not the application

Check the migration status:

```bash
# Check migration status
migctl migration status my-web-server-migration
```

## Step 4: Generate and Review the Migration Plan

Once M2C has analyzed the VM, it generates a migration plan:

```bash
# Get the migration plan for review
migctl migration get-plan my-web-server-migration
```

The plan is a YAML file that describes what M2C found on the VM and how it plans to containerize it. Here is an example plan:

```yaml
# Migration plan generated by M2C
apiVersion: anthos-migrate.cloud.google.com/v1
kind: LinuxMigrationPlan
metadata:
  name: my-web-server-migration
spec:
  # Base OS image for the container
  image:
    base: "ubuntu:20.04"

  # Services detected on the VM
  detectedServices:
    - name: nginx
      enabled: true
      probes:
        - type: liveness
          httpGet:
            path: /
            port: 80
    - name: my-app
      enabled: true
      probes:
        - type: liveness
          tcpSocket:
            port: 8080

  # File system paths to include/exclude
  dataVolumes:
    - path: /var/www/html
      persistentVolume: true
    - path: /etc/nginx
      persistentVolume: false

  # Directories to exclude from the container image
  excludePaths:
    - /tmp
    - /var/tmp
    - /var/cache
    - /var/log

  # Network ports to expose
  endpoints:
    - port: 80
      protocol: TCP
    - port: 8080
      protocol: TCP
```

Review this plan carefully. Common adjustments include:

- Removing unnecessary services from the container
- Adjusting which paths are included or excluded
- Configuring volume mounts for persistent data
- Setting the right health check endpoints

To edit the plan:

```bash
# Download the plan for editing
migctl migration get-plan my-web-server-migration -o plan.yaml

# Edit the plan
# ... make your changes to plan.yaml ...

# Upload the modified plan
migctl migration update my-web-server-migration --plan plan.yaml
```

## Step 5: Generate Container Artifacts

Once you are happy with the plan, generate the container image and Kubernetes manifests:

```bash
# Generate the container artifacts
migctl migration generate-artifacts my-web-server-migration
```

This step:

1. Creates a container image from the VM's filesystem
2. Pushes the image to your container registry
3. Generates Kubernetes deployment YAML
4. Generates a Dockerfile for future rebuilds

Check the status:

```bash
# Monitor artifact generation progress
migctl migration status my-web-server-migration

# Once complete, download the artifacts
migctl migration get-artifacts my-web-server-migration -o ./artifacts/
```

## Step 6: Review Generated Artifacts

The generated artifacts typically include:

```bash
# List the generated files
ls ./artifacts/
```

You will find:

- `deployment_spec.yaml` - Kubernetes Deployment and Service definitions
- `Dockerfile` - For rebuilding the container image
- `migration.yaml` - The migration configuration

Review the deployment spec:

```yaml
# deployment_spec.yaml (generated by M2C)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app: web-server
  template:
    metadata:
      labels:
        app: web-server
    spec:
      containers:
        - name: web-server
          image: us-central1-docker.pkg.dev/PROJECT_ID/m2c-images/web-server:v1
          ports:
            - containerPort: 80
            - containerPort: 8080
          resources:
            requests:
              cpu: "500m"
              memory: "1Gi"
          livenessProbe:
            httpGet:
              path: /
              port: 80
            initialDelaySeconds: 30
          volumeMounts:
            - name: data
              mountPath: /var/www/html
      volumes:
        - name: data
          persistentVolumeClaim:
            claimName: web-server-data
---
apiVersion: v1
kind: Service
metadata:
  name: web-server
spec:
  selector:
    app: web-server
  ports:
    - name: http
      port: 80
      targetPort: 80
    - name: app
      port: 8080
      targetPort: 8080
  type: LoadBalancer
```

## Step 7: Customize and Deploy

Adjust the generated YAML for production use:

```yaml
# Add resource limits, HPA, and additional configuration
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-server
spec:
  replicas: 3  # Increase from 1 for production
  selector:
    matchLabels:
      app: web-server
  template:
    metadata:
      labels:
        app: web-server
    spec:
      containers:
        - name: web-server
          image: us-central1-docker.pkg.dev/PROJECT_ID/m2c-images/web-server:v1
          ports:
            - containerPort: 80
            - containerPort: 8080
          resources:
            requests:
              cpu: "500m"
              memory: "1Gi"
            limits:
              cpu: "2000m"
              memory: "4Gi"
          livenessProbe:
            httpGet:
              path: /
              port: 80
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /
              port: 80
            initialDelaySeconds: 5
            periodSeconds: 5
```

Deploy to your production GKE cluster:

```bash
# Deploy the containerized workload
kubectl apply -f deployment_spec.yaml

# Verify the deployment
kubectl rollout status deployment/web-server

# Check pods
kubectl get pods -l app=web-server

# Test the service
kubectl get svc web-server
```

## Step 8: Iterate and Optimize

The first migration is rarely perfect. Common post-migration tasks:

**Slim down the image.** M2C includes the full VM filesystem by default. Remove unnecessary packages and files to reduce image size:

```dockerfile
# Edit the generated Dockerfile to remove unnecessary packages
FROM us-central1-docker.pkg.dev/PROJECT_ID/m2c-images/web-server-base:v1

# Remove packages not needed in the container
RUN apt-get remove -y \
  desktop-packages \
  unnecessary-tools \
  && apt-get autoremove -y \
  && rm -rf /var/lib/apt/lists/*
```

**Externalize configuration.** Move configuration that was baked into the VM to ConfigMaps or environment variables:

```yaml
# configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: web-server-config
data:
  nginx.conf: |
    server {
      listen 80;
      root /var/www/html;
      location /api {
        proxy_pass http://localhost:8080;
      }
    }
```

**Add proper logging.** Configure the application to log to stdout/stderr instead of log files so Kubernetes picks up the logs automatically.

## Limitations to Be Aware Of

**Not all workloads containerize well.** Applications with heavy filesystem dependencies, GUI components, or kernel-level operations may not work well in containers.

**Windows VMs require different handling.** M2C primarily supports Linux VMs. Windows containerization requires a different approach.

**Stateful applications need careful planning.** If the VM has local databases or stateful services, you need to decide whether to include them in the container or migrate them to managed services (Cloud SQL, etc.).

**Performance may differ.** Containerized workloads share resources differently than VMs. Benchmark your containerized application against the original VM to make sure performance is acceptable.

## Summary

Migrate to Containers automates the hardest part of containerizing VM workloads - analyzing the VM, extracting the application, and generating a working container image. Install M2C on a GKE cluster, create a migration for your VM, review and customize the generated plan, and deploy the containerized result. The generated artifacts are a starting point - plan for iteration to slim down images, externalize configuration, and optimize for the container runtime. The result is a containerized workload that benefits from Kubernetes orchestration without requiring a manual rewrite.
