# How to Implement SLSA Level 3 Build Provenance with Cloud Build on Google Cloud

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: GCP, Cloud Build, SLSA, Supply Chain Security, DevOps

Description: Implement SLSA Level 3 build provenance using Google Cloud Build to secure your software supply chain with verifiable build attestations.

---

Supply chain attacks are not theoretical anymore. SolarWinds, Codecov, and the xz utils backdoor showed how devastating they can be. SLSA (Supply-chain Levels for Software Artifacts) is a framework that helps you protect against these attacks by ensuring your build process is trustworthy and your artifacts have verifiable provenance.

Google Cloud Build has built-in support for generating SLSA provenance, and getting to Level 3 - which means your builds run on a hardened, isolated platform with non-falsifiable provenance - is achievable without major infrastructure changes.

In this post, I will walk through what SLSA Level 3 requires and how to implement it on Cloud Build.

## Understanding SLSA Levels

SLSA defines four levels of build security:

- **Level 1** - Documentation of the build process (basically, you have a build script)
- **Level 2** - Tamper resistance of the build service (hosted CI/CD, signed provenance)
- **Level 3** - Extra resistance to specific threats (isolated builds, non-falsifiable provenance)
- **Level 4** - The highest assurance (hermetic builds, reproducible, two-person review)

Cloud Build gives you Level 3 because each build runs in an isolated VM, the provenance is generated by the platform (not user-controlled steps), and it is signed by Google's infrastructure.

## Enabling SLSA Provenance in Cloud Build

The first step is making sure your Cloud Build configuration generates provenance attestations. This is done by using the `requestedVerifyOption` field:

```yaml
# cloudbuild.yaml
# Build configuration with SLSA provenance enabled
options:
  # Request provenance verification - this enables SLSA attestation
  requestedVerifyOption: VERIFIED

steps:
  # Build the container image
  - name: 'gcr.io/cloud-builders/docker'
    args:
      - 'build'
      - '-t'
      - 'us-docker.pkg.dev/${PROJECT_ID}/my-repo/my-app:${SHORT_SHA}'
      - '-t'
      - 'us-docker.pkg.dev/${PROJECT_ID}/my-repo/my-app:latest'
      - '--no-cache'
      - '.'

  # Push to Artifact Registry
  - name: 'gcr.io/cloud-builders/docker'
    args:
      - 'push'
      - 'us-docker.pkg.dev/${PROJECT_ID}/my-repo/my-app:${SHORT_SHA}'

  - name: 'gcr.io/cloud-builders/docker'
    args:
      - 'push'
      - 'us-docker.pkg.dev/${PROJECT_ID}/my-repo/my-app:latest'

images:
  - 'us-docker.pkg.dev/${PROJECT_ID}/my-repo/my-app:${SHORT_SHA}'
  - 'us-docker.pkg.dev/${PROJECT_ID}/my-repo/my-app:latest'
```

## Setting Up Artifact Registry

Your container images need to be stored in Artifact Registry (not the old Container Registry) to get provenance attestations:

```hcl
# artifact-registry.tf
# Artifact Registry repository with vulnerability scanning

resource "google_artifact_registry_repository" "app_repo" {
  location      = var.region
  repository_id = "my-repo"
  description   = "Application container images"
  format        = "DOCKER"
  project       = var.project_id

  # Enable vulnerability scanning
  docker_config {
    immutable_tags = true  # Prevent tag overwriting
  }
}

# Grant Cloud Build permission to push images
resource "google_artifact_registry_repository_iam_member" "cloudbuild_writer" {
  project    = var.project_id
  location   = var.region
  repository = google_artifact_registry_repository.app_repo.name
  role       = "roles/artifactregistry.writer"
  member     = "serviceAccount:${var.project_number}@cloudbuild.gserviceaccount.com"
}
```

## Verifying Build Provenance

After a build completes, you can verify the provenance attestation. This is critical - generating provenance is useless if you do not verify it.

Use gcloud to check the provenance of a built image:

```bash
# View the provenance attestation for a built image
gcloud artifacts docker images describe \
  us-docker.pkg.dev/${PROJECT_ID}/my-repo/my-app:${TAG} \
  --show-provenance

# Verify the provenance using the SLSA verifier
slsa-verifier verify-image \
  us-docker.pkg.dev/${PROJECT_ID}/my-repo/my-app@sha256:${DIGEST} \
  --source-uri github.com/myorg/myrepo \
  --builder-id https://cloudbuild.googleapis.com/GoogleHostedWorker
```

## Implementing Binary Authorization

To enforce that only images with valid provenance can be deployed, set up Binary Authorization:

```hcl
# binary-auth.tf
# Binary Authorization policy requiring SLSA provenance

resource "google_binary_authorization_policy" "slsa_policy" {
  project = var.project_id

  # Default rule: deny all images that do not have attestations
  default_admission_rule {
    evaluation_mode  = "REQUIRE_ATTESTATION"
    enforcement_mode = "ENFORCED_BLOCK_AND_AUDIT_LOG"

    require_attestations_by = [
      google_binary_authorization_attestor.cloud_build.name
    ]
  }

  # Allow Google-provided system images
  admission_whitelist_patterns {
    name_pattern = "gcr.io/google_containers/*"
  }

  admission_whitelist_patterns {
    name_pattern = "gcr.io/google-containers/*"
  }

  # Allow GKE system images
  admission_whitelist_patterns {
    name_pattern = "gke.gcr.io/*"
  }
}

# Create an attestor that validates Cloud Build provenance
resource "google_binary_authorization_attestor" "cloud_build" {
  name    = "cloud-build-attestor"
  project = var.project_id

  attestation_authority_note {
    note_reference = google_container_analysis_note.build_note.name

    public_keys {
      id = "//cloudkms.googleapis.com/v1/${google_kms_crypto_key.attestor_key.id}/cryptoKeyVersions/1"

      pkix_public_key {
        public_key_pem      = data.google_kms_crypto_key_version.attestor_key_version.public_key[0].pem
        signature_algorithm = data.google_kms_crypto_key_version.attestor_key_version.public_key[0].algorithm
      }
    }
  }
}

resource "google_container_analysis_note" "build_note" {
  name    = "cloud-build-slsa-note"
  project = var.project_id

  attestation_authority {
    hint {
      human_readable_name = "Cloud Build SLSA Level 3 Attestation"
    }
  }
}
```

## Creating Custom Attestations

In addition to the built-in provenance, you can create custom attestations for additional checks like vulnerability scanning:

```python
# create_attestation.py
# Creates a custom attestation after vulnerability scanning passes
from google.cloud import binaryauthorization_v1
from google.cloud import containeranalysis_v1
from google.cloud import kms_v1
import hashlib
import json
import base64

def create_vulnerability_attestation(
    project_id, image_url, image_digest,
    attestor_name, key_name
):
    """Create an attestation after vulnerability scan passes."""

    # First, check that the image passed vulnerability scanning
    if not vulnerability_scan_passed(project_id, image_url):
        print("Vulnerability scan did not pass - skipping attestation")
        return False

    # Create the attestation payload
    payload = {
        "critical": {
            "identity": {
                "docker-reference": image_url
            },
            "image": {
                "docker-manifest-digest": image_digest
            },
            "type": "Google cloud binauthz container signature"
        }
    }

    payload_bytes = json.dumps(payload).encode('utf-8')

    # Sign the payload with KMS
    kms_client = kms_v1.KeyManagementServiceClient()
    sign_response = kms_client.asymmetric_sign(
        request={
            "name": key_name,
            "digest": {
                "sha256": hashlib.sha256(payload_bytes).digest()
            }
        }
    )

    signature = base64.b64encode(
        sign_response.signature
    ).decode('utf-8')

    # Create the attestation occurrence
    client = containeranalysis_v1.GrafeasClient()
    note_name = f"projects/{project_id}/notes/cloud-build-slsa-note"

    occurrence = {
        "resource_uri": f"{image_url}@{image_digest}",
        "note_name": note_name,
        "attestation": {
            "serialized_payload": base64.b64encode(
                payload_bytes
            ).decode('utf-8'),
            "signatures": [{
                "public_key_id": key_name,
                "signature": signature,
            }]
        }
    }

    result = client.create_occurrence(
        parent=f"projects/{project_id}",
        occurrence=occurrence
    )

    print(f"Attestation created: {result.name}")
    return True


def vulnerability_scan_passed(project_id, image_url):
    """Check if the image passed vulnerability scanning."""
    client = containeranalysis_v1.GrafeasClient()
    parent = f"projects/{project_id}"

    # List vulnerability occurrences for the image
    filter_str = (
        f'resourceUrl="{image_url}" '
        f'AND kind="VULNERABILITY" '
        f'AND noteProjectId="{project_id}"'
    )

    critical_count = 0
    for occurrence in client.list_occurrences(
        parent=parent, filter=filter_str
    ):
        vuln = occurrence.vulnerability
        if vuln.severity in ("CRITICAL", "HIGH"):
            critical_count += 1

    # Fail if there are critical or high vulnerabilities
    return critical_count == 0
```

## Complete CI/CD Pipeline with SLSA

Here is a complete Cloud Build pipeline that builds, scans, attests, and deploys with SLSA Level 3:

```yaml
# cloudbuild-full-pipeline.yaml
# Complete SLSA Level 3 pipeline: build, scan, attest, deploy
options:
  requestedVerifyOption: VERIFIED

steps:
  # Step 1: Run unit tests
  - name: 'python:3.11'
    entrypoint: 'sh'
    args: ['-c', 'pip install -r requirements.txt && pytest']
    id: 'test'

  # Step 2: Build the container image
  - name: 'gcr.io/cloud-builders/docker'
    args:
      - 'build'
      - '-t'
      - 'us-docker.pkg.dev/${PROJECT_ID}/my-repo/my-app:${SHORT_SHA}'
      - '.'
    id: 'build'
    waitFor: ['test']

  # Step 3: Push the image
  - name: 'gcr.io/cloud-builders/docker'
    args:
      - 'push'
      - 'us-docker.pkg.dev/${PROJECT_ID}/my-repo/my-app:${SHORT_SHA}'
    id: 'push'
    waitFor: ['build']

  # Step 4: Wait for vulnerability scanning to complete
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        # Wait for the scan to finish (up to 5 minutes)
        for i in $(seq 1 30); do
          SCAN_STATUS=$(gcloud artifacts docker images describe \
            us-docker.pkg.dev/${PROJECT_ID}/my-repo/my-app:${SHORT_SHA} \
            --show-package-vulnerability \
            --format='value(discovery[0].discovery.analysisStatus)' 2>/dev/null)
          if [ "$SCAN_STATUS" = "FINISHED_SUCCESS" ]; then
            echo "Scan complete"
            break
          fi
          echo "Waiting for scan... attempt $i"
          sleep 10
        done
    id: 'wait-scan'
    waitFor: ['push']

  # Step 5: Create attestation if scan passes
  - name: 'python:3.11'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        pip install google-cloud-binary-authorization \
          google-cloud-containeranalysis google-cloud-kms
        python create_attestation.py \
          --project=${PROJECT_ID} \
          --image=us-docker.pkg.dev/${PROJECT_ID}/my-repo/my-app:${SHORT_SHA}
    id: 'attest'
    waitFor: ['wait-scan']

  # Step 6: Deploy to GKE (only if attested)
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        gcloud container clusters get-credentials ${_CLUSTER} \
          --region ${_REGION}
        kubectl set image deployment/my-app \
          my-app=us-docker.pkg.dev/${PROJECT_ID}/my-repo/my-app:${SHORT_SHA}
    id: 'deploy'
    waitFor: ['attest']

images:
  - 'us-docker.pkg.dev/${PROJECT_ID}/my-repo/my-app:${SHORT_SHA}'
```

## Wrapping Up

SLSA Level 3 with Cloud Build is one of the most impactful supply chain security improvements you can make on GCP. The platform does most of the heavy lifting - isolated build environments and signed provenance come out of the box. Your job is to verify that provenance, enforce it with Binary Authorization, and make sure nothing gets deployed without going through the pipeline. Combined with vulnerability scanning and custom attestations, you get a build system where every deployed artifact has a verifiable chain of custody from source code to production.
