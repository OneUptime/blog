# How to Handle Case-Sensitive Column Names in PostgreSQL

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: PostgreSQL, SQL, Case Sensitivity, Identifiers, Database Design, Best Practices

Description: Master PostgreSQL's case sensitivity rules for column names and identifiers. Learn when to use quoted identifiers, how to avoid common pitfalls, and best practices for naming conventions.

---

PostgreSQL's handling of case sensitivity trips up many developers, especially those coming from MySQL or SQL Server. Understanding how PostgreSQL treats identifiers is essential for writing correct queries and avoiding frustrating "column does not exist" errors.

## How PostgreSQL Handles Identifiers

By default, PostgreSQL folds all unquoted identifiers to lowercase. This means that `UserName`, `USERNAME`, and `username` are all treated as the same identifier when written without quotes.

```sql
-- All of these reference the same column (lowercase 'username')
SELECT Username FROM users;
SELECT USERNAME FROM users;
SELECT username FROM users;

-- PostgreSQL internally converts all to: SELECT username FROM users;
```

When you use double quotes around an identifier, PostgreSQL preserves the exact case.

```sql
-- These reference different columns
SELECT "UserName" FROM users;   -- Looks for column named exactly 'UserName'
SELECT "USERNAME" FROM users;   -- Looks for column named exactly 'USERNAME'
SELECT "username" FROM users;   -- Looks for column named exactly 'username'
```

## Creating Tables with Mixed-Case Columns

The case folding behavior applies during table creation as well.

```sql
-- Without quotes: column is created as lowercase
CREATE TABLE example1 (
    UserID INTEGER,          -- Creates column named 'userid'
    FirstName VARCHAR(50),   -- Creates column named 'firstname'
    LastName VARCHAR(50)     -- Creates column named 'lastname'
);

-- With quotes: exact case is preserved
CREATE TABLE example2 (
    "UserID" INTEGER,        -- Creates column named 'UserID'
    "FirstName" VARCHAR(50), -- Creates column named 'FirstName'
    "LastName" VARCHAR(50)   -- Creates column named 'LastName'
);
```

You can verify the actual column names using the information schema.

```sql
-- Check the actual column names stored in the database
SELECT column_name
FROM information_schema.columns
WHERE table_name = 'example1';

-- Results: userid, firstname, lastname (all lowercase)

SELECT column_name
FROM information_schema.columns
WHERE table_name = 'example2';

-- Results: UserID, FirstName, LastName (case preserved)
```

## The Quoted Identifier Problem

Once you create a column with a quoted mixed-case name, you must always use quotes when referencing it.

```sql
-- Table created with quoted identifiers
CREATE TABLE products (
    "ProductID" SERIAL PRIMARY KEY,
    "ProductName" VARCHAR(100),
    "UnitPrice" DECIMAL(10,2)
);

-- This fails because PostgreSQL looks for lowercase 'productid'
SELECT ProductID FROM products;
-- ERROR: column "productid" does not exist

-- This works because quotes preserve the case
SELECT "ProductID" FROM products;

-- Inserting data also requires quotes
INSERT INTO products ("ProductName", "UnitPrice")
VALUES ('Widget', 29.99);
```

## Renaming Columns to Fix Case Issues

If you have inherited a database with problematic naming, you can rename columns.

```sql
-- Rename mixed-case columns to lowercase
ALTER TABLE products RENAME COLUMN "ProductID" TO product_id;
ALTER TABLE products RENAME COLUMN "ProductName" TO product_name;
ALTER TABLE products RENAME COLUMN "UnitPrice" TO unit_price;

-- Now queries work without quotes
SELECT product_id, product_name, unit_price FROM products;
```

## Working with ORMs and Case Sensitivity

Many ORMs generate mixed-case column names based on class property names. This can create friction with PostgreSQL.

```sql
-- Example: Entity generated by an ORM might create
CREATE TABLE "Users" (
    "Id" INTEGER PRIMARY KEY,
    "CreatedAt" TIMESTAMP,
    "UpdatedAt" TIMESTAMP
);

-- Raw SQL queries become tedious
SELECT "Id", "CreatedAt" FROM "Users" WHERE "Id" = 1;
```

Most ORMs provide configuration to control identifier quoting. For example, with SQLAlchemy:

```python
# SQLAlchemy configuration to use lowercase names
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class User(Base):
    # Explicitly set lowercase table and column names
    __tablename__ = 'users'

    id = Column('id', Integer, primary_key=True)
    first_name = Column('first_name', String(50))
    last_name = Column('last_name', String(50))
```

## Escaping Quotes in Identifiers

If your identifier actually contains a double quote character, escape it by doubling.

```sql
-- Column name with a literal quote: weird"name
CREATE TABLE strange_names (
    id SERIAL PRIMARY KEY,
    "weird""name" VARCHAR(50)  -- Double quote is escaped by doubling
);

-- Query the column
SELECT "weird""name" FROM strange_names;
```

## Reserved Words as Column Names

Quoting is also required when using PostgreSQL reserved words as identifiers.

```sql
-- 'user' is a reserved word
CREATE TABLE accounts (
    id SERIAL PRIMARY KEY,
    "user" VARCHAR(50),     -- Requires quotes
    "select" VARCHAR(50),   -- Requires quotes
    "from" VARCHAR(50)      -- Requires quotes
);

-- Better approach: avoid reserved words entirely
CREATE TABLE accounts (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50),
    selection VARCHAR(50),
    source VARCHAR(50)
);
```

## Best Practices for PostgreSQL Naming

Following consistent naming conventions prevents case sensitivity issues.

```sql
-- Recommended: use snake_case with all lowercase
CREATE TABLE user_accounts (
    user_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email_address VARCHAR(255) UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Queries are clean and predictable
SELECT user_id, first_name, last_name
FROM user_accounts
WHERE created_at > '2026-01-01';
```

## Checking Existing Table Structure

When working with an unfamiliar database, inspect the actual identifier names.

```sql
-- View table structure with exact column names
\d+ table_name

-- Or query the information schema
SELECT
    column_name,
    data_type,
    is_nullable,
    column_default
FROM information_schema.columns
WHERE table_schema = 'public'
    AND table_name = 'your_table'
ORDER BY ordinal_position;

-- Check if any columns require quoting (contain uppercase)
SELECT column_name
FROM information_schema.columns
WHERE table_name = 'your_table'
    AND column_name != lower(column_name);
```

## Dynamic SQL with Case-Sensitive Names

When building dynamic queries, use `quote_ident()` to safely quote identifiers.

```sql
-- Function that safely quotes identifiers
CREATE OR REPLACE FUNCTION get_column_value(
    table_name TEXT,
    column_name TEXT,
    row_id INTEGER
) RETURNS TEXT AS $$
DECLARE
    result TEXT;
BEGIN
    -- quote_ident() adds quotes only when necessary
    EXECUTE format(
        'SELECT %I::TEXT FROM %I WHERE id = $1',
        column_name,
        table_name
    ) INTO result USING row_id;

    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Works correctly regardless of column case
SELECT get_column_value('products', 'ProductName', 1);
SELECT get_column_value('products', 'product_name', 1);
```

## Migration Strategy for Legacy Databases

If you need to standardize naming in an existing database:

```sql
-- Generate ALTER statements to rename all mixed-case columns
SELECT format(
    'ALTER TABLE %I RENAME COLUMN %I TO %I;',
    table_name,
    column_name,
    lower(column_name)
) AS rename_statement
FROM information_schema.columns
WHERE table_schema = 'public'
    AND column_name != lower(column_name);
```

Review the generated statements carefully before executing, especially if your application code references the original column names.

## Handling Case in WHERE Clauses

Case sensitivity also affects string comparisons, but this is separate from identifier handling.

```sql
-- String comparison is case-sensitive by default
SELECT * FROM users WHERE name = 'John';   -- Matches 'John' only
SELECT * FROM users WHERE name = 'john';   -- Matches 'john' only

-- Use ILIKE or LOWER() for case-insensitive matching
SELECT * FROM users WHERE name ILIKE 'john';
SELECT * FROM users WHERE LOWER(name) = 'john';

-- Create a case-insensitive index for better performance
CREATE INDEX idx_users_name_lower ON users (LOWER(name));
```

Understanding PostgreSQL's case handling rules from the start saves hours of debugging. Stick to lowercase snake_case for all identifiers, and you will never need to worry about quoting or case mismatches in your queries.
