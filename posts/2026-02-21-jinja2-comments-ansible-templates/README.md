# How to Use Jinja2 Comments in Ansible Templates

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: Ansible, Jinja2, Templates, DevOps

Description: Learn how to use Jinja2 comments in Ansible templates to document logic without affecting rendered output.

---

When you are working on Ansible templates, especially complex ones that generate Nginx configs, HAProxy settings, or systemd unit files, you need a way to explain your template logic to future maintainers (including your future self). Jinja2 comments give you exactly that: a way to annotate your templates without any of those notes appearing in the rendered output. This is different from the native comment syntax of whatever config format you are generating. Let us dig into how Jinja2 comments work and when to use them.

## Jinja2 Comments vs. Output Comments

There is an important distinction between two types of comments in a template:

1. **Jinja2 comments** - stripped out during rendering, never appear in the output file
2. **Output comments** - regular text that uses the target format's comment syntax (like `#` for YAML or `//` for JSON) and shows up in the rendered file

Here is a template that uses both:

```jinja2
{# This is a Jinja2 comment. It will NOT appear in the output file. #}
# This is an output comment. It WILL appear in the rendered config.
server {
    listen {{ listen_port }};
    {# TODO: Add SSL support once certs are provisioned #}
    server_name {{ server_name }};
}
```

When rendered, the output is:

```nginx
# This is an output comment. It WILL appear in the rendered config.
server {
    listen 80;
    server_name example.com;
}
```

The Jinja2 comment vanished completely. The output comment stayed.

## Basic Jinja2 Comment Syntax

The syntax is straightforward. Wrap your comment text in `{#` and `#}`:

```jinja2
{# Single line comment explaining a variable #}
{{ my_variable }}
```

You can also write multi-line comments:

```jinja2
{#
  Multi-line comment block.
  This is useful when you need to explain
  complex template logic spanning several lines.
#}
```

## Why Use Jinja2 Comments Over Output Comments

You might wonder why you would use Jinja2 comments instead of just writing a regular comment in the target format. There are several good reasons.

First, Jinja2 comments can document template logic that would make no sense to someone reading the output file. Consider this:

```jinja2
{#
  We loop over the 'upstreams' dict. Each key is a pool name,
  each value is a list of server objects with 'host' and 'port' fields.
  The weight defaults to 1 if not specified in the inventory.
#}
{% for pool_name, servers in upstreams.items() %}
upstream {{ pool_name }} {
    {% for server in servers %}
    server {{ server.host }}:{{ server.port }} weight={{ server.weight | default(1) }};
    {% endfor %}
}
{% endfor %}
```

If this comment appeared in the output file, it would confuse anyone reading the Nginx config because it talks about Ansible variables and inventory. It belongs in the template only.

Second, Jinja2 comments do not bloat the output. If you generate configs across hundreds of servers, removing unnecessary comment text saves a small amount of disk space and makes the configs cleaner.

Third, Jinja2 comments let you leave notes about conditional logic, workarounds, or deprecated sections without polluting the rendered configuration.

## Practical Example: Documenting a Complex Template

Let us build a realistic HAProxy configuration template with proper Jinja2 comments:

```jinja2
{# haproxy.cfg.j2
   Generated by Ansible - do not edit manually on the target host.
   Template maintained in: roles/haproxy/templates/haproxy.cfg.j2
   Last major refactor: 2025-09-15 by ops team
#}
global
    maxconn {{ haproxy_maxconn | default(4096) }}
    log /dev/log local0
    {# We use local1 for notice-level messages to separate health check noise #}
    log /dev/log local1 notice
    chroot /var/lib/haproxy
    stats socket /run/haproxy/admin.sock mode 660 level admin
    stats timeout 30s
    user haproxy
    group haproxy
    daemon

{# SSL tuning section - only included when SSL is enabled globally #}
{% if haproxy_ssl_enabled | default(false) %}
    ssl-default-bind-ciphers {{ haproxy_ssl_ciphers }}
    ssl-default-bind-options {{ haproxy_ssl_options | default('no-sslv3 no-tlsv10') }}
    tune.ssl.default-dh-param {{ haproxy_dh_param_size | default(2048) }}
{% endif %}

defaults
    mode http
    log global
    {#
      Timeout values below are in milliseconds.
      These defaults work well for typical web applications.
      Override per-backend if you have long-running requests.
    #}
    timeout connect {{ haproxy_timeout_connect | default('5000ms') }}
    timeout client {{ haproxy_timeout_client | default('50000ms') }}
    timeout server {{ haproxy_timeout_server | default('50000ms') }}
    option httplog
    option dontlognull
    option forwardfor

{# Frontend section - each frontend gets its own bind and ACL rules #}
{% for frontend in haproxy_frontends %}
frontend {{ frontend.name }}
    bind {{ frontend.bind }}
    {# Generate ACL rules for path-based routing #}
    {% for acl in frontend.acls | default([]) %}
    acl {{ acl.name }} {{ acl.criterion }}
    {% endfor %}
    {# Map ACLs to backends #}
    {% for rule in frontend.rules | default([]) %}
    use_backend {{ rule.backend }} if {{ rule.condition }}
    {% endfor %}
    default_backend {{ frontend.default_backend }}
{% endfor %}

{# Backend section - server entries come from the inventory groups #}
{% for backend in haproxy_backends %}
backend {{ backend.name }}
    balance {{ backend.balance | default('roundrobin') }}
    {# Health check configuration #}
    {% if backend.health_check | default(true) %}
    option httpchk {{ backend.health_check_method | default('GET') }} {{ backend.health_check_path | default('/health') }}
    {% endif %}
    {% for server in backend.servers %}
    server {{ server.name }} {{ server.address }}:{{ server.port }} check inter {{ backend.check_interval | default('3000') }}
    {% endfor %}
{% endfor %}
```

Every Jinja2 comment here serves a purpose: explaining why a section exists, documenting default values, or providing context about the data structures being iterated.

## Commenting Out Template Sections

Jinja2 comments are also great for temporarily disabling parts of a template during development or debugging:

```jinja2
{# DISABLED: Rate limiting section - re-enable after load testing
{% if rate_limiting_enabled %}
    stick-table type ip size 100k expire 30s store http_req_rate(10s)
    http-request track-sc0 src
    http-request deny deny_status 429 if { sc_http_req_rate(0) gt 100 }
{% endif %}
#}
```

This is far safer than deleting the code, because it preserves the logic for when you want to bring it back. Just remove the outer `{#` and `#}` and the section is live again.

## Whitespace and Comments

Jinja2 comments support the same whitespace control modifiers as other Jinja2 tags. If your comments are leaving blank lines in the output, use the dash modifier:

```jinja2
{#- This comment strips the preceding whitespace -#}
```

This is useful when you have a comment on its own line and do not want that line to produce a blank line in the output:

```jinja2
server {
{#- Health check location block -#}
    location /health {
        return 200 "OK";
    }
}
```

Without the dashes, you would get a blank line between `server {` and `location /health {`.

## Best Practices for Jinja2 Comments

Here are some guidelines I follow when commenting Ansible templates:

**Add a file header comment.** At the top of every template, include a Jinja2 comment that documents what the template generates, who maintains it, and any important notes about the data structures it expects.

```jinja2
{#
  Template: nginx_vhost.conf.j2
  Generates: Virtual host configuration for Nginx
  Expected variables:
    - vhost_name (string): The server name
    - vhost_port (int): Listen port, defaults to 80
    - vhost_locations (list): Location block definitions
  Managed by: roles/nginx/templates/
#}
```

**Comment on non-obvious defaults.** When you use the `default()` filter, explain why that default was chosen:

```jinja2
{# Max body size set to 10m to support file uploads up to 10MB #}
client_max_body_size {{ nginx_max_body_size | default('10m') }};
```

**Mark sections that depend on specific inventory structures.** If your template expects variables from a particular group_vars file or host_vars layout, note that:

```jinja2
{#
  The 'db_replicas' variable comes from group_vars/databases.yml.
  Each entry must have 'host', 'port', and 'priority' fields.
#}
{% for replica in db_replicas %}
server {{ replica.host }}:{{ replica.port }} priority={{ replica.priority }};
{% endfor %}
```

**Do not over-comment obvious things.** A comment like `{# Loop over servers #}` right before `{% for server in servers %}` adds no value. Save comments for things that need explanation.

## Combining Jinja2 Comments with Ansible Managed Markers

Many teams use the `ansible_managed` variable in their templates to warn that a file is auto-generated:

```jinja2
{# This Jinja2 comment won't appear in output #}
# {{ ansible_managed }}
# Do not edit this file manually - changes will be overwritten by Ansible.
```

The `ansible_managed` line renders as a regular comment in the output file, serving as a warning to anyone who SSH-es into the server and opens the config. The Jinja2 comment above it is just for template maintainers.

## Wrapping Up

Jinja2 comments are a small feature, but using them well makes a big difference in template maintainability. Use `{# #}` to document your template logic, explain default values, note data structure requirements, and temporarily disable sections during development. Keep output comments for things that should be visible in the rendered file, and use Jinja2 comments for everything else. Your teammates (and future you) will appreciate the clarity.
