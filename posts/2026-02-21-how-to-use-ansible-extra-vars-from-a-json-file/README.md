# How to Use Ansible Extra Vars from a JSON File

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: Ansible, Variables, JSON, Automation

Description: Learn how to pass variables to Ansible playbooks from JSON files using the extra-vars flag for dynamic and automated deployments.

---

Extra vars (`-e` or `--extra-vars`) are the highest-priority variables in Ansible. They override everything else, including role defaults, inventory variables, play vars, and even `vars_files`. When you pass extra vars from a JSON file, you can drive playbook behavior with configuration generated by external tools, CI/CD pipelines, or API responses.

## Basic JSON Extra Vars

Pass a JSON file to a playbook using the `@` prefix with the `-e` flag.

```bash
# Pass variables from a JSON file
ansible-playbook deploy.yml -e @deploy-config.json
```

The `@` tells Ansible to read the value from a file rather than interpreting it as an inline variable.

Here is the JSON file:

```json
{
  "app_version": "2.4.1",
  "deploy_env": "production",
  "worker_count": 8,
  "enable_debug": false,
  "allowed_ips": [
    "10.0.1.0/24",
    "10.0.2.0/24"
  ]
}
```

And the playbook that uses these variables:

```yaml
# deploy.yml
# Uses variables passed from an external JSON file
---
- name: Deploy application
  hosts: appservers
  become: yes
  tasks:
    - name: Show deployment parameters
      ansible.builtin.debug:
        msg:
          - "Version: {{ app_version }}"
          - "Environment: {{ deploy_env }}"
          - "Workers: {{ worker_count }}"
          - "Debug: {{ enable_debug }}"
          - "Allowed IPs: {{ allowed_ips | join(', ') }}"

    - name: Deploy the application
      ansible.builtin.template:
        src: app-config.yml.j2
        dest: /etc/myapp/config.yml
        mode: '0640'
```

## JSON Data Types Are Preserved

One of the advantages of JSON over inline extra vars is that data types are preserved. Booleans are real booleans, numbers are numbers, and lists are lists.

```json
{
  "port": 8080,
  "debug": true,
  "tags": ["web", "api", "v2"],
  "limits": {
    "max_connections": 1000,
    "timeout_seconds": 30
  },
  "replicas": 3
}
```

```yaml
# type-demo.yml
# Demonstrates that JSON types are preserved
---
- name: Show JSON type preservation
  hosts: localhost
  gather_facts: no
  tasks:
    - name: Port is an integer
      ansible.builtin.debug:
        msg: "Port {{ port }} + 1 = {{ port + 1 }}"

    - name: Debug is a boolean
      ansible.builtin.debug:
        msg: "Debug mode is {{ 'ON' if debug else 'OFF' }}"

    - name: Tags is a list
      ansible.builtin.debug:
        msg: "Tag: {{ item }}"
      loop: "{{ tags }}"

    - name: Limits is a dictionary
      ansible.builtin.debug:
        msg: "Max connections: {{ limits.max_connections }}"
```

Compare this to inline extra vars where everything is a string:

```bash
# Inline: port is a string "8080"
ansible-playbook deploy.yml -e "port=8080"

# JSON file: port is integer 8080
ansible-playbook deploy.yml -e @config.json
```

## Combining JSON Files with Other Extra Vars

You can pass multiple JSON files and combine them with inline extra vars. Later values override earlier ones.

```bash
# Load base config, then environment overrides, then inline override
ansible-playbook deploy.yml \
  -e @base-config.json \
  -e @production-overrides.json \
  -e "force_deploy=true"
```

```json
// base-config.json
{
  "app_version": "2.4.0",
  "worker_count": 4,
  "log_level": "info",
  "cache_enabled": true
}
```

```json
// production-overrides.json
{
  "worker_count": 16,
  "log_level": "warn",
  "ssl_enabled": true
}
```

The final values are: `app_version: "2.4.0"`, `worker_count: 16`, `log_level: "warn"`, `cache_enabled: true`, `ssl_enabled: true`, `force_deploy: "true"` (string because inline).

## CI/CD Pipeline Integration

JSON extra vars are perfect for CI/CD pipelines where deployment parameters are generated programmatically.

```yaml
# deploy-pipeline.yml
# Designed to be called by CI/CD with generated JSON config
---
- name: Pipeline deployment
  hosts: "{{ target_hosts | default('staging') }}"
  become: yes
  tasks:
    - name: Validate required variables
      ansible.builtin.assert:
        that:
          - app_version is defined
          - deploy_env is defined
          - git_commit is defined
        fail_msg: "Missing required variables. Pass them via -e @config.json"

    - name: Deploy application
      ansible.builtin.copy:
        src: "builds/{{ app_version }}/app.tar.gz"
        dest: /opt/myapp/releases/
        mode: '0644'

    - name: Record deployment metadata
      ansible.builtin.copy:
        content: |
          {
            "version": "{{ app_version }}",
            "environment": "{{ deploy_env }}",
            "git_commit": "{{ git_commit }}",
            "deployed_at": "{{ ansible_date_time.iso8601 }}",
            "pipeline_id": "{{ pipeline_id | default('manual') }}"
          }
        dest: /opt/myapp/deploy-metadata.json
        mode: '0644'
```

A Jenkins pipeline generating the JSON file:

```groovy
// Jenkinsfile snippet
stage('Deploy') {
    steps {
        writeJSON file: 'deploy-config.json', json: [
            app_version: env.BUILD_VERSION,
            deploy_env: 'production',
            git_commit: env.GIT_COMMIT,
            pipeline_id: env.BUILD_ID,
            target_hosts: 'production_servers'
        ]
        sh 'ansible-playbook deploy-pipeline.yml -e @deploy-config.json'
    }
}
```

A GitHub Actions workflow:

```yaml
# .github/workflows/deploy.yml
name: Deploy
on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy'
        required: true
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Generate deployment config
        run: |
          cat > deploy-config.json <<EOF
          {
            "app_version": "${{ github.event.inputs.version }}",
            "deploy_env": "${{ github.event.inputs.environment }}",
            "git_commit": "${{ github.sha }}",
            "pipeline_id": "${{ github.run_id }}"
          }
          EOF

      - name: Run Ansible
        run: ansible-playbook deploy-pipeline.yml -e @deploy-config.json
```

## Generating JSON from Scripts

External scripts can generate the JSON configuration dynamically.

```bash
#!/bin/bash
# generate-config.sh
# Generates deployment configuration JSON from various sources

# Get latest version from API
VERSION=$(curl -s https://api.example.com/releases/latest | jq -r '.version')

# Get current git commit
GIT_COMMIT=$(git rev-parse --short HEAD)

# Determine target hosts from environment
if [ "$1" == "production" ]; then
  TARGET="production_servers"
  WORKERS=16
else
  TARGET="staging_servers"
  WORKERS=4
fi

# Generate JSON config
cat > /tmp/deploy-config.json <<EOF
{
  "app_version": "$VERSION",
  "git_commit": "$GIT_COMMIT",
  "target_hosts": "$TARGET",
  "worker_count": $WORKERS,
  "deploy_timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}
EOF

echo "Generated config:"
cat /tmp/deploy-config.json

# Run Ansible with the generated config
ansible-playbook deploy.yml -e @/tmp/deploy-config.json
```

## Complex Nested JSON Structures

JSON files can contain deeply nested structures that map directly to Ansible dictionaries and lists.

```json
{
  "application": {
    "name": "mywebapp",
    "version": "2.4.1",
    "features": {
      "api_v2": true,
      "websockets": true,
      "legacy_mode": false
    }
  },
  "infrastructure": {
    "load_balancer": {
      "algorithm": "round_robin",
      "health_check_path": "/health",
      "health_check_interval": 10
    },
    "databases": [
      {
        "name": "primary",
        "host": "db-primary.internal",
        "port": 5432,
        "read_only": false
      },
      {
        "name": "replica",
        "host": "db-replica.internal",
        "port": 5432,
        "read_only": true
      }
    ]
  },
  "monitoring": {
    "enabled": true,
    "endpoints": {
      "metrics": "/metrics",
      "health": "/health"
    }
  }
}
```

```yaml
# use-nested-json.yml
# Accesses deeply nested JSON structures
---
- name: Use nested JSON config
  hosts: all
  tasks:
    - name: Show application config
      ansible.builtin.debug:
        msg:
          - "App: {{ application.name }} v{{ application.version }}"
          - "API v2: {{ application.features.api_v2 }}"
          - "LB algorithm: {{ infrastructure.load_balancer.algorithm }}"

    - name: Show database configuration
      ansible.builtin.debug:
        msg: "{{ item.name }}: {{ item.host }}:{{ item.port }} (read_only: {{ item.read_only }})"
      loop: "{{ infrastructure.databases }}"
      loop_control:
        label: "{{ item.name }}"
```

## Validating JSON Input

Always validate external JSON input before using it.

```yaml
# validate-json-input.yml
# Validates JSON extra vars before using them
---
- name: Validate and deploy
  hosts: all
  tasks:
    - name: Verify required top-level keys exist
      ansible.builtin.assert:
        that:
          - app_version is defined
          - app_version is match('^[0-9]+\.[0-9]+\.[0-9]+$')
          - deploy_env is defined
          - deploy_env in ['development', 'staging', 'production']
        fail_msg: |
          Invalid configuration. Required JSON structure:
          {
            "app_version": "X.Y.Z",
            "deploy_env": "development|staging|production"
          }

    - name: Proceed with deployment
      ansible.builtin.debug:
        msg: "Configuration validated. Deploying {{ app_version }} to {{ deploy_env }}."
```

## Summary

Passing extra vars from JSON files is the cleanest way to feed external configuration into Ansible playbooks. JSON preserves data types (booleans, numbers, lists, nested objects), making it superior to inline extra vars for anything beyond simple strings. Use the `@` prefix to specify file paths, combine multiple files for layered configuration, and generate the JSON from CI/CD pipelines or scripts for fully automated deployments. Since extra vars have the highest precedence in Ansible, they reliably override any conflicting values from other sources.
