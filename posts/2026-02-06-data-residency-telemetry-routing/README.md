# How to Implement Data Residency Compliance by Routing Telemetry to Region-Specific Backends Based on Attributes

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: OpenTelemetry, Data Residency, Compliance, Telemetry Routing

Description: Implement data residency compliance by routing OpenTelemetry telemetry to region-specific backends based on resource attributes.

Data residency regulations like GDPR, CCPA, and various national data protection laws require that certain data stays within specific geographic boundaries. When telemetry contains personally identifiable information (PII) or is generated by services handling EU citizens' data, that telemetry must be stored in the EU. This post shows how to implement compliant routing in your OpenTelemetry pipeline.

## The Compliance Challenge

Telemetry data often contains information that falls under data residency requirements:

- User IDs, email addresses, or IP addresses in span attributes
- Request paths that include PII
- Log messages with customer data
- Service names that indicate processing of region-specific data

You need to route this telemetry to the correct geographic region automatically.

## Architecture

```
Services (any region) -> Regional Collector -> Routing Gateway
                                                  |
                            +---------------------+------------------+
                            |                     |                  |
                     EU Backend (Frankfurt)  US Backend (Virginia)  APAC Backend (Singapore)
```

## Step 1: Tag Services with Data Residency Attributes

Add region annotations to your Kubernetes deployments:

```yaml
# eu-service-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: eu-user-service
  namespace: user-management
  labels:
    data-residency: eu
    data-classification: pii
spec:
  template:
    metadata:
      labels:
        app: eu-user-service
        data-residency: eu
        data-classification: pii
    spec:
      containers:
        - name: app
          env:
            - name: OTEL_RESOURCE_ATTRIBUTES
              value: >
                data.residency=eu,
                data.classification=pii,
                service.region=eu-west-1
```

## Step 2: Collector Configuration for Compliant Routing

```yaml
# routing-gateway-config.yaml
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317

processors:
  batch:
    send_batch_size: 4096
    timeout: 1s

  # Extract and validate residency attributes
  k8sattributes:
    extract:
      labels:
        - tag_name: data.residency
          key: data-residency
          from: pod
        - tag_name: data.classification
          key: data-classification
          from: pod

  # Scrub PII from telemetry that crosses regions
  transform/scrub_pii:
    trace_statements:
      - context: span
        statements:
          # Remove PII attributes for non-compliant routing
          - delete_key(attributes, "user.email")
          - delete_key(attributes, "user.id")
          - replace_pattern(attributes["http.url"],
              "email=[^&]*", "email=REDACTED")
          - replace_pattern(attributes["http.url"],
              "token=[^&]*", "token=REDACTED")
    log_statements:
      - context: log
        statements:
          - replace_pattern(body,
              "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}",
              "EMAIL_REDACTED")

  # Route based on data residency attribute
  routing/residency:
    from_attribute: data.residency
    attribute_source: resource
    table:
      - value: eu
        exporters: [otlphttp/eu]
      - value: us
        exporters: [otlphttp/us]
      - value: apac
        exporters: [otlphttp/apac]
    default_exporters: [otlphttp/us]

  # For data that must go to a non-primary region,
  # scrub PII first
  routing/classification:
    from_attribute: data.classification
    attribute_source: resource
    table:
      - value: pii
        pipelines: [traces/pii_handling]
      - value: public
        pipelines: [traces/public]
    default_pipelines: [traces/public]

exporters:
  # EU backend - Frankfurt
  otlphttp/eu:
    endpoint: https://otel-backend.eu-west-1.internal:4318
    headers:
      X-Data-Region: eu
    tls:
      cert_file: /etc/ssl/certs/eu-client.pem
      key_file: /etc/ssl/certs/eu-client-key.pem

  # US backend - Virginia
  otlphttp/us:
    endpoint: https://otel-backend.us-east-1.internal:4318
    headers:
      X-Data-Region: us
    tls:
      cert_file: /etc/ssl/certs/us-client.pem
      key_file: /etc/ssl/certs/us-client-key.pem

  # APAC backend - Singapore
  otlphttp/apac:
    endpoint: https://otel-backend.ap-southeast-1.internal:4318
    headers:
      X-Data-Region: apac
    tls:
      cert_file: /etc/ssl/certs/apac-client.pem
      key_file: /etc/ssl/certs/apac-client-key.pem

service:
  pipelines:
    # Main intake pipeline
    traces:
      receivers: [otlp]
      processors: [k8sattributes, batch, routing/residency]
      exporters: [otlphttp/eu, otlphttp/us, otlphttp/apac]

    # PII data gets extra scrubbing
    traces/pii_handling:
      receivers: [routing/classification]
      processors: [transform/scrub_pii, batch]
      exporters: [otlphttp/eu]  # PII always goes to EU

    traces/public:
      receivers: [routing/classification]
      processors: [batch]
      exporters: [otlphttp/us]  # Public data goes to US (cheapest)

    logs:
      receivers: [otlp]
      processors: [k8sattributes, transform/scrub_pii, batch, routing/residency]
      exporters: [otlphttp/eu, otlphttp/us, otlphttp/apac]
```

## Step 3: Compliance Validation

Build a validator that checks routing rules against compliance requirements:

```python
# compliance_validator.py
import yaml

COMPLIANCE_RULES = {
    "eu": {
        "allowed_regions": ["eu-west-1", "eu-central-1"],
        "requires_pii_scrubbing_for_cross_region": True,
        "max_retention_days": 365,
    },
    "us": {
        "allowed_regions": ["us-east-1", "us-west-2"],
        "requires_pii_scrubbing_for_cross_region": True,
        "max_retention_days": 730,
    },
}

def validate_routing_config(config_path):
    with open(config_path) as f:
        config = yaml.safe_load(f)

    errors = []

    # Check that EU-tagged data goes to EU backends
    routing = config.get("processors", {}).get("routing/residency", {})
    for route in routing.get("table", []):
        region = route["value"]
        exporters = route["exporters"]

        for exporter in exporters:
            endpoint = (config.get("exporters", {})
                       .get(exporter, {}).get("endpoint", ""))

            # Verify the endpoint is in the correct region
            rules = COMPLIANCE_RULES.get(region, {})
            allowed = rules.get("allowed_regions", [])

            region_ok = any(r in endpoint for r in allowed)
            if not region_ok:
                errors.append(
                    f"Route for '{region}' data points to "
                    f"non-compliant endpoint: {endpoint}"
                )

    # Check PII scrubbing exists
    if "transform/scrub_pii" not in config.get("processors", {}):
        errors.append("Missing PII scrubbing processor")

    if errors:
        print("COMPLIANCE VIOLATIONS:")
        for e in errors:
            print(f"  - {e}")
        return False

    print("Routing configuration is compliant")
    return True

if __name__ == "__main__":
    import sys
    ok = validate_routing_config(sys.argv[1])
    sys.exit(0 if ok else 1)
```

## Audit Trail

Log every routing decision for compliance audits:

```yaml
processors:
  # Log routing decisions
  transform/audit:
    trace_statements:
      - context: span
        statements:
          - set(attributes["compliance.routed_to"],
              resource.attributes["data.residency"])
          - set(attributes["compliance.classification"],
              resource.attributes["data.classification"])
          - set(attributes["compliance.routing_timestamp"],
              Now())
```

## Wrapping Up

Data residency compliance for telemetry requires careful routing based on the data's geographic and classification attributes. By combining Kubernetes labels, Collector-level PII scrubbing, and attribute-based routing, you can ensure that telemetry data stays within the required geographic boundaries. Always validate your routing configuration against compliance rules in CI, and maintain an audit trail of routing decisions.
