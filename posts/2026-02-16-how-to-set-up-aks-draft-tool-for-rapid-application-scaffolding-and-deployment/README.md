# How to Set Up AKS Draft Tool for Rapid Application Scaffolding and Deployment

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: AKS, Draft, Kubernetes, Scaffolding, Deployment, DevOps, Azure

Description: Learn how to use the AKS Draft tool to automatically generate Dockerfiles, Kubernetes manifests, and GitHub Actions workflows for your applications.

---

Getting an application from a local development environment to running on AKS involves writing a Dockerfile, creating Kubernetes manifests, setting up a CI/CD pipeline, and configuring an ingress. Each piece is straightforward on its own, but together they represent hours of boilerplate work that looks roughly the same for every project.

The AKS Draft tool automates this scaffolding. It analyzes your source code, detects the language and framework, and generates production-ready Dockerfiles, Kubernetes deployment manifests, Helm charts, and GitHub Actions workflows. Instead of starting from scratch every time, you run a few Draft commands and have a deployable application in minutes.

## What Draft Generates

Draft can create several types of artifacts depending on what you need:

- **Dockerfiles**: Language-specific, multi-stage Dockerfiles optimized for your application type
- **Kubernetes manifests**: Deployments, Services, and Ingress resources
- **Helm charts**: Full Helm chart with values files for parameterized deployments
- **Kustomize overlays**: Kustomize-based deployment configurations
- **GitHub Actions workflows**: CI/CD pipelines that build, push, and deploy your application
- **Azure Pipelines**: Azure DevOps pipeline definitions

## Prerequisites

- Azure CLI 2.50 or later
- An AKS cluster with credentials configured
- An Azure Container Registry
- A source code repository (Draft supports Go, Python, Node.js, Java, .NET, Rust, PHP, Ruby, and more)

## Step 1: Install Draft

Draft is available as an Azure CLI extension and as a standalone binary.

```bash
# Install Draft as an Azure CLI extension
az extension add --name aks-draft

# Verify the installation
az aks draft --help

# Alternatively, install the standalone binary
# On macOS
brew install azure/draft/draft

# On Linux
curl -fsSL https://raw.githubusercontent.com/Azure/draft/main/scripts/install.sh | bash

# Verify standalone installation
draft version
```

## Step 2: Generate a Dockerfile

Navigate to your application's source directory and let Draft create a Dockerfile.

```bash
# Run draft create to generate a Dockerfile
# Draft will auto-detect the language from your source code
az aks draft create

# Or use the standalone CLI
draft create
```

Draft asks a few questions about your application (port number, entry point) and generates a Dockerfile. Here is an example of what Draft generates for a Node.js application:

```dockerfile
# Dockerfile generated by Draft
# Multi-stage build for optimized production image

# Build stage - install dependencies and build the application
FROM node:20-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build

# Production stage - minimal runtime image
FROM node:20-alpine
WORKDIR /app
# Copy only the built artifacts and production dependencies
COPY --from=build /app/node_modules ./node_modules
COPY --from=build /app/dist ./dist
COPY --from=build /app/package.json ./

# Run as non-root user for security
RUN addgroup -S appgroup && adduser -S appuser -G appgroup
USER appuser

EXPOSE 3000
CMD ["node", "dist/index.js"]
```

For a Python Flask application, Draft generates something like:

```dockerfile
# Dockerfile generated by Draft for Python Flask
FROM python:3.12-slim AS builder
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir --prefix=/install -r requirements.txt

FROM python:3.12-slim
WORKDIR /app
COPY --from=builder /install /usr/local
COPY . .

RUN addgroup --system appgroup && adduser --system --ingroup appgroup appuser
USER appuser

EXPOSE 5000
CMD ["gunicorn", "--bind", "0.0.0.0:5000", "app:app"]
```

## Step 3: Generate Kubernetes Manifests

Draft can generate deployment manifests in plain YAML, Helm charts, or Kustomize format.

```bash
# Generate Kubernetes deployment manifests
az aks draft generate-workflow \
  --destination ./manifests \
  --deploy-type manifests

# Or generate a Helm chart
az aks draft generate-workflow \
  --destination ./chart \
  --deploy-type helm

# Or generate Kustomize files
az aks draft generate-workflow \
  --destination ./kustomize \
  --deploy-type kustomize
```

Here is what the generated Kubernetes manifests look like:

```yaml
# manifests/deployment.yaml
# Generated by Draft - Kubernetes deployment for the application
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
  labels:
    app: my-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-app
        image: myregistry.azurecr.io/my-app:latest
        ports:
        - containerPort: 3000
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 256Mi
        livenessProbe:
          httpGet:
            path: /healthz
            port: 3000
          initialDelaySeconds: 15
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
---
# manifests/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-app
spec:
  type: ClusterIP
  ports:
  - port: 80
    targetPort: 3000
  selector:
    app: my-app
```

## Step 4: Set Up Ingress with Draft

Draft can configure ingress routing, including integration with the Web Application Routing addon on AKS.

```bash
# Set up ingress using the AKS Web Application Routing addon
az aks draft setup-gh \
  --app my-app \
  --destination ./manifests \
  --ingress-tls-cert-keyvault-uri "https://myvault.vault.azure.net/certificates/my-cert"
```

The generated ingress manifest:

```yaml
# manifests/ingress.yaml
# Generated by Draft - Ingress with TLS from Key Vault
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-app
  annotations:
    kubernetes.azure.com/tls-cert-keyvault-uri: "https://myvault.vault.azure.net/certificates/my-cert"
spec:
  ingressClassName: webapprouting.kubernetes.azure.com
  tls:
  - hosts:
    - my-app.example.com
    secretName: my-app-tls
  rules:
  - host: my-app.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: my-app
            port:
              number: 80
```

## Step 5: Generate a GitHub Actions Workflow

Draft creates a complete CI/CD pipeline that builds your Docker image, pushes it to ACR, and deploys to AKS.

```bash
# Generate a GitHub Actions workflow
az aks draft setup-gh \
  --app my-app \
  --subscription-id <sub-id> \
  --resource-group myResourceGroup \
  --aks-cluster-name myAKSCluster \
  --container-registry-name myregistry \
  --destination .github/workflows
```

The generated workflow:

```yaml
# .github/workflows/deploy.yaml
# Generated by Draft - Build and deploy to AKS
name: Build and Deploy to AKS

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  AZURE_CONTAINER_REGISTRY: myregistry
  CONTAINER_NAME: my-app
  RESOURCE_GROUP: myResourceGroup
  CLUSTER_NAME: myAKSCluster

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Build and push to ACR
      run: |
        az acr build \
          --registry ${{ env.AZURE_CONTAINER_REGISTRY }} \
          --image ${{ env.CONTAINER_NAME }}:${{ github.sha }} \
          .

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Set AKS context
      uses: azure/aks-set-context@v3
      with:
        resource-group: ${{ env.RESOURCE_GROUP }}
        cluster-name: ${{ env.CLUSTER_NAME }}

    - name: Deploy to AKS
      uses: azure/k8s-deploy@v4
      with:
        manifests: manifests/
        images: |
          ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.CONTAINER_NAME }}:${{ github.sha }}
```

## Step 6: Customize and Deploy

Draft generates sensible defaults, but you should review and customize the output before deploying.

Common customizations:

```bash
# Build and push your image manually to test
az acr build \
  --registry myregistry \
  --image my-app:v1 \
  .

# Deploy the generated manifests
kubectl apply -f manifests/

# Check the deployment
kubectl get pods -l app=my-app
kubectl get svc my-app
kubectl get ingress my-app
```

## Step 7: Update Existing Projects

Draft can update previously generated files when your application changes.

```bash
# Update the Dockerfile if you changed your application's dependencies
az aks draft update

# Regenerate manifests with new settings
az aks draft generate-workflow \
  --destination ./manifests \
  --deploy-type manifests
```

## Language Support and Detection

Draft detects your application language by examining file patterns in your repository:

| Language | Detection | Framework Support |
|----------|-----------|-------------------|
| Node.js  | package.json | Express, Next.js, Fastify |
| Python   | requirements.txt, pyproject.toml | Flask, Django, FastAPI |
| Go       | go.mod | Standard library, Gin, Echo |
| Java     | pom.xml, build.gradle | Spring Boot, Quarkus |
| .NET     | *.csproj, *.sln | ASP.NET Core |
| Rust     | Cargo.toml | Actix, Axum |
| PHP      | composer.json | Laravel |
| Ruby     | Gemfile | Rails, Sinatra |

## Tips for Production Use

Run `draft create` as a starting point, not a final product. The generated Dockerfiles and manifests are good but generic. Add your specific health check endpoints, configure resource limits based on actual usage data, and add environment-specific configurations.

Use Draft with Helm charts rather than plain manifests for production deployments. Helm charts give you the ability to parameterize values across environments (dev, staging, production) without duplicating files.

Commit all Draft-generated files to your repository. Treat them as owned code that you review and maintain, not as generated artifacts that get regenerated every time.

Draft is at its best when onboarding new microservices to your AKS cluster. It removes the friction of writing boilerplate and lets developers focus on application code rather than Kubernetes plumbing. For a team that deploys dozens of services to AKS, that time savings adds up quickly.
