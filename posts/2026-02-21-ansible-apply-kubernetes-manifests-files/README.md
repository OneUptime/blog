# How to Use Ansible to Apply Kubernetes Manifests from Files

Author: [nawazdhandala](https://www.github.com/nawazdhandala)

Tags: Ansible, Kubernetes, Manifests, YAML, DevOps

Description: Apply existing Kubernetes YAML manifest files using Ansible for integrating pre-existing manifests into your automation pipeline.

---

Many teams have a library of Kubernetes YAML manifests that work perfectly well. Rather than rewriting them as inline Ansible definitions, you can apply them directly from files. This is especially useful when you are adopting Ansible gradually, working with manifests generated by other tools, or managing third-party operator installations that ship as raw YAML.

Ansible's `kubernetes.core.k8s` module accepts manifest files through the `src` parameter and also supports applying entire directories of manifests. This guide covers the different approaches and when each makes sense.

## Prerequisites

- Ansible 2.12+ with `kubernetes.core` collection
- A valid kubeconfig
- Kubernetes YAML manifests on disk

```bash
ansible-galaxy collection install kubernetes.core
pip install kubernetes
```

## Applying a Single Manifest File

The simplest case: apply one YAML file to your cluster.

```yaml
# playbook: apply-manifest.yml
# Applies a single Kubernetes manifest file from disk
---
- name: Apply Kubernetes manifest from file
  hosts: localhost
  connection: local
  gather_facts: false

  tasks:
    - name: Apply the deployment manifest
      kubernetes.core.k8s:
        state: present
        src: manifests/deployment.yml
```

The `src` parameter takes a path relative to the playbook or an absolute path. The file can contain any valid Kubernetes resource definition.

Here is what `manifests/deployment.yml` might look like:

```yaml
# manifests/deployment.yml
# Standard Kubernetes Deployment for the web application
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-app
  namespace: production
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web-app
  template:
    metadata:
      labels:
        app: web-app
    spec:
      containers:
        - name: web
          image: myapp/web:v2.1.0
          ports:
            - containerPort: 8080
          resources:
            requests:
              cpu: 200m
              memory: 256Mi
```

## Applying Multi-Document YAML Files

A single YAML file can contain multiple Kubernetes resources separated by `---`. The `k8s` module handles these automatically.

```yaml
# manifests/app-stack.yml
# Contains all resources for the application in one file
---
apiVersion: v1
kind: Namespace
metadata:
  name: myapp
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
  namespace: myapp
data:
  LOG_LEVEL: "info"
  PORT: "8080"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-app
  namespace: myapp
spec:
  replicas: 2
  selector:
    matchLabels:
      app: web-app
  template:
    metadata:
      labels:
        app: web-app
    spec:
      containers:
        - name: web
          image: myapp/web:v2.1.0
          ports:
            - containerPort: 8080
---
apiVersion: v1
kind: Service
metadata:
  name: web-app
  namespace: myapp
spec:
  selector:
    app: web-app
  ports:
    - port: 80
      targetPort: 8080
```

Apply it with a single task:

```yaml
# task: apply the multi-document manifest
- name: Apply the full application stack
  kubernetes.core.k8s:
    state: present
    src: manifests/app-stack.yml
```

## Applying All Manifests in a Directory

When you have a directory full of manifest files, loop through them.

```yaml
# playbook: apply-manifest-directory.yml
# Applies all YAML files from a manifests directory
---
- name: Apply all manifests from directory
  hosts: localhost
  connection: local
  gather_facts: false

  tasks:
    - name: Find all YAML manifest files
      ansible.builtin.find:
        paths: "{{ playbook_dir }}/manifests/base/"
        patterns:
          - "*.yml"
          - "*.yaml"
        recurse: false
      register: manifest_files

    - name: Apply each manifest file
      kubernetes.core.k8s:
        state: present
        src: "{{ item.path }}"
      loop: "{{ manifest_files.files | sort(attribute='path') }}"
      loop_control:
        label: "{{ item.path | basename }}"
```

Sorting by path ensures the files are applied in alphabetical order. If you need specific ordering, prefix your files with numbers: `01-namespace.yml`, `02-configmap.yml`, `03-deployment.yml`.

## Applying Manifests with Variables

Sometimes you want to use existing manifest files but override certain values. Combine `src` with Ansible's lookup and template capabilities.

```yaml
# playbook: apply-manifest-with-overrides.yml
# Loads a manifest, modifies it, and applies the result
---
- name: Apply manifest with variable overrides
  hosts: localhost
  connection: local
  gather_facts: false

  vars:
    image_tag: "v2.3.0"
    replica_count: 5

  tasks:
    - name: Load and modify the deployment manifest
      kubernetes.core.k8s:
        state: present
        definition: "{{ lookup('file', 'manifests/deployment.yml') | from_yaml | combine({'spec': {'replicas': replica_count}}, recursive=True) }}"
```

This loads the YAML file, parses it, merges in the override values, and applies the result. The `combine` filter with `recursive=True` does a deep merge, so nested keys are properly handled.

For more control, you can load, modify, and apply:

```yaml
# task: load, modify image tag, and apply
- name: Load the deployment manifest
  ansible.builtin.set_fact:
    deployment: "{{ lookup('file', 'manifests/deployment.yml') | from_yaml }}"

- name: Override the container image
  ansible.builtin.set_fact:
    deployment: "{{ deployment | combine({'spec': {'template': {'spec': {'containers': [{'name': 'web', 'image': 'myapp/web:' + image_tag}]}}}}, recursive=True, list_merge='replace') }}"

- name: Apply the modified deployment
  kubernetes.core.k8s:
    state: present
    definition: "{{ deployment }}"
```

## Applying Manifests from URLs

You can also apply manifests hosted at a URL, which is common for installing CRDs and operators.

```yaml
# playbook: apply-from-url.yml
# Installs cert-manager CRDs from the project's GitHub release
---
- name: Apply manifests from URL
  hosts: localhost
  connection: local
  gather_facts: false

  tasks:
    - name: Download cert-manager manifest
      ansible.builtin.get_url:
        url: "https://github.com/cert-manager/cert-manager/releases/download/v1.13.3/cert-manager.yaml"
        dest: "/tmp/cert-manager.yaml"
        mode: '0644'

    - name: Apply the downloaded manifest
      kubernetes.core.k8s:
        state: present
        src: "/tmp/cert-manager.yaml"

    - name: Clean up the downloaded file
      ansible.builtin.file:
        path: "/tmp/cert-manager.yaml"
        state: absent
```

## Organizing Manifests with Environments

A practical directory structure for managing manifests across environments:

```
project/
  manifests/
    base/
      namespace.yml
      configmap.yml
      deployment.yml
      service.yml
    overlays/
      staging/
        configmap-patch.yml
        deployment-patch.yml
      production/
        configmap-patch.yml
        deployment-patch.yml
```

```yaml
# playbook: deploy-environment.yml
# Applies base manifests then environment-specific patches
---
- name: Deploy to environment
  hosts: localhost
  connection: local
  gather_facts: false

  vars:
    env: production

  tasks:
    - name: Apply base manifests
      kubernetes.core.k8s:
        state: present
        src: "{{ item }}"
      loop:
        - manifests/base/namespace.yml
        - manifests/base/configmap.yml
        - manifests/base/deployment.yml
        - manifests/base/service.yml

    - name: Apply environment-specific patches
      kubernetes.core.k8s:
        state: present
        src: "{{ item }}"
      with_fileglob:
        - "manifests/overlays/{{ env }}/*.yml"
```

## Dry Run Before Applying

Test what changes would be made without actually applying them.

```yaml
# task: validate manifest without applying
- name: Dry run the deployment manifest
  kubernetes.core.k8s:
    state: present
    src: manifests/deployment.yml
    dry_run: true
    validate:
      fail_on_error: true
  register: dry_run_result

- name: Show what would change
  ansible.builtin.debug:
    msg: "Would change: {{ dry_run_result.changed }}"
```

## Deleting Resources Defined in a File

To remove resources defined in a manifest file, change the state to absent.

```yaml
# task: remove all resources defined in the manifest
- name: Delete resources from manifest file
  kubernetes.core.k8s:
    state: absent
    src: manifests/old-deployment.yml
```

## Summary

Applying Kubernetes manifests from files through Ansible bridges the gap between teams that have existing YAML and those adopting automation. You do not need to rewrite everything as inline Ansible definitions. Use `src` for straightforward file application, `find` and loops for directory-based workflows, and `from_yaml | combine` when you need to inject variables into existing files. This approach lets you adopt Ansible incrementally without throwing away manifests that already work.
